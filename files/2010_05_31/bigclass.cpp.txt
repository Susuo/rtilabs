//////////////////////////////////////////////////////////////////////
// 構築/消滅
//////////////////////////////////////////////////////////////////////


BigClass::DisplayListViewBigIconWin32
(Window* inWindow,__RFILETYPE inNavigateType) : Display(inWindow,inNavigateType)
{
	ASSERT(Win != NULL);

	//Windowsのためのメイン.
BigClass::getMainSystem();

	//メインとなるリストビューの作成.
	ListView.Create(mainSystem->getInstance(),
		mainSystem->getBaseWindow( Win->getIsLeft() ),
		mainSystem->getID() , WS_CHILD | WS_TABSTOP | LVS_ICON | LVS_OWNERDATA | WS_VISIBLE );

	//コールバック登録
	mainSystem->registeCallbackWndProc(Win->getIsLeft(),this);

	//設定を読み込む.
	SetupLoad.Load(FILER_DEFAULT_DEFINE_FILENAME,"FileView");

	this->RfileItems = NULL;
	this->RfileItemsSize = 0;

	//真中に移動する.
	this->HarfWindow();
}


//ウィンドウを半分の位置に移動する.
BigClass::HarfWindow() const
{
BigClass::getMainSystem();
	RECT baseWindowRC ;

	ASSERT(Win != NULL);
BigClass::GetClientRect( mainSystem->getBaseWindow( Win->getIsLeft() ) , &baseWindowRC);

	ListView.MoveWindow(0 , ITEM_PANEL_SIZE , baseWindowRC.right  , baseWindowRC.bottom - ITEM_PANEL_SIZE - STATUS_BAR_SIZE);
	
}

BigClass::~DisplayListViewBigIconWin32()
{
	//関連付けられているイメージリストを勝手に破棄しやがるので
	//無効なリストに摩り替えて、勝手には破棄されないようにします。
	//イメージリストは共有のものをつかっているからねー
	//破棄しちゃうともう一つのウィンドウでいちきなりイメージリストがエラーで大変なことになる。
	//このデバックで2時間かかったぢゃないかプンプン.
	ListView.setImageList(NULL , LVSIL_NORMAL);

BigClass::getMainSystem();
	mainSystem->UnregisteCallbackWndProc(Win->getIsLeft(),this);

	this->RfileItems = NULL;
	this->RfileItemsSize = 0;
}

//WindowProcを受け取る
//自分が処理する場合は true を返す。 戻り値は outRet に代入する。
//自分は処理しない奴は false を返す。
BigClass::WndProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,LRESULT* outRet)
{
    switch(msg)
	{
	case WM_SIZE:
		if (IsWindowVisible( ListView.getWindowHandle() ) )		HarfWindow();
		break;
	case WM_NOTIFY:
		{
			if (!IsWindowVisible( ListView.getWindowHandle() ) ) return false;

			LPNMHDR nmhdr = (LPNMHDR)lparam;
			if (nmhdr->hwndFrom != ListView.getWindowHandle() )	return false;

			switch(nmhdr->code)
			{
			case LVN_GETDISPINFO:
				{
					if (this->OnGetDispInfo((NMLVDISPINFO*) lparam) )
					{
						*outRet = 0;
						return true;
					}
				}
				break;
			case NM_DBLCLK:	//ダブルクリックされたとき
				{
					if (this->OnDoubleClick() )
					{
						*outRet = 0;
						return true;
					}
				}
				break;
			case NM_RCLICK:
				{
					if (this->OnRClick((LPNMHDR)lparam) )
					{
						*outRet = 0;
						return true;
					}
				}
				break;
			case LVN_COLUMNCLICK:	//カラムをクリックされたとき
				{
					if (this->OnColumnClick((LPDRAWITEMSTRUCT) lparam ) )
					{
						*outRet = 0;
						return true;
					}
				}
				break;
			case LVN_KEYDOWN:
				{
					if (OnKeyDown(((LPNMKEY)lparam)->nVKey , MODIFY_KEY_NONE) ) 
					{
						*outRet = 0;
						return true;
					}
				}
			case NM_SETFOCUS:
				{
					//フォーカスが変わったことを通知.
BigClass::getFiler();
					filer->OnChangeFocus( Win->getIsLeft() );
					*outRet = 0;
					return true;
				}
			}

		}
		break;
	}
	return false;
}

//キーが押されたときの処理
BigClass::OnKeyDown(unsigned char inKeyCode  , int inModifyKey ) const
{
	try
	{
		return this->SetupLoad.KeyDown(inKeyCode, (MODIFY_KEY) inModifyKey);
	}
	catch(RParseException e)
	{
		printf("エラーが発生しました:\n%s\n", e.getMessage() );
	}
	return false;
}

//FixedColumが変更されたときに呼ばれる.
BigClass::OnChangeFixedColum()
{
}

//表示項目の設定
BigClass::setRfileItems(int inSize,const Rfile** inRfileItems)
{
	this->RfileItems = inRfileItems;
	this->RfileItemsSize = inSize;

	//イメージリストセット.
BigClass::getInstance()->getImageList() , LVSIL_NORMAL);

	//これを呼び出すと、LVN_GETDISPINFO が呼ばれるらしいので、先に
	//RfileItems RfileItemsSize をセットしないと落ちでー
	ListView.SetItemCountEx(inSize ,0 );

	//すべての選択を解除します。
	ListView.ResetSelect();

	//アクティヴな選択を前回のディレクトリに合わせます。
	const string lastPath = Win->getLastPath();
	const string nowPath = Win->getNowPath();
	if (nowPath != lastPath.substr( 0 ,nowPath.size() ) )
	{	//新しく入ったディレクトリなので、先頭のアイテムにフォーカスを当てます。
		ListView.SetItemState(0 , LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
		TRACE("次のパスは一致しなかったたです %s -> %s\n" ,lastPath.c_str() ,  nowPath.c_str() );
	}
	else
	{	//対象ファイルをスキャンします。

		//サーチするターゲット.
		string filename = lastPath.substr( nowPath.size() );
		//ディレクトリなど、最後の \\ が入っている場合があるので切り落とします。
BigClass::IsPathToComplement(filename) )
		{
			filename = filename.substr(0 , filename.size() - 1 );
		}

		for(int i = 0; i<inSize ; i++)
		{
			if ( inRfileItems[i]->getVars(__FILECOLUMN_TYPE_NAME) == filename)
			{//ヒット.
				ListView.SetItemState(i , LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
				break;
			}
		}
		if (i==inSize)
		{//ヒットしなかった場合は、やはり、先頭に合わせます。
			ListView.SetItemState(0 , LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
		}
	}

}



//ダブルクリック
BigClass::OnDoubleClick() const
{
	//マウスクリック関係はどこか選択されていることが条件です。
	//どこも選択されていない場合は、キャンセルする.
	if ( ListView.HitItem() == -1) return false;

	return OnKeyDown(VK_LBUTTON , MODIFY_KEY_DBCLICK);
}

//カラムクリック
BigClass::OnColumnClick(LPDRAWITEMSTRUCT inItem) const
{
	return true;
}

//アクティヴになりました
BigClass::OnActive()  const
{
	HarfWindow();

	ListView.Show();

BigClass::SetFocus( ListView.getWindowHandle() );
}

//非アクティヴになりました
BigClass::OnNoActive() const
{
	ListView.Hide();
}


BigClass::OnGetDispInfo(NMLVDISPINFO* inInfo) const
{
	if (!RfileItems) return false;
	LVITEMA * item = &inInfo->item;

	const Rfile* rf = this->RfileItems[item->iItem];

	item->iImage = rf->getImageIndex();
	item->stateMask = 0;
	item->state = 0;
	item->pszText = (char*) rf->getVars(__FILECOLUMN_TYPE_NAME).c_str();
	return true;
}

BigClass::OnCustomDraw(NMLVCUSTOMDRAW* inCustomDraw ) const
{
	return false;
}

//現在カーソルがあるファイル名を取得します。
BigClass::getActiveFilename() const 
{
	const int index = ListView.getNowSelected();
	if (index < 0 || index >= RfileItemsSize) return "";

	//Rfile 取得.
	const Rfile* rf = this->RfileItems[index];

	return rf->getVars(__FILECOLUMN_TYPE_NAME);
}

//現在マークされているファイルを渡します。
BigClass::getMarkFilenames() const 
{
	StringList selected;

	int index = -1;
	while((index = ListView_GetNextItem(ListView.getWindowHandle(), index, LVNI_ALL | LVNI_SELECTED))!=-1)
	{
		//念のため
		if (index < 0 || index >= RfileItemsSize) continue;

		//Rfile 取得.
		const Rfile* rf = this->RfileItems[index];

		selected.push_back( rf->getVars(__FILECOLUMN_TYPE_NAME) );
	}

	return selected;
}


//右クリック
BigClass::OnRClick(const NMHDR * inNmhdr) 
{
	try
	{
		//どこも選択されていない場合は、現在位置のアイテムを選択させる.
		//クリックした位置にあるアイテムをアクティヴにする.
		const int item = ListView.HitItem();
		if (item != -1)
		{
			//その位置のアイテムは選択されていますか?
			if (! (ListView.GetItemState(item , LVIS_SELECTED) & (LVIS_SELECTED)) )
			{
				//選択されていないので、現在選択されているアイテムをすべて解除し、
				ListView.ResetSelect();

				//現在アイテムを選択させます。
				ListView.SetItemState(item , LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
				
			}
		}

		//ポップアップ.
		PopupMenu("Popup");
	}
	catch(RException e)
	{
		printf("エラーが発生しました:\n%s",e.getMessage() );
		return false;
	}

	return true;	
}


//指定したメニューをポップアップする.
BigClass::PopupMenu(const string inMenuName) const throw(RWin32Exception,RParseException,RNotFoundException) 
{
	POINT pt;
	GetCursorPos(&pt);

	return SetupLoad.Popup(inMenuName , pt , ListView.getWindowHandle());
}

//表示するものの作成.
BigClass::CreateShowObject(const PathInterface* inPath) 
{

}

BigClass::RAddressBarWin32(FilerSub* inFilerSub) : RAddressBar(inFilerSub )
{
BigClass::getMainSystem();

	//作成.
	this->WindowHandle = 
BigClass::CreateWindow( "STATIC" , "" ,WS_CHILD | WS_VISIBLE , 
		CW_USEDEFAULT , CW_USEDEFAULT , CW_USEDEFAULT , CW_USEDEFAULT ,
	    mainSystem->getBaseWindow( FSub->getIsLeft() ) , 
		(HMENU)mainSystem->getID(),mainSystem->getInstance() , NULL);
	this->EditHandle = 
BigClass::CreateWindow( "EDIT" , "" ,WS_CHILD | WS_TABSTOP | WS_VISIBLE | ES_AUTOHSCROLL, 
		CW_USEDEFAULT , CW_USEDEFAULT , CW_USEDEFAULT , CW_USEDEFAULT ,
		this->WindowHandle ,(HMENU)mainSystem->getID(),mainSystem->getInstance() , NULL);
	//Editのサブクラス化.
	AddressOrignalWindowProc = 
		(WNDPROC) GetWindowLong( this->EditHandle, GWL_WNDPROC);
	SetWindowLong( this->EditHandle , GWL_USERDATA, (LONG)this );
	SetWindowLong( this->EditHandle , GWL_WNDPROC, (LONG)AddressWindowProcStatic);

	//オートコンプリートの実装
	//http://www.runan.net/program/tips/sdk.shtml
	typedef HRESULT (WINAPI *SHAUTOCOMPLETE)    (HWND hwndEdit, DWORD dwFlags);
	RAutoLibrary Lib;
	Lib.Create("SHLWAPI.DLL");
	SHAUTOCOMPLETE SHAutoCompleteAPI = (SHAUTOCOMPLETE) Lib.GetProcAddress("SHAutoComplete");
	if (SHAutoCompleteAPI)
	{
		HRESULT ret = SHAutoCompleteAPI(this->EditHandle, SHACF_DEFAULT);
		if (ret == S_OK)
		{
			TRACE("SHAutoCompleteAPI error\n");
		}
	}

	OnSize();
}

BigClass::~RAddressBarWin32()
{
BigClass::DestroyWindow(this->EditHandle);
BigClass::DestroyWindow(this->WindowHandle);
}

//サイズが変更されたときに呼び出される
BigClass::OnSize()
{
	RECT itemRC;
BigClass::getMainSystem();

BigClass::GetClientRect( mainSystem->getBaseWindow( FSub->getIsLeft() ) , &itemRC);

	//アドレスバー
	MoveWindow(this->WindowHandle , itemRC.left , itemRC.top + ADDRESS_BAR_START , itemRC.right , itemRC.top + ADDRESS_BAR_SIZE , TRUE);
	//アドレスバーのエディットボックス.
	MoveWindow(this->EditHandle , 0 , 0 , itemRC.right , ADDRESS_BAR_SIZE , TRUE);
}

//ウィンドウプロシージャ.
BigClass::AddressWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
	switch(msg)
	{
	case WM_KEYDOWN:
		if (wparam == VK_RETURN)
		{
			char pathBuffer[MAX_PATH];
			GetWindowText(this->EditHandle ,pathBuffer ,  MAX_PATH);

			if (GetAsyncKeyState( VK_SHIFT) & 0x8000)
				NewView(pathBuffer);
			else
				PathView(pathBuffer);

			return 0;
		}
		break;
	}
	return ( CallWindowProc( AddressOrignalWindowProc ,
												hwnd,msg,wparam,lparam) );
}

//指定したパスを閲覧する.
BigClass::PathView(string inPath)
{
	Window* win = FSub->getActiveWindow();
	if (win)
	{
		//現在のウィンドウで閲覧する.
		win->PreviewOrLs( inPath );
	}
	else
	{
		//新しいウィンドウでパスを閲覧する.
		NewView(inPath);
	}
}

//新しいウィンドウでパスを閲覧する.
BigClass::NewView(string inPath)
{
	FSub->setActiveWindow( FSub->NewWindow( inPath ) );
}

//パスが変更されたときに呼び出される.
BigClass::OnAddressChange(string inNewPath)
{
	SetWindowText(this->EditHandle , inNewPath.c_str() );
}


//計算式をセット.
BigClass::setExpression(string inExpression)
{
	this->Expression = inExpression;
	this->Pos = 0;
}

BigClass::getExpression()
{
	return this->Expression;
}

//トークン分割.
BigClass::getToken() throw(RParseException)
{
	const char* p = this->Expression.c_str() ;
	int i = this->Pos;
	for( ; TRIM_SPACE( p[i] ) ; i++);
	if (p[i] == '\0' ) return "";

	switch(p[i])
	{
	case '+':	case '-':	case '*':	case '/':	case '(':	case ')':
		this->Pos = i+1;
		return Expression.substr(i,1);
	case '0':	case '1':	case '2':	case '3':	case '4':	case '5':
	case '6':	case '7':	case '8':	case '9':
		{
			int hit = i;
			//数字以外が現れるのを待つ.
			for(i++; p[i] >= '0' && p[i] <= '9' ; i++);

			this->Pos = i;
			return Expression.substr(hit ,i - hit);
		}		
	}
	throw RParseException("数式 %s の %d 番目に解析不能の文字が現れました\n",this->Expression.c_str() ,i );
}



BigClass::test()
{
	RExprToken token;
	token.setExpression("1 + 1 * 2	+ 1 / 455/ 2324 * 12 +343     + 2456*1123");

	ASSERT( token.getToken() == "1");
	ASSERT( token.getToken() == "+");
	ASSERT( token.getToken() == "1");
	ASSERT( token.getToken() == "*");
	ASSERT( token.getToken() == "2");
	ASSERT( token.getToken() == "+");
	ASSERT( token.getToken() == "1");
	ASSERT( token.getToken() == "/");
	ASSERT( token.getToken() == "455");
	ASSERT( token.getToken() == "/");
	ASSERT( token.getToken() == "2324");
	ASSERT( token.getToken() == "*");
	ASSERT( token.getToken() == "12");
	ASSERT( token.getToken() == "+");
	ASSERT( token.getToken() == "343");
	ASSERT( token.getToken() == "+");
	ASSERT( token.getToken() == "2456");
	ASSERT( token.getToken() == "*");
	ASSERT( token.getToken() == "1123");
}

//計算開始.
BigClass::Expr(string inExpression) throw(RParseException)
{
	Token.setExpression(inExpression);

	getToken();

	return expression();
}

//式
BigClass::expression() throw(RParseException)
{
	int ans = term();
	while(1)
	{
		if (NextToken == "+")
		{
			getToken();
			ans = ans + term();
		}
		else if (NextToken == "-")
		{
			getToken();
			ans = ans - term();
		}
		else break;
	}
	return ans;
}

//項
BigClass::term() throw(RParseException)
{
	int ans = factor();
	while(1)
	{
		if (NextToken == "*")
		{
			getToken();
			ans = ans * factor();
		}
		else if (NextToken == "/")
		{
			getToken();
			ans = ans / factor();
		}
		else break;
	}
	return ans;
}

//因子
BigClass::factor() throw(RParseException)
{
	if (NextToken == "(")
	{
		getToken();
		int ans = this->expression();

		if (NextToken != ")") RParseException("数式 %s で括弧が対応していないようです\n",Token.getExpression().c_str() );

		getToken();
		return ans;
	}
	else
	{
		int ans = atoi( NextToken.c_str() );
		getToken();

		return ans;
	}

}


BigClass::test()
{
	RExpr expr;
	ASSERT(expr.Expr("1+1") == 2);
	ASSERT(expr.Expr("1+1*10") == 11);
	ASSERT(expr.Expr("1+1*10+2") == 13);
	ASSERT(expr.Expr("(1+1)*10+2") == 22);
}


//登録します。
BigClass::Attach(const Rfiles* inRfiles ,const char* inName,__int64 inSize,__int64 inDate,DWORD inAttrib)
{
	this->Name = inName;
	this->Size = inSize;
	this->Date = inDate;
	this->Attrib = inAttrib;

	//ファイル修飾子の取得
	if ( IsDirectory() ) 
	{
		this->FileModify = this->DirectoryLoadModifty( inRfiles->getPath() + inName);
	}
	else
	{
BigClass::Filename2Ext(inName) ;

		if (ext == "EXE")
		{//特殊ファイル キャッシュしません.
BigClass::__SYSTEMICON_EXEFILE);
		}
		else if (ext == "LNK" || ext == "ICO")
		{//特殊ファイル キャッシュしません.
BigClass::__SYSTEMICON_NORMALFILE);
		}
		else
		{//一般ファイル キャッシュします。
			this->FileModify = this->NormalLoadModifty(ext ,inRfiles->getPath() + inName);
		}
	}
	ASSERT(this->FileModify);
}

//値の取得.
BigClass::getVars(__FILECOLUMN_TYPE inType) const
{
	switch(inType)
	{
	case __FILECOLUMN_TYPE_NAME:			//名前
		return Name;
	case __FILECOLUMN_TYPE_EXT:				//タイプ(拡張子に関連付けられている名前)
		return FileModify->getFileType();
	case __FILECOLUMN_TYPE_SIZE:			//サイズ
		return "";
	case __FILECOLUMN_TYPE_DATE:			//更新日付
		return "";
	case __FILECOLUMN_TYPE_ATTRIB:			//属性
		return "";
	}
	return "";
}

//イメージの取得.
BigClass::getImageIndex() const
{
	return FileModify->getIndex();
}


//特殊なファイル修飾子の取得.
BigClass::NormalLoadModifty(string inExt , string inFullFilename )
{
BigClass::getInstance();
	FileModifyData* p = fmc->Search( inExt );
	if (!p)
	{
		//ないので取得.
		SHFILEINFO  shfi = {0};
		SHGetFileInfo( inFullFilename.c_str() , FILE_ATTRIBUTE_ARCHIVE, &shfi, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_DISPLAYNAME | SHGFI_TYPENAME);

		//取得失敗、システムの普通のファイルのアイコンを返します。
		if (shfi.hIcon == NULL) 
		{
BigClass::__SYSTEMICON_NORMALFILE);
		}
		else
		{//アイコン取得完了
			//ファイルタイプ取得できやんした?
			if (shfi.szTypeName[0] != '\0')
				p = fmc->Tearch(inExt , shfi.hIcon, shfi.szTypeName );
			else
				p = fmc->Tearch(inExt , shfi.hIcon,  inExt + "ファイル");
			DestroyIcon(shfi.hIcon);
		}
	}
	return p;
}

//特殊なファイル修飾子の取得.
BigClass::SpecialLoadModifty(string inExt , string inFullFilename ,
BigClass::Modifty inDefaultIconIndex )
{
BigClass::getInstance();
	//特殊ファイル キャッシュしません.
	SHFILEINFO  shfi = {0};
	SHGetFileInfo( inFullFilename.c_str() , FILE_ATTRIBUTE_ARCHIVE, &shfi, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_DISPLAYNAME | SHGFI_TYPENAME);
	//取得失敗、システムの普通のファイルのアイコンを返します。
	if (shfi.hIcon == NULL) 
	{
		return fmc->SearchSystem(inDefaultIconIndex);
	}
	else
	{//アイコン取得完了
		FileModifyData* p ;
		//特殊なアイコンなので非キャッシュとして登録します。
		//ファイルタイプ取得できやんした?
		if (shfi.szTypeName[0] != '\0')
			p = fmc->Tearch( shfi.hIcon, shfi.szTypeName );
		else
			p = fmc->Tearch( shfi.hIcon,  inExt + "ファイル");
		DestroyIcon(shfi.hIcon);
		return p;
	}
}

//ディレクトリのファイル修飾子の取得.
BigClass::DirectoryLoadModifty(string inFullFilename )
{
BigClass::getInstance();

	SHFILEINFO  shfi = {0};
	SHGetFileInfo( inFullFilename.c_str(), FILE_ATTRIBUTE_ARCHIVE, &shfi, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_DISPLAYNAME );

	//取得失敗、システムの普通のディレクトリのアイコンを返します。
	if (shfi.hIcon == NULL) 
	{
BigClass::__SYSTEMICON_NORMALFOLDER);
	}
	else
	{//アイコン取得完了
		FileModifyData* p ;
		if (shfi.dwAttributes & SFGAO_SHARE)
		{//共有ディレクトリ
			if ( FILE_EXIST((inFullFilename + "\\desktop.ini").c_str()) )
			{
BigClass::FOLDER_STRING );
			}
			else
			{
BigClass::__SYSTEMICON_NORMALFOLDER);
			}
			//本当はmix とかごにょごにょする.
		}
		else
		{
			if ( FILE_EXIST((inFullFilename + "\\desktop.ini").c_str()) )
			{
BigClass::FOLDER_STRING );
			}
			else
			{
BigClass::__SYSTEMICON_NORMALFOLDER);
			}
		}
		DestroyIcon(shfi.hIcon);
		return p;
	}
}
// RfilesLocal.cpp: RfilesLocal クラスのインプリメンテーション
//
//////////////////////////////////////////////////////////////////////


//初期化できなかった場合は RNotSupportException を投げる.
BigClass::RfilesLocal(__RFILETYPE inRfileType , const string inPath) 
{
	RfileType = inRfileType;
	Path = inPath;

	switch(RfileType)
	{
	case __RFILETYPE_LOCALFILE_REPORT:
	case __RFILETYPE_LOCALFILE_BIGICON:
		break;
	default:
		break;
	}
}
//final
BigClass::~RfilesLocal()
{
}

//一覧取得
BigClass::ls()
{
	WIN32_FIND_DATA data;
	HANDLE p;

	RTable * rt = getWritebleTable();

	rt->clear();

	string wildpath = this->Path + "*.*";
	__FILECOLUMN_TYPE sortkey = rt->GetSortKey();
BigClass::FindFirstFile( wildpath.c_str() , &data);
	if (p != INVALID_HANDLE_VALUE)
	{
		do
		{
			// . または .. のファイルは無視.
			if ( (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && 
				(data.cFileName[0] == '.' && (data.cFileName[1] == '\0' || (data.cFileName[1] == '.' && data.cFileName[2] == '\0') ) )
			)	continue;

BigClass::New(RfileType);
			p->Attach(this , data.cFileName , 
				INT64CONVERT(data.nFileSizeHigh , data.nFileSizeLow)  ,
				INT64CONVERT(data.ftCreationTime.dwHighDateTime , data.ftCreationTime.dwLowDateTime) ,
				data.dwFileAttributes);
			p->SortAttach( sortkey );
			rt->add( p );
		}
BigClass::FindNextFile( p , &data) );
BigClass::FindClose(p);
	}

	rt->Sort();
	rt->createAllList( );
}
//一覧取得
BigClass::ls(string inFilter)
{
	WIN32_FIND_DATA data;
	HANDLE p;

	RTable * rt = getWritebleTable();

	//検索用正規表現を設定.
BigClass::reg_expression<char> filterRegex  = inFilter.c_str();
BigClass::match_results<const char*> results;

	rt->clear();

	string wildpath = this->Path + "*.*";
	__FILECOLUMN_TYPE sortkey = rt->GetSortKey();
BigClass::FindFirstFile( wildpath.c_str() , &data);
	if (p != INVALID_HANDLE_VALUE)
	{
		do
		{
			// . または .. のファイルは無視.
			if ( (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && 
				(data.cFileName[0] == '.' && (data.cFileName[1] == '\0' || (data.cFileName[1] == '.' && data.cFileName[2] == '\0') ) )
			)	continue;

BigClass::regex_search(data.cFileName , results,filterRegex) == 0) continue;

BigClass::New(RfileType);
			p->Attach(this , data.cFileName , 
				INT64CONVERT(data.nFileSizeHigh , data.nFileSizeLow)  ,
				INT64CONVERT(data.ftCreationTime.dwHighDateTime , data.ftCreationTime.dwLowDateTime) ,
				data.dwFileAttributes);
			p->SortAttach( sortkey );
			rt->add( p );
		}
BigClass::FindNextFile( p , &data) );
BigClass::FindClose(p);
	}

	rt->Sort();
	rt->createAllList( );
}
//削除
BigClass::rm(string inFilename)
{
}
//リネーム
BigClass::rename(string inSrcFilename,string inDestFilename)
{
}
//種類を返す.
BigClass::getRfileType()	const
{
	return RfileType;
}
//パスの取得
BigClass::getPath() const 
{
	return Path;
}
//パスの設定
BigClass::setPath(const string inPath)  
{
	this->Path = inPath;
}
//RTableを作成します。
//ls を使う前に呼んでください。
//作成できない __FILECOLUMN_TYPE が渡されたら例外 RNotSupportExceptionを返します。
BigClass::MakeTable(__FILECOLUMN_TYPE inKey,bool IsAscending) throw()
{
	switch(inKey)
	{
	case __FILECOLUMN_TYPE_NAME:
		setTable( new RTableEasy(inKey,IsAscending) );
		break;
	case __FILECOLUMN_TYPE_EXT:
		setTable( new RTableMuchDuplication<string>(inKey,IsAscending) );
		break;
	case __FILECOLUMN_TYPE_SIZE:
//			setTable( new RTableLittleDuplication<__int64>(inKey,IsAscending) );
		break;
	case __FILECOLUMN_TYPE_DATE:
//			setTable( new RTableLittleDuplication<__int64>(inKey,IsAscending) );
		break;
	default:
		throw RNotSupportException("指定されたタイプのカラム %d はサポートされていません",inKey);
		break;
	}
	return;
}

//テスト.
BigClass::test()
{
	{
		RfilesLocal p(__RFILETYPE_LOCALFILE_REPORT,"c:\\test\\");

		//一覧取得
		p.MakeTable(__FILECOLUMN_TYPE_EXT,true);
		p.ls(  );

		const RTable* rt = p.getTable();

		//一覧を照合
		DisplayDebugPrintf ddp;
		ddp.setRfileItems( rt->getAllSize() , rt->getAllList() );

		string DebugString = "1039.jpg ★ JPGファイル 2get.jpg ★ JPGファイル giko2a.jpg ★ JPGファイル NHKにモナー.jpg ★ JPGファイル NHKにモナー2.jpg ★ JPGファイル おにぎりわっしょい.jpg ★ JPGファイル サッカーで（ﾟдﾟ）ﾊｧ.jpg ★ JPGファイル ホームラン級のバカ.jpg ★ JPGファイル メラゾーマ.jpg ★ JPGファイル 稲垣メンバー.jpg ★ JPGファイル 激しく同意.jpg ★ JPGファイル 逝って良しケーキ.jpg ★ JPGファイル 名スレの予感.jpg ★ JPGファイル 名無しさん@ゴーゴーゴー.jpg ★ JPGファイル ";
		if ( ddp.DebugBuffer != DebugString )
		{
			TRACE("\n%s\n",ddp.DebugBuffer.c_str());
			ASSERT(0);
		}

	}
	{
		//取得できないディレクトリーを設定してみる
		RfilesLocal p(__RFILETYPE_LOCALFILE_REPORT,"c:\\t国崎最高!!");

		//一覧取得
		p.MakeTable(__FILECOLUMN_TYPE_EXT,true);
		p.ls();

		const RTable* rt = p.getTable();

		//一覧を照合
		DisplayDebugPrintf ddp;
		ddp.setRfileItems( rt->getAllSize() , rt->getAllList() );

		string DebugString = "";

		if ( ddp.DebugBuffer != DebugString )
		{
			TRACE("\n%s\n",ddp.DebugBuffer.c_str());
			ASSERT(0);
		}
	}
}

BigClass::RInputDialog() 
{
	AutoComplete = NULL;
	EnumStr = NULL;
}

BigClass::~RInputDialog()
{
	if (AutoComplete) AutoComplete->Release();
//	if (EnumStr)	EnumStr->Release();
}

BigClass::DoModal(string inTitle , string inAutoCompleteName , string inDefualt)	throw(RWin32Exception,RNoComplateException)
{
	Title = inTitle;
	AutoCompleteName = inAutoCompleteName;
	Defualt = inDefualt;

BigClass::getMainSystem();
BigClass::DialogBoxParam(mainSystem->getInstance() ,"INPUTDIALOG", mainSystem->getWindowHandle() , (DLGPROC)DlgProcStatic ,(LPARAM) this);
	if ( ret == -1 )
	{
		throw RWin32Exception("入力ダイアログを作成できません");
	}
	//キャンセルされた場合
	if (ret == IDCANCEL)
	{
		throw RNoComplateException("入力ダイアログでキャンセルされました");
	}
	if (InputData.empty() )
	{
		throw RNoComplateException("入力ダイアログで NULL が入力されました");
	}

	return InputData;
}

//ウィンドウプロシージャ.
BigClass::DlgProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
	switch(msg)
	{
	case WM_INITDIALOG:
		return OnInitDialog() != false;
	case WM_COMMAND:
		{
			int p = LOWORD(wparam);
			switch (LOWORD(wparam)) 
			{
			case IDOK:
				OnOK();
				break;
			case IDCANCEL:
				OnCancel();
				break;
			}
		}
		break;
	}
	return FALSE;
}

//OKをおされたときの処理.
BigClass::OnOK()
{
	//エディットボックス入力されている値を  InputData に取得.
	HWND	EditWindowHandle = GetDlgItem(this->WindowHandle, IDC_INPUTEDIT);
	char	buf[MAX_PATH];
	GetWindowText(EditWindowHandle , buf , MAX_PATH); 
	InputData = buf;

BigClass::EndDialog(this->WindowHandle , IDOK);
}

//キャンセルをおされたときの処理.
BigClass::OnCancel()
{
BigClass::EndDialog(this->WindowHandle , IDCANCEL);
}

BigClass::OnInitDialog()
{

BigClass::getMainSystem();
	try
	{
		//タイトルにセット
		SetWindowText(this->WindowHandle , Title.c_str() );

		//エディットボックスにディフォルトをセット.
		HWND	EditWindowHandle = GetDlgItem(this->WindowHandle, IDC_INPUTEDIT);
		SetWindowText(EditWindowHandle , Defualt.c_str() );

		//補完システムを作成.
		EnumStr = new IMyEnumString(NULL, LoadComplete(AutoCompleteName) );

		// IAutoCompleteインターフェイスを作成
		if (CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER,
				IID_IAutoComplete, (void**)&AutoComplete) != S_OK)
		{
			throw RNotSupportException("CoCreateInstance に失敗しました.");
		}

		// エディットボックスを対象にする.
		if (AutoComplete->Init(EditWindowHandle, EnumStr, NULL, NULL) != S_OK)
		{
			throw RNotSupportException("登録できません.");
		}
//	IAutoComplete2* pAuto2 = NULL;
//	if (SUCCEEDED(pAutoComp->QueryInterface(IID_IAutoComplete2, (LPVOID*)&pAuto2))){
//		pAuto2->SetOptions(ACO_AUTOSUGGEST);
//		pAuto2->Release();
//	}
	}
	catch(RException e)
	{
		printf("オートコンプリート作成でエラーが発生しました:\n%s\n" , e.getMessage() );
		return false;
	}

	return true;
}

//コンプリートデータの読み込み.
BigClass::LoadComplete(string inName)
{
	string dataes;
	try
	{
BigClass::Load("filer.dat" , "AutoComplete" , inName);
	}
	catch(RException e)
	{
		printf("コンプリートデータの取得に失敗\n%s\n",e.getMessage() );
		return WStringList();
	}

	USES_CONVERSION;
	WStringList ret;
	// \t 区切りなので..
	int findstart = 0;
	int hitpos = 0;
	while(1)
	{
		hitpos = dataes.find('\t' , findstart);
		if (hitpos == -1) break;
		string one = dataes.substr(findstart , hitpos - findstart);

		ret.push_back( T2COLE(one.c_str()) );

		findstart = hitpos + 1;
	}

	return ret;
}

//コンプリートデータの書き込み
BigClass::SaveComplete(string inName , WStringList inTargetString)
{
	USES_CONVERSION;

	string writeString;
	for(int i = 0; i < inTargetString.size() ; i++)
	{
		 writeString += string( OLE2CT( inTargetString[i].c_str() ) ) + "\t";
	}
	try
	{
BigClass::Save("filer.dat" , "AutoComplete" , inName,writeString);
	}
	catch(RException e)
	{
		printf("コンプリートデータの書き込みに失敗\n%s\n",e.getMessage() );
	}
}


BigClass::RListView()
{
}

BigClass::~RListView()
{
}

BigClass::Create(HINSTANCE inINstance,
					   HWND isParentWindow,int inID, DWORD inFlg) throw()
{
BigClass::Create(inINstance,WC_LISTVIEW,isParentWindow,inID,inFlg,0);
}

//拡張項目のセット.
BigClass::setExtended(DWORD inStyle)
{
	ListView_SetExtendedListViewStyle(this->getWindowHandle(), inStyle); 
}

//拡張項目のセット.
BigClass::getExtended()
{
	return ListView_GetExtendedListViewStyle(this->getWindowHandle() );
}

//カラムをすべて削除する.
BigClass::ClearColumn()
{
	//すべのカラムの破棄
	while( ListView_DeleteColumn(this->getWindowHandle() ,0) );
}

//カラムアイテムの追加.
BigClass::InsertColumn(int inItem,int inSubItem,char* inString,int inWidth,UINT inMask,int inFmt)
{
	LV_COLUMN lvcol = {0};
	lvcol.mask = inMask;
	lvcol.fmt = inFmt;
	lvcol.cx = inWidth;
	lvcol.pszText = inString;
	lvcol.iSubItem = inSubItem;
	return Btob(ListView_InsertColumn(this->getWindowHandle() , inItem, &lvcol));
}

//アイテムの追加.
BigClass::SetItem(int inItem,int inSubItem,const char* inString)
{
	LVITEM	 lvitem = {0};
	lvitem.mask = LVIF_TEXT ;
	lvitem.pszText = (char*)inString;
	lvitem.iItem = inItem;
	lvitem.iSubItem = inSubItem;
	if (inSubItem == 0)
		return Btob(ListView_InsertItem(this->getWindowHandle() , &lvitem));
	else
		return Btob(ListView_SetItem(this->getWindowHandle() , &lvitem));
}

//アイテムの追加.
BigClass::SetItem(int inItem,int inSubItem,int inInt)
{
	char buf[20];
	return SetItem(inItem,inSubItem, itoa( inInt , buf , 10) );
}

//アイテムの取得
BigClass::GetItem(int inItem,int inSubitem)
{
	char buf[MAX_PATH];

	LVITEM	 lvitem = {0};
	lvitem.mask = LVIF_TEXT ;
	lvitem.pszText = buf;
	lvitem.cchTextMax = MAX_PATH;
	lvitem.iItem = inItem;
	lvitem.iSubItem = inSubitem;
	bool ret = Btob( ListView_GetItem(this->getWindowHandle() , &lvitem) );
	if (!ret) return "";

	return lvitem.pszText;
}



//仮想リストの場合の項目数の設定
BigClass::SetItemCountEx(int inCount,DWORD inFlg)
{
	ListView_SetItemCountEx(this->getWindowHandle() , inCount, inFlg);
}
//仮想リストの場合の項目数の設定
BigClass::SetItemCount(int inCount) 
{
	ListView_SetItemCount(this->getWindowHandle() , inCount);
}

//現在選択されているところの取得.
BigClass::getNowSelected() const
{
	return ListView_GetNextItem(this->getWindowHandle() ,-1,LVNI_SELECTED);
}




//アイテムの数の取得
BigClass::GetItemCount() const
{
	return ListView_GetItemCount(this->getWindowHandle() );
}

//inSearchIntがある位置をサーチ.
BigClass::SearchItem(int inSubItem , int inSearchInt)
{
	char buf[20];
	itoa( inSearchInt , buf , 10);

	int len = GetItemCount();

	for(int i  = 0; i < len ; i++)
	{
		if ( strcmp(GetItem( i ,inSubItem ).c_str() , buf) == 0 )return i;
	}
	return -1;
}

//アイテムの削除
BigClass::DeleteItem(int inItem)
{
	ASSERT(inItem != -1);
	return Btob( ListView_DeleteItem(this->getWindowHandle() , inItem) );
}



//イメージリストセット.
BigClass::setImageList(const HIMAGELIST inImageLIst , int inType)
{	
	return ListView_SetImageList(this->getWindowHandle() ,(HIMAGELIST)inImageLIst , inType) != NULL;
}



//指定したアイテムの状態を変更します。
BigClass::SetItemState(int inItem , int inState,int inMask)
{
	ASSERT(inItem != -1);

	ListView_SetItemState(this->getWindowHandle() ,inItem , inState,inMask);
}

//アイテムとのヒットテスト
BigClass::HitTest(const POINT inPoint) const
{
	LVHITTESTINFO hit = {0};
	hit.pt = inPoint;

	return ListView_HitTest(this->getWindowHandle() , &hit);
}


//指定したアイテムの状態を取得します。
BigClass::GetItemState(int inItem , int inMask) const
{
	ASSERT(inItem != -1);
	return ListView_GetItemState(this->getWindowHandle() ,inItem, inMask);
}

//すべての選択を解除.
BigClass::ResetSelect()
{
	int index = -1;
	while((index = ListView_GetNextItem(this->getWindowHandle(), index, LVNI_ALL | LVNI_SELECTED))!=-1)
	{
		SetItemState(index , 0 , LVIS_SELECTED | LVIS_FOCUSED);
	}
}

//現在マウスカーソルがのっかっているアイテムを取得します。
BigClass::HitItem() const
{
	//どこも選択されていない場合は、キャンセルする.
	POINT pt;
	GetCursorPos(&pt);

	//クライアント座標に持ってきて..
	ScreenToClient(this->getWindowHandle() , &pt);

	//参考 http://www.alpha-net.ne.jp/users2/uk413/vc/VCT_LVitem.html
	return this->HitTest(pt) ;
}
BigClass::RListView()
{
}

BigClass::~RListView()
{
}

BigClass::Create(HINSTANCE inINstance,
					   HWND isParentWindow,int inID, DWORD inFlg) throw()
{
BigClass::Create(inINstance,WC_LISTVIEW,isParentWindow,inID,inFlg,0);
}

//拡張項目のセット.
BigClass::setExtended(DWORD inStyle)
{
	ListView_SetExtendedListViewStyle(this->getWindowHandle(), inStyle); 
}

//拡張項目のセット.
BigClass::getExtended()
{
	return ListView_GetExtendedListViewStyle(this->getWindowHandle() );
}

//カラムをすべて削除する.
BigClass::ClearColumn()
{
	//すべのカラムの破棄
	while( ListView_DeleteColumn(this->getWindowHandle() ,0) );
}

//カラムアイテムの追加.
BigClass::InsertColumn(int inItem,int inSubItem,char* inString,int inWidth,UINT inMask,int inFmt)
{
	LV_COLUMN lvcol = {0};
	lvcol.mask = inMask;
	lvcol.fmt = inFmt;
	lvcol.cx = inWidth;
	lvcol.pszText = inString;
	lvcol.iSubItem = inSubItem;
	return Btob(ListView_InsertColumn(this->getWindowHandle() , inItem, &lvcol));
}

//アイテムの追加.
BigClass::SetItem(int inItem,int inSubItem,const char* inString)
{
	LVITEM	 lvitem = {0};
	lvitem.mask = LVIF_TEXT ;
	lvitem.pszText = (char*)inString;
	lvitem.iItem = inItem;
	lvitem.iSubItem = inSubItem;
	if (inSubItem == 0)
		return Btob(ListView_InsertItem(this->getWindowHandle() , &lvitem));
	else
		return Btob(ListView_SetItem(this->getWindowHandle() , &lvitem));
}

//アイテムの追加.
BigClass::SetItem(int inItem,int inSubItem,int inInt)
{
	char buf[20];
	return SetItem(inItem,inSubItem, itoa( inInt , buf , 10) );
}

//アイテムの取得
BigClass::GetItem(int inItem,int inSubitem)
{
	char buf[MAX_PATH];

	LVITEM	 lvitem = {0};
	lvitem.mask = LVIF_TEXT ;
	lvitem.pszText = buf;
	lvitem.cchTextMax = MAX_PATH;
	lvitem.iItem = inItem;
	lvitem.iSubItem = inSubitem;
	bool ret = Btob( ListView_GetItem(this->getWindowHandle() , &lvitem) );
	if (!ret) return "";

	return lvitem.pszText;
}



//仮想リストの場合の項目数の設定
BigClass::SetItemCountEx(int inCount,DWORD inFlg)
{
	ListView_SetItemCountEx(this->getWindowHandle() , inCount, inFlg);
}
//仮想リストの場合の項目数の設定
BigClass::SetItemCount(int inCount) 
{
	ListView_SetItemCount(this->getWindowHandle() , inCount);
}

//現在選択されているところの取得.
BigClass::getNowSelected() const
{
	return ListView_GetNextItem(this->getWindowHandle() ,-1,LVNI_SELECTED);
}




//アイテムの数の取得
BigClass::GetItemCount() const
{
	return ListView_GetItemCount(this->getWindowHandle() );
}

//inSearchIntがある位置をサーチ.
BigClass::SearchItem(int inSubItem , int inSearchInt)
{
	char buf[20];
	itoa( inSearchInt , buf , 10);

	int len = GetItemCount();

	for(int i  = 0; i < len ; i++)
	{
		if ( strcmp(GetItem( i ,inSubItem ).c_str() , buf) == 0 )return i;
	}
	return -1;
}

//アイテムの削除
BigClass::DeleteItem(int inItem)
{
	ASSERT(inItem != -1);
	return Btob( ListView_DeleteItem(this->getWindowHandle() , inItem) );
}



//イメージリストセット.
BigClass::setImageList(const HIMAGELIST inImageLIst , int inType)
{	
	return ListView_SetImageList(this->getWindowHandle() ,(HIMAGELIST)inImageLIst , inType) != NULL;
}



//指定したアイテムの状態を変更します。
BigClass::SetItemState(int inItem , int inState,int inMask)
{
	ASSERT(inItem != -1);

	ListView_SetItemState(this->getWindowHandle() ,inItem , inState,inMask);
}

//アイテムとのヒットテスト
BigClass::HitTest(const POINT inPoint) const
{
	LVHITTESTINFO hit = {0};
	hit.pt = inPoint;

	return ListView_HitTest(this->getWindowHandle() , &hit);
}


//指定したアイテムの状態を取得します。
BigClass::GetItemState(int inItem , int inMask) const
{
	ASSERT(inItem != -1);
	return ListView_GetItemState(this->getWindowHandle() ,inItem, inMask);
}

//すべての選択を解除.
BigClass::ResetSelect()
{
	int index = -1;
	while((index = ListView_GetNextItem(this->getWindowHandle(), index, LVNI_ALL | LVNI_SELECTED))!=-1)
	{
		SetItemState(index , 0 , LVIS_SELECTED | LVIS_FOCUSED);
	}
}

//現在マウスカーソルがのっかっているアイテムを取得します。
BigClass::HitItem() const
{
	//どこも選択されていない場合は、キャンセルする.
	POINT pt;
	GetCursorPos(&pt);

	//クライアント座標に持ってきて..
	ScreenToClient(this->getWindowHandle() , &pt);

	//参考 http://www.alpha-net.ne.jp/users2/uk413/vc/VCT_LVitem.html
	return this->HitTest(pt) ;
}

BigClass::RMouseGestureMakeZende()
{

}

BigClass::~RMouseGestureMakeZende()
{

}

//Zonde法により解析します。
BigClass::Convert(MOUSE_GESTURE_MOUSE_POINTS inPoints)
{
	RMouseGestureZonde ret;
	const int size = inPoints.size() ;

	//描画されたジェスチャーがぴったりおさまる枠を求めます。
	RECT CanvsRect;
	CanvsRect.left = INT_MAX;
	CanvsRect.top = INT_MAX;
	CanvsRect.right = INT_MIN;
	CanvsRect.bottom = INT_MIN;
	for(int i = 0 ; i < size ; i++)
	{
		POINT p = inPoints[i];
		if ( CanvsRect.left > p.x)	CanvsRect.left = p.x;
		if ( CanvsRect.right < p.x)	CanvsRect.right = p.x;
		if ( CanvsRect.top > p.y)	CanvsRect.top = p.y;
		if ( CanvsRect.bottom < p.y)	CanvsRect.bottom = p.y;
	}

	int canvsWidth = CanvsRect.right - CanvsRect.left;
	int canvsHegith = CanvsRect.bottom - CanvsRect.top;

	//直線との交差により zonde を求めます。
	for(i = 1 ; i < size ; i++)
	{
		LINE target(inPoints[i - 1] , inPoints[i]);
		//1    2      345    6      7    
		//  \  |    /  |   \ |    /      
		//8-------/-----------\-----     
		//     |/      |     |/  \       
		//    /|  \    |    /|     \     
		//  /  |    \  | /   |      \    
		//9------------------------12    
		// 10  |      /|\    |   /       
		//    \|   /   |  \  | /         
		//11-----\-----------/------     
		//   / |   \   |  /  |\          
		///    |     \ /     |  \        

		//1
		if (Intersect( target ,  LINE(CanvsRect.left , CanvsRect.top		, CanvsRect.right , CanvsRect.bottom) )	)
			ret.upHit(1 -1);
		//2
		if (Intersect( target ,  LINE(canvsWidth / 4, CanvsRect.top		, canvsWidth / 4, CanvsRect.bottom) )	)
			ret.upHit(2 -1);
		//3
		if (Intersect( target ,  LINE(canvsWidth / 2, CanvsRect.top		, CanvsRect.left , canvsHegith / 2) )	)
			ret.upHit(3 -1);
		//4
		if (Intersect( target ,  LINE(canvsWidth / 2, CanvsRect.top		, canvsWidth / 2 , CanvsRect.bottom) )	)
			ret.upHit(4 -1);
		//5
		if (Intersect( target ,  LINE(canvsWidth / 2, CanvsRect.top		, CanvsRect.right , canvsHegith / 2) )	)
			ret.upHit(5 -1);
		//6
		if (Intersect( target ,  LINE(canvsWidth / 4 * 3, CanvsRect.top		, canvsWidth / 4 * 3, CanvsRect.bottom) )	)
			ret.upHit(6 -1);
		//7
		if (Intersect( target ,  LINE(CanvsRect.right , CanvsRect.top		, CanvsRect.left , CanvsRect.bottom) )	)
			ret.upHit(7 -1);
		//8
		if (Intersect( target ,  LINE(CanvsRect.left , canvsHegith / 4		, CanvsRect.right , canvsHegith / 4) )	)
			ret.upHit(8 -1);
		//9
		if (Intersect( target ,  LINE(CanvsRect.left , canvsHegith / 2		, CanvsRect.right , canvsHegith / 2) )	)
			ret.upHit(9 -1);
		//10
		if (Intersect( target ,  LINE(CanvsRect.left , canvsHegith / 2		, canvsWidth / 2 , CanvsRect.bottom) )	)
			ret.upHit(10 -1);
		//11
		if (Intersect( target ,  LINE(CanvsRect.left , canvsHegith / 4 *3	, CanvsRect.right , canvsHegith / 4 *3) )	)
			ret.upHit(9 -1);
		//12
		if (Intersect( target ,  LINE(CanvsRect.right , canvsHegith / 2		, canvsWidth / 2 , CanvsRect.bottom) )	)
			ret.upHit(12 -1);
	}
	return ret;
}


//交差を判定.
// 線分 e1, e2 が交差するか判定する。
// 線分 e1, e2 が交差すれば真、さもなくば偽を返す
BigClass::Intersect( LINE e1, LINE e2 )
{
	// 線分 e1, e2 を対角線とする２つの長方形が交わらない場合、線分 e1, e2 が交わることはない。
	if ( min(e1.a.x,e1.b.x) > max(e2.a.x,e2.b.x) ) return 0;
	if ( min(e1.a.y,e1.b.y) > max(e2.a.y,e2.b.y) ) return 0;
	if ( min(e2.a.x,e2.b.x) > max(e1.a.x,e1.b.x) ) return 0;
	if ( min(e2.a.y,e2.b.y) > max(e1.a.y,e1.b.y) ) return 0;

	// 線分 e2 が直線 e1 を跨ぎ、かつ、線分 e1 が直線 e2 を跨ぐならば、線分 e1, e2 は交差する。
	return Straddle( e1, e2.a, e2.b ) && Straddle( e2, e1.a, e1.b );
}//intersect

// 点が直線上に存在する場合には『直線を跨ぐ』と判断する。
// 点 a, b が直線 e を跨いで存在するか判定する。
// 点 a, b が直線 e を跨いでいれば真、さもなくば偽を返す
BigClass::Straddle( LINE e, POINT a, POINT b )
{
	return 0 >= ( Side(a,e) * Side(b,e) );
}//straddle

// 点 p が有向線分 e(a,b) のどちら側にあるか調べる。
// 点 p が有向線分 e の　右側にある場合  1 を、
// 　   　有向線分 e の直線上にある場合  0 を、
// 　   　有向線分 e の　左側にある場合 -1 を返す
BigClass::Side( POINT p, LINE e )
{
	int     n;
	POINT	p1, p2, p3;

	// 有向線分 (p2,p1), (p2,p3) の外積を求める
	p1 = p; p2 = e.a; p3 = e.b;
	n  = p1.x*(p2.y-p3.y)+p2.x*(p3.y-p1.y)+p3.x*(p1.y-p2.y);

	if      ( n > 0 ) return  1; // 右
	else if ( n < 0 ) return -1; // 左
	else              return  0; // 線上
}//side


BigClass::RMouseGestureMousePoints()
{
	CompensationDistrance = 10;
}

BigClass::~RMouseGestureMousePoints()
{

}

//軌跡を追加
//追加された場合は true
//ポリシー違反で追加されない場合は false .
BigClass::Insert(int x,int y)
{
	int size = Points.size();
	if (size >= 1)
	{
		//前回の値
		POINT last = Points[size - 1];

		//前回の値から Distrance ピクセル離れていること
		if ( abs(last.x - x) <= this->CompensationDistrance && abs(last.y - y) <= this->CompensationDistrance )	return false;

		if (size >= 2)
		{
			//前々会 (2つ前)と　前回(1つ前)の傾きが同じ方向だったら、
			//前回の消去し、今回の値を入力する.
			POINT moreLast = Points[size - 2];
			if (	Normalize(moreLast.x - last.x) == Normalize(last.x - x) &&
					Normalize(moreLast.y - last.y) == Normalize(last.y - y)	)
			{
				//前回のを上書き
				POINT p;	p.x = x;	p.y = y;
				Points[size - 1] = p;
				return false;
			}
		}
	}
	//んぢゃ、追加してみっか。
	POINT p;	p.x = x;	p.y = y;
	Points.push_back( p );

	return true;

}


BigClass::RProgressBar()
{
	BockSize = 5;
	OrignalExtends = 0;
}

BigClass::~RProgressBar()
{

}

//作成.
//失敗	RNotSupportException 
//		RDoNotInitaliseException
BigClass::Create(HINSTANCE inINstance,
	HWND isParentWindow,int inID , DWORD inFlg) throw()
{
BigClass::Create(inINstance,"msctls_progress32",isParentWindow,inID, inFlg | WS_CHILD | WS_VISIBLE ,0);

	//よーしパパ、サブクラスにしちゃうぞー
	this->OrignalWindowProc = (WNDPROC) GetWindowLong( this->getWindowHandle() , GWL_WNDPROC );
	SetWindowLong( this->getWindowHandle() , GWL_USERDATA, (LONG)this );
	SetWindowLong( this->getWindowHandle() , GWL_WNDPROC, (LONG)WndProcStatic);

	setRange(0,100);
}





//ウィンドウプロシージャ(none static)
BigClass::WndProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
	switch(msg)
	{
	case WM_PAINT:
		{
			PAINTSTRUCT ps;
BigClass::BeginPaint( hwnd , &ps);
			OnPaint(ps.hdc);
BigClass::EndPaint(hwnd , &ps);
			return 0;
		}
	case WM_LBUTTONDOWN:
	case WM_MOUSEMOVE:
		{
			if (!(OrignalExtends & ORIGNAL_EXTENDS_STYLE_MOUSE_CHANGE))
			{
				break;
			}
			if (msg == WM_MOUSEMOVE && wparam != MK_LBUTTON)
			{
				break;
			}
			RECT rc;
			this->GetWindowRect(&rc);
			if (getStyle() & PBS_VERTICAL)
			{
				const int     yPos    = HIWORD(lparam);
				setPos( (End - Start) - ((End - Start) * yPos / (rc.bottom - rc.top))  );
			}
			else
			{
				const int     xPos    = LOWORD(lparam);
				setPos( (End - Start) * xPos / (rc.right - rc.left)  );
			}
BigClass::GetWindowLong(this->getWindowHandle() , GWL_ID);

BigClass::GetParent( this->getWindowHandle() ) , WM_COMMAND , 
BigClass::GetWindowLong(this->getWindowHandle() , GWL_ID) , PB_ORIGNAL_EXTENDS_MOUSE_DOWN) ,
				(LPARAM)this->getWindowHandle() );
		}
	}
BigClass::CallWindowProc( OrignalWindowProc ,hwnd,msg,wparam,lparam);
}

BigClass::OnPaint(HDC hdc)
{
	RECT ClientRC;
	this->GetClientRect( &ClientRC );

	//スタートから終わりまでの差を求める.
	int r = (GetRValue(EndColor) - GetRValue(StartColor));
	int g = (GetGValue(EndColor) - GetGValue(StartColor));
	int b = (GetBValue(EndColor) - GetBValue(StartColor));

	int colorStep;
	if (getStyle() & PBS_VERTICAL)		colorStep	=	ClientRC.bottom;
	else								colorStep	=	ClientRC.right;

	//ステップ
	float rStep = (float)r/colorStep;
	float gStep = (float)g/colorStep;
	float bStep = (float)b/colorStep;

	COLORREF colorFill;
	RECT	rc = ClientRC;
	if (getStyle() & PBS_VERTICAL)
	{
		//カラーがひとつ変わるとき、リアルでいくつ進むか.
		int barSize = getBarSize(ClientRC.bottom);
		for(int i=1 ; i < barSize ; i+= BockSize)
		{
			colorFill = RGB(r + (int)(i * rStep),
							g + (int)(i * gStep),
							b + (int)(i * bStep));

			rc.top = ClientRC.bottom - (i-BockSize);
			rc.bottom = ClientRC.bottom - i;
			FillRectWithSolidBrush(hdc , &rc , colorFill);
		}
		//最後の位置ブロックを塗りつぶす.
		rc.top = ClientRC.bottom - (barSize-BockSize);
		rc.bottom = ClientRC.bottom - barSize;
		FillRectWithSolidBrush(hdc , &rc , colorFill);
	}
	else
	{
		//カラーがひとつ変わるとき、リアルでいくつ進むか.
		int barSize = getBarSize(ClientRC.right);
		for(int i=0 ; i < barSize ; i+= BockSize)
		{
			colorFill = RGB(r + (int)(i * rStep),
							g + (int)(i * gStep),
							b + (int)(i * bStep));

			rc.left = ClientRC.left + (i-BockSize);
			rc.right = ClientRC.left + i;
			FillRectWithSolidBrush(hdc , &rc , colorFill);
		}
		//最後の位置ブロックを塗りつぶす.
		rc.left = ClientRC.left + (barSize-BockSize);
		rc.right = ClientRC.left + barSize;
		FillRectWithSolidBrush(hdc , &rc , colorFill);
	}

	return ;
}

BigClass::getBarSize(int inFullSize)
{
	const int range = End - Start;
	int pos= getPos();
	return (inFullSize * pos / range);
}


//そのパスを解決してみる
BigClass::DoSolvable(string inPath) 
{
	//先頭が file:/// だった場合、その部分をカット.
	if ( inPath.substr(0,8) == "file:///" )
	{
		inPath = inPath.substr(8);
		// / を \\ にする.
		replace( inPath.begin() , inPath.end() , '/','\\');
		//UrlEncode を取り除く.
BigClass::UrlEncode(inPath);
	}

	//先頭が \\ でなければダメ
	if (inPath.substr(0,2) != "\\\\")
	{
		//ただし smb:// の場合は、ドメインログインとして扱う. 独自仕様(w
		if (inPath.substr(0,6) != "smb://")
		{
			return false;	//ぼつ.
		}
		else
		{
			//最後が \\ でない場合は最後に \\ を補完します。
BigClass::IsPathToComplement(inPath) )
			{
				inPath += "\\";
			}
			//パスの深さが 3以下であることが必須   substr は 先頭の smb:// を除くため.
			//smb://\\Microsoft Windows Network\\DOMAIN\\ .

			int dilimiter[MAX_DIMLIMITERES] ;
BigClass::setPathDelimiteres(inPath.c_str() , '\\' , dilimiter ,MAX_DIMLIMITERES);
			if ( maxDilimiter >= 4)
			{
				// \\マシン名 として評価してみます.
				return DoSolvable( string("\\") + inPath.substr(dilimiter[2]) );
			}
		}
	}
	else
	{
		//最後が \\ でない場合は最後に \\ を補完します。
BigClass::IsPathToComplement(inPath) )
		{
			inPath += "\\";
		}

		//パスの深さが 1以下であることが必須   substr は 先頭の \\ を除くため.
BigClass::setPathDepth(inPath.substr(2) ) >= 2)
		{
			return false;	//ぼつ
		}
	}
	this->setPath(inPath);

	//OK
	return true;
}

//一つディレクトリを上がる
BigClass::UpDirectory() const
{
	const string path = getPath() ;

	//先頭が \\ だったら...
	if (path.substr(0,2) == "\\\\")
	{	//共有の情報を取得します。

		//最後の \\ を削る.
		string remoteName = path.substr( 0 , path.size() - 1);

		NETRESOURCE srcNr;
		srcNr.lpProvider = "Microsoft Windows Network";
		srcNr.dwType = RESOURCETYPE_DISK;
		srcNr.lpRemoteName = (char*) remoteName.c_str();

		DWORD bufSize = MAX_PATH * 10;	//適当
		NETRESOURCE *destNr = (NETRESOURCE*)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, bufSize);

		if ( WNetGetResourceParent( &srcNr , destNr , &bufSize) != NO_ERROR)
		{
			GlobalFree(destNr);
			//取得に失敗.. どうする? マイネットワークにでも戻すか?
BigClass::getSpecialFolder(CSIDL_NETWORK);
		}

		string ret = string("smb://\\") + destNr->lpProvider + string("\\") + destNr->lpRemoteName + string("\\");

		GlobalFree(destNr);

		return ret;
	}

	//ただし smb:// の場合は、ドメインログインとして扱う. 独自仕様(w
	//んで、smb:// 以上にあがる場合は マイネットワークに飛ばす.
BigClass::setPathDepth(path) == 1)
	{
BigClass::getSpecialFolder(CSIDL_NETWORK);
	}

BigClass::getLastDirectoryPos( path );
	return path.substr( 0 , lastpos + 1) ;
}

BigClass::Test()
{
	SolvablePathSMBLogon sp;

	//パスが解決できるか?
//	ASSERT( sp.DoSolvable("c:\\") );
//	ASSERT( sp.getPath() == "c:\\" );

}



BigClass::SusiePlugin()
{
}
BigClass::~SusiePlugin()
{
}

//初期化かされていない場合は RDoNotInitaliseException です。
//そんな関数ない場合は RNotSupportException です。
BigClass::Create(const string inDllName) throw()
{
	Lib.Create(inDllName.c_str() );
	ExportGetPluginInfo = (GETPLUGININFO) Lib.GetProcAddress("GetPluginInfo");
	ExportIsSupported = (ISUPPORTED) Lib.GetProcAddress("IsSupported");
	ExportGetPictureInfo = (GETPICTUREINFO) Lib.GetProcAddress("GetPictureInfo");
	ExportGetPicture = (GETPICTURE) Lib.GetProcAddress("GetPicture");
}


//プラグインバージョンの取得
//エラー RSusieConferException
BigClass::GetPluginVersion() const throw()
{
	char buf[MAX_PATH+4];	//多めに確保
	int ret;
	try
	{
		ret = ExportGetPluginInfo(0 , buf , MAX_PATH);
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	buf[ret] = '\0';

	return buf;
}
//プラグインコピーライトの取得
BigClass::GetPluginCopyRight() const throw()
{
	char buf[MAX_PATH+4];	//多めに確保
	int ret;
	try
	{
		ret = ExportGetPluginInfo(1 , buf , MAX_PATH);
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	buf[ret] = '\0';

	return buf;
}
//プラグインが対応している拡張子 代表的な拡張子 ("*.JPG" "*.RGB;*.Q0" など)
//@inNo	0〜
//ret 形式
//失敗 ""
BigClass::GetPluginSupportExt(int inNo) const throw()
{
	char buf[MAX_PATH+4];	//多めに確保
	int ret;
	try
	{
		ret = ExportGetPluginInfo(2 + inNo*2 , buf , MAX_PATH);
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	buf[ret] = '\0';

	return buf;
}

//プラグインが対応しているファイル形式名
//@inNo	0〜
//ret ファイルタイプ
//失敗 ""
BigClass::GetPluginSupportFiletypeName(int inNo) const throw()
{
	char buf[MAX_PATH+4];	//多めに確保
	int ret;
	try
	{
		ret = ExportGetPluginInfo(3 + inNo*2 , buf , MAX_PATH);
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	buf[ret] = '\0';

	return buf;
}




//サポートされているかどうか調べる
BigClass::IsSupported(char* ioFilename,char* io2KMemory) const
{
	int ret;
	try
	{
		ret = ExportIsSupported(ioFilename , (DWORD)io2KMemory);
	}
	catch(...){	return false;	}	//例外ではないので注意

	return (ret != 0);
}


//画像の情報の取得
//エラー RSusieConferException
BigClass::GetPictureInfo(char* ioFilename,	PictureInfo *outinfo) const throw()
{

	TRACE("%s\n" , GetPluginCopyRight().c_str() );
	int ret;

	try
	{
		ret = ExportGetPictureInfo(ioFilename,0 ,0	 , outinfo );
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	if ( ret == 2 ) ret = 0;	//SUSIEのボケのバグ対策.
	SusieResult( ret ,"GetPictureInfo");
}


//展開
//エラー RSusieConferException
BigClass::GetPicture(char* ioFilename,
			HLOCAL *outBinfo, HLOCAL *outBm,
			SusieCallable* inCallable) const throw()
{
	int ret;

	//ロード
	try
	{
		ret = ExportGetPicture(ioFilename,0,0 , 
BigClass::ProgressCallback , (DWORD)inCallable);
	}
	catch(...)
	{
		throw RSusieConferException(0,"プラグインが例外を飛ばしました");	
	}
	if ( ret == 2 ) ret = 0;	//SUSIEのボケのバグ対策.

	SusieResult( ret , "GetPicture");
}


//Susieの戻り値の処理
//エラー RSusieConferException
BigClass::SusieResult(int inRetCode,const char* inFuncName) const throw()
{
	//正常終了
	if (inRetCode == 0) return ;

	switch(inRetCode)
	{
	case -1:
		throw RSusieConferException(inRetCode,"%s: その機能はインプリメントされていない", inFuncName);
		break;
	case 1:
		throw RSusieConferException(inRetCode,"%s: コールバック関数が非0を返したので展開を中止した", inFuncName);
		break;
	case 2:
		throw RSusieConferException(inRetCode,"%s: 未知のフォーマット", inFuncName);
		break;
	case 3:
		throw RSusieConferException(inRetCode,"%s: データが壊れている", inFuncName);
		break;
	case 4:
		throw RSusieConferException(inRetCode,"%s: メモリーが確保出来ない", inFuncName);
		break;
	case 5:
		throw RSusieConferException(inRetCode,"%s: メモリーエラー（Lock出来ない、等）", inFuncName);
		break;
	case 6:
		throw RSusieConferException(inRetCode,"%s: ファイルリードエラー", inFuncName);
		break;
	case 8:
		throw RSusieConferException(inRetCode,"%s: 内部エラー", inFuncName);
		break;
	default:
		throw RSusieConferException(inRetCode,"%s: 定義外エラー", inFuncName);
		break;
	}
}


BigClass::SusiePlugin()
{
}
BigClass::~SusiePlugin()
{
}

//初期化かされていない場合は RDoNotInitaliseException です。
//そんな関数ない場合は RNotSupportException です。
BigClass::Create(const string inDllName) throw()
{
	Lib.Create(inDllName.c_str() );
	ExportGetPluginInfo = (GETPLUGININFO) Lib.GetProcAddress("GetPluginInfo");
	ExportIsSupported = (ISUPPORTED) Lib.GetProcAddress("IsSupported");
	ExportGetPictureInfo = (GETPICTUREINFO) Lib.GetProcAddress("GetPictureInfo");
	ExportGetPicture = (GETPICTURE) Lib.GetProcAddress("GetPicture");
}


//プラグインバージョンの取得
//エラー RSusieConferException
BigClass::GetPluginVersion() const throw()
{
	char buf[MAX_PATH+4];	//多めに確保
	int ret;
	try
	{
		ret = ExportGetPluginInfo(0 , buf , MAX_PATH);
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	buf[ret] = '\0';

	return buf;
}
//プラグインコピーライトの取得
BigClass::GetPluginCopyRight() const throw()
{
	char buf[MAX_PATH+4];	//多めに確保
	int ret;
	try
	{
		ret = ExportGetPluginInfo(1 , buf , MAX_PATH);
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	buf[ret] = '\0';

	return buf;
}
//プラグインが対応している拡張子 代表的な拡張子 ("*.JPG" "*.RGB;*.Q0" など)
//@inNo	0〜
//ret 形式
//失敗 ""
BigClass::GetPluginSupportExt(int inNo) const throw()
{
	char buf[MAX_PATH+4];	//多めに確保
	int ret;
	try
	{
		ret = ExportGetPluginInfo(2 + inNo*2 , buf , MAX_PATH);
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	buf[ret] = '\0';

	return buf;
}

//プラグインが対応しているファイル形式名
//@inNo	0〜
//ret ファイルタイプ
//失敗 ""
BigClass::GetPluginSupportFiletypeName(int inNo) const throw()
{
	char buf[MAX_PATH+4];	//多めに確保
	int ret;
	try
	{
		ret = ExportGetPluginInfo(3 + inNo*2 , buf , MAX_PATH);
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	buf[ret] = '\0';

	return buf;
}




//サポートされているかどうか調べる
BigClass::IsSupported(char* ioFilename,char* io2KMemory) const
{
	int ret;
	try
	{
		ret = ExportIsSupported(ioFilename , (DWORD)io2KMemory);
	}
	catch(...){	return false;	}	//例外ではないので注意

	return (ret != 0);
}


//画像の情報の取得
//エラー RSusieConferException
BigClass::GetPictureInfo(char* ioFilename,	PictureInfo *outinfo) const throw()
{

	TRACE("%s\n" , GetPluginCopyRight().c_str() );
	int ret;

	try
	{
		ret = ExportGetPictureInfo(ioFilename,0 ,0	 , outinfo );
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	if ( ret == 2 ) ret = 0;	//SUSIEのボケのバグ対策.
	SusieResult( ret ,"GetPictureInfo");
}


//展開
//エラー RSusieConferException
BigClass::GetPicture(char* ioFilename,
			HLOCAL *outBinfo, HLOCAL *outBm,
			SusieCallable* inCallable) const throw()
{
	int ret;

	//ロード
	try
	{
		ret = ExportGetPicture(ioFilename,0,0 , 
BigClass::ProgressCallback , (DWORD)inCallable);
	}
	catch(...)
	{
		throw RSusieConferException(0,"プラグインが例外を飛ばしました");	
	}
	if ( ret == 2 ) ret = 0;	//SUSIEのボケのバグ対策.

	SusieResult( ret , "GetPicture");
}


//Susieの戻り値の処理
//エラー RSusieConferException
BigClass::SusieResult(int inRetCode,const char* inFuncName) const throw()
{
	//正常終了
	if (inRetCode == 0) return ;

	switch(inRetCode)
	{
	case -1:
		throw RSusieConferException(inRetCode,"%s: その機能はインプリメントされていない", inFuncName);
		break;
	case 1:
		throw RSusieConferException(inRetCode,"%s: コールバック関数が非0を返したので展開を中止した", inFuncName);
		break;
	case 2:
		throw RSusieConferException(inRetCode,"%s: 未知のフォーマット", inFuncName);
		break;
	case 3:
		throw RSusieConferException(inRetCode,"%s: データが壊れている", inFuncName);
		break;
	case 4:
		throw RSusieConferException(inRetCode,"%s: メモリーが確保出来ない", inFuncName);
		break;
	case 5:
		throw RSusieConferException(inRetCode,"%s: メモリーエラー（Lock出来ない、等）", inFuncName);
		break;
	case 6:
		throw RSusieConferException(inRetCode,"%s: ファイルリードエラー", inFuncName);
		break;
	case 8:
		throw RSusieConferException(inRetCode,"%s: 内部エラー", inFuncName);
		break;
	default:
		throw RSusieConferException(inRetCode,"%s: 定義外エラー", inFuncName);
		break;
	}
}


BigClass::SusiePlugin()
{
}
BigClass::~SusiePlugin()
{
}

//初期化かされていない場合は RDoNotInitaliseException です。
//そんな関数ない場合は RNotSupportException です。
BigClass::Create(const string inDllName) throw()
{
	Lib.Create(inDllName.c_str() );
	ExportGetPluginInfo = (GETPLUGININFO) Lib.GetProcAddress("GetPluginInfo");
	ExportIsSupported = (ISUPPORTED) Lib.GetProcAddress("IsSupported");
	ExportGetPictureInfo = (GETPICTUREINFO) Lib.GetProcAddress("GetPictureInfo");
	ExportGetPicture = (GETPICTURE) Lib.GetProcAddress("GetPicture");
}


//プラグインバージョンの取得
//エラー RSusieConferException
BigClass::GetPluginVersion() const throw()
{
	char buf[MAX_PATH+4];	//多めに確保
	int ret;
	try
	{
		ret = ExportGetPluginInfo(0 , buf , MAX_PATH);
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	buf[ret] = '\0';

	return buf;
}
//プラグインコピーライトの取得
BigClass::GetPluginCopyRight() const throw()
{
	char buf[MAX_PATH+4];	//多めに確保
	int ret;
	try
	{
		ret = ExportGetPluginInfo(1 , buf , MAX_PATH);
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	buf[ret] = '\0';

	return buf;
}
//プラグインが対応している拡張子 代表的な拡張子 ("*.JPG" "*.RGB;*.Q0" など)
//@inNo	0〜
//ret 形式
//失敗 ""
BigClass::GetPluginSupportExt(int inNo) const throw()
{
	char buf[MAX_PATH+4];	//多めに確保
	int ret;
	try
	{
		ret = ExportGetPluginInfo(2 + inNo*2 , buf , MAX_PATH);
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	buf[ret] = '\0';

	return buf;
}

//プラグインが対応しているファイル形式名
//@inNo	0〜
//ret ファイルタイプ
//失敗 ""
BigClass::GetPluginSupportFiletypeName(int inNo) const throw()
{
	char buf[MAX_PATH+4];	//多めに確保
	int ret;
	try
	{
		ret = ExportGetPluginInfo(3 + inNo*2 , buf , MAX_PATH);
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	buf[ret] = '\0';

	return buf;
}




//サポートされているかどうか調べる
BigClass::IsSupported(char* ioFilename,char* io2KMemory) const
{
	int ret;
	try
	{
		ret = ExportIsSupported(ioFilename , (DWORD)io2KMemory);
	}
	catch(...){	return false;	}	//例外ではないので注意

	return (ret != 0);
}


//画像の情報の取得
//エラー RSusieConferException
BigClass::GetPictureInfo(char* ioFilename,	PictureInfo *outinfo) const throw()
{

	TRACE("%s\n" , GetPluginCopyRight().c_str() );
	int ret;

	try
	{
		ret = ExportGetPictureInfo(ioFilename,0 ,0	 , outinfo );
	}
	catch(...){	throw RSusieConferException(0,"プラグインが例外を飛ばしました");	}
	if ( ret == 2 ) ret = 0;	//SUSIEのボケのバグ対策.
	SusieResult( ret ,"GetPictureInfo");
}


//展開
//エラー RSusieConferException
BigClass::GetPicture(char* ioFilename,
			HLOCAL *outBinfo, HLOCAL *outBm,
			SusieCallable* inCallable) const throw()
{
	int ret;

	//ロード
	try
	{
		ret = ExportGetPicture(ioFilename,0,0 , 
BigClass::ProgressCallback , (DWORD)inCallable);
	}
	catch(...)
	{
		throw RSusieConferException(0,"プラグインが例外を飛ばしました");	
	}
	if ( ret == 2 ) ret = 0;	//SUSIEのボケのバグ対策.

	SusieResult( ret , "GetPicture");
}


//Susieの戻り値の処理
//エラー RSusieConferException
BigClass::SusieResult(int inRetCode,const char* inFuncName) const throw()
{
	//正常終了
	if (inRetCode == 0) return ;

	switch(inRetCode)
	{
	case -1:
		throw RSusieConferException(inRetCode,"%s: その機能はインプリメントされていない", inFuncName);
		break;
	case 1:
		throw RSusieConferException(inRetCode,"%s: コールバック関数が非0を返したので展開を中止した", inFuncName);
		break;
	case 2:
		throw RSusieConferException(inRetCode,"%s: 未知のフォーマット", inFuncName);
		break;
	case 3:
		throw RSusieConferException(inRetCode,"%s: データが壊れている", inFuncName);
		break;
	case 4:
		throw RSusieConferException(inRetCode,"%s: メモリーが確保出来ない", inFuncName);
		break;
	case 5:
		throw RSusieConferException(inRetCode,"%s: メモリーエラー（Lock出来ない、等）", inFuncName);
		break;
	case 6:
		throw RSusieConferException(inRetCode,"%s: ファイルリードエラー", inFuncName);
		break;
	case 8:
		throw RSusieConferException(inRetCode,"%s: 内部エラー", inFuncName);
		break;
	default:
		throw RSusieConferException(inRetCode,"%s: 定義外エラー", inFuncName);
		break;
	}
}


BigClass::WindowsMain()
{
}

BigClass::~WindowsMain()
{

}

BigClass::getMainSystem()
{
	static WindowsMain	main;
	return &main;
}

//適当にIDを振り出す(w
BigClass::getID()
{
	static id = 1000;
	return id++;
}

//実行.
//戻り値		プログラムのリターン値.
//例外			初期化失敗の場合は RDoNotInitaliseException が投げられる.
BigClass::Run()
{
    STARTUPINFO StatUpInfo;
    HINSTANCE hPrevInstance;
    int nCmdShow;

	//スタートアップ処理.
    GetStartupInfo(&StatUpInfo);
    this->Instance = GetModuleHandle(0);
    hPrevInstance = 0;
    nCmdShow = (StatUpInfo.dwFlags & STARTF_USESHOWWINDOW)?
                StatUpInfo.wShowWindow:SW_SHOWNORMAL;

    WNDCLASS	wc;
    MSG			msg = {0};
	//メインウィンドクラスの作成.
	wc.lpszClassName = "SuperFiler";
    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = (WNDPROC)WndProcStatic;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = this->Instance;
    wc.hIcon         = LoadIcon(this->Instance, MAKEINTRESOURCE(IDI_APPLICATION));
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW);
    wc.lpszMenuName  = NULL;

    if(!RegisterClass(&wc))
	{
        throw RDoNotInitaliseException("ウィンドウクラスの作成に失敗しました");
    }
	//メインウィンドウの作成.
    this->WindowHandle = CreateWindow(wc.lpszClassName,
				            wc.lpszClassName,WS_OVERLAPPEDWINDOW,
						    CW_USEDEFAULT, CW_USEDEFAULT,
							CW_USEDEFAULT, CW_USEDEFAULT,
							NULL, NULL,this->Instance, NULL);
	if (this->WindowHandle == NULL)
	{
        throw RDoNotInitaliseException("メインウィンドウの作成に失敗しました");
	}

	//パネルを2つ張ります。
	//---------------------------------------
	//|  BasePanelLeft  |  BasePanelRight   |
	//|                 |                   |
	//|                 |                   |
	//|                 |                   |
	//|                 |                   |
	//|-------------------------------------|

	//左側のパネルの作成
	Panel[0].Create(true);
	//右側のパネルの作成
	Panel[1].Create(true);

	//スプリッターの作成.
	Spliter.setParentWnidow( this->getWindowHandle() );
	Spliter.setRubberBandSize(5);
	Spliter.setLeftWindowSize(0.50);


	//CommonControlの初期化
	InitCommonControls();
	//Oleの初期化
BigClass::CoInitialize(NULL);
	//ATLの初期化
	_Module.Init(0, Instance );

	//サイズ調整.
	OnSize();
	//作成.
BigClass::getFiler();
	filer->OnCreate();
	//ウィンドウ表示開始.
    ShowWindow(this->WindowHandle, nCmdShow);
    UpdateWindow(this->WindowHandle);

	//C++のクセ static の初期化.
BigClass::getInstance();


	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg); 
	} 
	//ATLの終了
	_Module.Term();
	//COMの終了処理
	CoUninitialize();
	//プログラム終了.
	return msg.wParam;	
}


//サイズ変更
BigClass::OnSize()
{
	RECT theRC;

	//Left
	Spliter.getWindowRect(true,&theRC);
	Panel[0].MoveWindow(theRC.left , theRC.top , theRC.right-theRC.left , theRC.bottom-theRC.top);

	//Right
	Spliter.getWindowRect(false,&theRC);
	Panel[1].MoveWindow(theRC.left , theRC.top , theRC.right-theRC.left , theRC.bottom-theRC.top);
}

//ウィンドウプロシージャ(none static)
BigClass::WndProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch(msg)
	{
	case WM_CREATE:
		//分割ウィンドウ設定
		break;
	case WM_LBUTTONDOWN:
		if ( Spliter.OnLButtonDown(LOWORD(lparam) , HIWORD(lparam)) ) return 0;
		break;
	case WM_LBUTTONUP:
		if ( Spliter.OnLButtonUp(LOWORD(lparam) , HIWORD(lparam)) ) return 0;
		break;
	case WM_MOUSEMOVE:
		if ( Spliter.OnMouseMove(LOWORD(lparam) , HIWORD(lparam)) ) return 0;
		break;
	case WM_SIZE:
		OnSize();
BigClass::getFiler()->OnWindowResize();
		break;
	case WM_KEYDOWN:
BigClass::getFiler()->OnKeyDown( (unsigned char)wparam );
		break;
	case WM_CLOSE:
BigClass::getFiler()->OnDestory();
		DestroyWindow(hwnd);
		return 0;
	case WM_TASKEND:	//タスクが終了しました。
BigClass::getInstance()->CallEndOfTask((RTask*)wparam,(Window*)lparam);
		return 0;
	case RTI_WM_INTERRUPT:	//メインスレッドに割り込む
		((RThreadExecuteOnMainThread*)(wparam))->_Start();
		break;
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, msg, wparam, lparam);
}


const DWORD CELL_FLG_SIZE = sizeof(DWORD) * 2;
const int CELL_ALIVE_FLG	=	0x00000000;
const int CELL_DELETE_FLG	=	0x00000001;

#define IS_FLG_SET(flg,d)	(flg & d)
#define FLG_SET(flg,d)		(flg | d)
#define FLG_RESET(flg,d)	(flg & (~d))

/*
データ構造:
	+0	+1	+2	+3	+4	+5	+6	+7	+8	+9	+10	+11
	(DWORD)			(DWORD)
	0	0	0	0	0	0	0	4	a	b	c	d
	|----flg----|	|--length---|	|---data----|

お約束:
	1.flg が CELL_DELETE_FLG の時、そのデータは削除されたものとして扱う。
	2.length の数だけデータは続く。

FAQ:
  Q:flg が 4バイトなのは無駄なのでは?
  A:そうですね。 まぁ、手抜きです。

*/	

//////////////////////////////////////////////////////////////////////
// 構築/消滅
//////////////////////////////////////////////////////////////////////

BigClass::RFileDB()
{
	File = NULL;
	IndexFile = NULL;
	Index = NULL;
}

BigClass::~RFileDB()
{
	Close();
}

/**
 * Close:			データベースのクローズ
 *
 * @return void 
 */
BigClass::Close()
{
	if (File)
	{
		fclose(File);
		File = NULL;
	}
	if (IndexFile)
	{
		fclose(IndexFile);
		IndexFile = NULL;
	}
	delete [] Index;
	Index = NULL;
}

/**
 * Create:					新規作成
 *
 * @param inFilename		ファイル名	あれば上書き
 * @param inHashTableSize	ハッシュテーブルの大きさ 素数推奨
 * @return void 
 */
BigClass::Create(const string& inFilename , int inHashTableSize) throw(RIOCannotOpenException)
{
	Open(inFilename , inHashTableSize , "w+b");
}

/**
 * Load:					読み込み
 *
 * @param inFilename		ファイル名
 * @param inHashTableSize	ハッシュテーブルの大きさ 素数推奨
 * @return void 
 */
BigClass::Load(const string& inFilename , int inHashTableSize) throw(RIOCannotOpenException)
{
	Open(inFilename , inHashTableSize , "r+b");

	//INDEXの読み取り.
	DWORD buffer[3];
	while( !feof(IndexFile) )
	{
		fread( buffer , sizeof(DWORD) , 3 , IndexFile);
		InsertIndex(buffer[0] , buffer[1], buffer[2]  );
	}
}

/**
 * InsertIndex:		index に挿入
 *
 * @param inKey		検索キー
 * @param inPos		挿入場所
 * @param inSize	データのサイズ
 * @return void 
 */
BigClass::InsertIndex(DWORD inKey , DWORD inPos , DWORD inSize)
{
	const DWORD key = inKey % HashSize;
	(Index[key])[inKey] = OneParts(inPos, inSize);
}

/**
 * FindIndex:		index より検索
 *
 * @param inKey		検索キー
 * @param outPos	データの場所
 * @param outSize	データのサイズ
 * @return bool		見つかった場合　true 
 */
BigClass::FindIndex(DWORD inKey , DWORD * outPos , DWORD * outSize) const
{
	const DWORD key = inKey % HashSize;
	SecondIndexDef * sd = & Index[key];
BigClass::const_iterator i = sd->find(inKey);
	if ( i == sd->end() ) return false;

	*outPos = ((*i).second).first;
	*outSize = ((*i).second).second;
	return true;
}

/**
 * UpdateIndex:		index の更新
 *
 * @param inKey		検索キー
 * @param inPos		データの場所
 * @param inSize	データサイズ
 * @return void 
 */
BigClass::UpdateIndex(DWORD inKey , DWORD inPos, DWORD inSize)
{
	InsertIndex(inKey , inPos , inSize);
}

/**
 * DeleteIndex:		index の削除
 *
 * @param inKey		検索キー
 * @return void 
 */
BigClass::DeleteIndex(DWORD inKey )
{
	const DWORD key = inKey % HashSize;
	SecondIndexDef * sd = & Index[key];
	sd->erase(inKey);
}

/**
 * Open:					データベースのオープン
 *
 * @param inFilename		データベース名
 * @param inHashTableSize	ハッシュテーブルの大きさ 素数推奨
 * @param mode				fopenのモード
 * @return void 
 */
BigClass::Open(const string& inFilename , int inHashTableSize , const char* mode) throw(RIOCannotOpenException)
{
	Close();

	File = fopen(inFilename.c_str() , mode);
	if (File == NULL)
	{
		throw RIOCannotOpenException(EXCEPTIONTRACE + " データベース" + inFilename + "が開けません");
	}
	const string index = inFilename + ".idx";
	IndexFile = fopen(index.c_str() , mode);
	if (IndexFile == NULL)
	{
		throw RIOCannotOpenException(EXCEPTIONTRACE + " データベース" + inFilename + "のインデックス" + index + "が開けません");
	}

	Index = new SecondIndexDef[inHashTableSize];

	HashSize = inHashTableSize;
}
/**
 * Save:					ディスクに index を書き込みます。 indexは OnMemory なのでセーブしないと無意味です
 *
 * @return void 
 */
BigClass::Save() 
{
	DWORD writeBuffer[3];

	fseek( IndexFile , 0 , SEEK_SET ) ;
	for(int i = 0 ; i < HashSize ; i++)
	{
		SecondIndexDef* sid = &Index[i];

BigClass::iterator end = sid->end() ;
BigClass::const_iterator i = sid->begin() ; i != end ; ++i)
		{
			//検索キー
			writeBuffer[0] = ((*i).first);
			//データの場所
			writeBuffer[1] = ((*i).second).first;
			//データの長さ
			writeBuffer[2] = ((*i).second).second;

			fwrite(writeBuffer , sizeof(DWORD) , 3 , IndexFile);
		}
	}
}

/**
 * Flush:					データを flush します。
 *
 * @return void 
 */
BigClass::Flush()
{
	fflush(File);
	fflush(IndexFile);
}

/**
 * Select:					検索
 *
 * @param inKey				検索キー
 * @param outData			データを書き込むバッファ
 * @return void 
 */
BigClass::Select(DWORD inKey , RBuffer * outData) const throw(RNotFoundException)
{
	DWORD	seekPos,size;
	if( !FindIndex(inKey, &seekPos , &size ) )	throw RNotFoundException("見つかりません");

	if ( fseek(File , seekPos+CELL_FLG_SIZE , SEEK_SET ) != 0) throw RNotFoundException("シークに失敗しました");

	outData->reserve(size);

	//vector は連続的だから代入できるはず。 そう信じたい
	//証拠
	//	http://anubis.dkuug.dk/JTC1/SC22/WG21/docs/lwg-defects.html#69
	//	http://www.tietew.jp/cppll/archive/4822
	fread( &((*outData)[0]) , sizeof(char) , size , File);
}

/**
 * Insert:					挿入
 *
 * @param inKey				検索キー
 * @param inData			挿入するデータ
 * @return void 
 */
BigClass::Insert(DWORD inKey ,const RBuffer& inData ) throw(RNotFoundException)
{
	DWORD seekPos , size;
	if( FindIndex(inKey , &seekPos , &size) )throw RNotFoundException("すでに値があります");

	if ( fseek(File , 0 , SEEK_END ) != 0) throw RNotFoundException("シークに失敗しました");

	InsertIndex( inKey , ftell(File) , inData.size());

	DWORD flg[2];	//control , size
	flg[0] = FLG_SET(0,CELL_ALIVE_FLG);
	flg[1] = inData.size();
	fwrite( flg , sizeof(DWORD) , 2 , File);
	fwrite( &(inData[0]) , sizeof(char) , flg[1] , File);
}

/**
 * Update:					変更
 *
 * @param inKey				検索キー
 * @param inData			変更するデータ
 * @return void 
 */
BigClass::Update(DWORD inKey ,const RBuffer& inData ) throw(RNotFoundException)
{
	DWORD	seekPos,size;
	if( !FindIndex(inKey, &seekPos , &size ) )	throw RNotFoundException("見つかりません");

	if (inData.size() == (size) )
	{	//もともとの大きさといっしょ
		if ( fseek(File , seekPos+CELL_FLG_SIZE , SEEK_SET ) != 0) throw RNotFoundException("シークに失敗しました");
		fwrite( &(inData[0]) , sizeof(char) ,inData.size() , File);
	}
	else
	{
		DWORD flg[2];
		if ( fseek(File , seekPos , SEEK_SET ) != 0) throw RNotFoundException("シークに失敗しました");

		if ( (inData.size()+CELL_FLG_SIZE) < size )
		{	//もともとの大きさより小さくなる セルを分割できる.
			flg[0] = FLG_SET(0,CELL_ALIVE_FLG);
			flg[1] = inData.size();

			fwrite( flg , sizeof(DWORD) , 2 , File);
			fwrite( &(inData[0]) , sizeof(char) ,inData.size() , File);

			//残りのセルは削除されたと報告.
			flg[0] = FLG_SET(0,CELL_DELETE_FLG);
			flg[1] = size - inData.size() - CELL_FLG_SIZE;
			ASSERT(flg[1] >= 0)
			fwrite( flg , sizeof(DWORD) , 2 , File);
		}
		else
		{	//もともとのサイズより大きくなる.
			DWORD free = CheckFreeSize(seekPos + size) + size;
			if (free >= inData.size() + CELL_FLG_SIZE)
			{//空き領域に格納できる.
				flg[0] = FLG_SET(0,CELL_ALIVE_FLG);
				flg[1] = inData.size();
				fwrite( flg , sizeof(DWORD) , 2 , File);
				fwrite( &(inData[0]) , sizeof(char) ,inData.size() , File);

				//空き領域は分断する.
				flg[0] = FLG_SET(0,CELL_DELETE_FLG);
				flg[1] = free - inData.size();
				fwrite( flg , sizeof(DWORD) , 2 , File);
			}
			else
			{//どうしようない...
				//現在の領域には収まりきれないので、
				//現在の領域を破棄してファイルの最後に追加します.
				flg[0] = FLG_SET(0,CELL_DELETE_FLG);
				flg[1] = size;
				fwrite( flg , sizeof(DWORD) , 2 , File);

				fseek(File , 0 , SEEK_END );	//ファイルの最後に

				//インデックス値の更新.
				UpdateIndex(inKey , ftell(File) , inData.size());

				flg[0] = FLG_SET(0,CELL_ALIVE_FLG);
				flg[1] = inData.size();
				fwrite( flg , sizeof(DWORD) , 2 , File);
				fwrite( &(inData[0]) , sizeof(char) ,inData.size() , File);

			}
		}
	}
}

/**
 * Delete:					削除
 *
 * @param inKey				検索キー
 * @return void				
 */
BigClass::Delete(DWORD inKey ) throw(RNotFoundException)
{
	DWORD	seekPos,size;
	if( !FindIndex(inKey, &seekPos , &size ) )	throw RNotFoundException("見つかりません");

	if ( fseek(File , seekPos , SEEK_SET ) != 0) throw RNotFoundException("シークに失敗しました");

	DeleteIndex( inKey  );

	DWORD flg;
	flg = FLG_SET(0,CELL_DELETE_FLG);
	fwrite( &flg , sizeof(DWORD) , 1 , File);
}

/**
 * IsHit:					存在チェック
 *
 * @param inKey				検索キー
 * @return bool 
 */
BigClass::IsHit(DWORD inKey ) const
{
	DWORD	seekPos,size;
	return FindIndex(inKey, &seekPos , &size );
}


/**
 * Vacuum:					不要なデータを整理します	(Windowsでいえば デフラグ)
 *
 * @return void 
 */
BigClass::Vacuum( )
{
}


/**
 * CheckFreeSize:			現在の場所よりどれだけのフリースペースを確保できるか調べます
 *
 * @param inStart			開始する場所
 * @return DWORD			確保できるサイズ
 */
BigClass::CheckFreeSize(DWORD inStart)
{
	DWORD free = 0;
	DWORD nextPoint = inStart;

	DWORD flg[2];	//control , size

	while( !feof(File) )
	{
		fseek(File ,nextPoint , SEEK_SET );	//次のセルに移動
		if ( !fread( flg , sizeof(DWORD) , 2 , File) )		//次のセルの情報を取得.
		{
			return free;
		}

		if ( !IS_FLG_SET(flg[0],CELL_DELETE_FLG) ) return free;

		free += flg[1];
		nextPoint += (flg[1] + CELL_FLG_SIZE);
	}
	return free;
}

BigClass::test()
{
	{
		RFileDB		db;
		db.Create("testdata/rfdbtest1.dat" , 13);

		//とりあえず 追加できるか?
		{
			RBuffer buffer;
			buffer = "test10";
			db.Insert(10,buffer);
			buffer = "test20";
			db.Insert(20,buffer);
			buffer = "test30";
			db.Insert(30,buffer);
			buffer = "test40";
			db.Insert(40,buffer);
			buffer = "test50";
			db.Insert(50,buffer);

			db.Select(10,&buffer);
			ASSERT( buffer == "test10" ); 
			db.Select(20,&buffer);
			ASSERT( buffer == "test20" ); 
			db.Select(30,&buffer);
			ASSERT( buffer == "test30" ); 
			db.Select(40,&buffer);
			ASSERT( buffer == "test40" ); 
			db.Select(50,&buffer);
			ASSERT( buffer == "test50" ); 
		}
		//削除できるか?
		{
			RBuffer buffer;
			db.Delete(10);
			db.Delete(30);
			db.Delete(50);

			ASSERT( db.IsHit(10) == false);
			ASSERT( db.IsHit(20) == true);
			ASSERT( db.IsHit(30) == false);
			ASSERT( db.IsHit(40) == true);
			ASSERT( db.IsHit(50) == false);

		}
		//変更できるか?
		{
			RBuffer buffer;

			//同じ大きさ
			buffer = "test20";
			db.Update(20 , buffer);
			db.Select(20 , &buffer);
			ASSERT( buffer == "test20");

			//小さい
			buffer = "t20";
			db.Update(20 , buffer);
			db.Select(20 , &buffer);
			ASSERT( buffer == "t20");

			//すこし大きい
			buffer = "test!!20";
			db.Update(20 , buffer);
			db.Select(20 , &buffer);
			ASSERT( buffer == "test!!20");

			//とても大きい
			buffer = "teeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeest20";
			db.Update(20 , buffer);
			db.Select(20 , &buffer);
			ASSERT( buffer == "teeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeest20");

			//小さい
			buffer = "t20";
			db.Update(20 , buffer);
			db.Select(20 , &buffer);
			ASSERT( buffer == "t20");
		
			//同じ大きさ
			buffer = "test20";
			db.Update(20 , buffer);
			db.Select(20 , &buffer);
			ASSERT( buffer == "test20");
		}
	}
	{
		RFileDB		db;
		RBuffer buffer;
		RBuffer t;
		db.Create("testdata/rfdbtest2.dat" , 13);

		buffer = "あにくん";
		db.Insert(3 , buffer);
		buffer = "あにぃ";
		db.Insert(2 , buffer);
		buffer = "にぃさま";
		db.Insert(0 , buffer);
		buffer = "おにぃちゃま";
		db.Insert(1 , buffer);

		buffer = "あにちゃま";
		db.Update(1 , buffer);
		buffer = "にぃさま";
		db.Update(0 , buffer);
		buffer = "あにき";
		db.Update(2 , buffer);
		buffer = "あにうえさま";
		db.Update(3 , buffer);

		t = "にぃさま";
		db.Select(0 , &buffer);
		ASSERT( memcmp(buffer.c_str() , t.c_str() , t.size() ) == 0);

		t = "あにちゃま";
		db.Select(1 , &buffer);
		ASSERT( memcmp(buffer.c_str() , t.c_str() , t.size() ) == 0);

		t = "あにき";
		db.Select(2 , &buffer);
		ASSERT( memcmp(buffer.c_str() , t.c_str() , t.size() ) == 0);

		t = "あにうえさま";
		db.Select(3 , &buffer);
		ASSERT( memcmp(buffer.c_str() , t.c_str() , t.size() ) == 0);
	}
	{
		RFileDB		db;
		RBuffer buffer;
		RBuffer t;
		db.Create("testdata/rfdbtest2.dat" , 13);

		buffer = "あにちゃま";
		db.Insert(9 , buffer);
		buffer = "あにぎみさま";
		db.Insert(0 , buffer);
		buffer = "あにちゃま";
		db.Insert(1 , buffer);
		buffer = "あにき";
		db.Insert(6 , buffer);
		buffer = "おにぃたま";
		db.Insert(2 , buffer);
		buffer = "にいや";
		db.Insert(3 , buffer);
		buffer = "あにちゃま";
		db.Insert(7 , buffer);
		buffer = "おにぃちゃん";
		db.Insert(4 , buffer);
		buffer = "あにちゃま";
		db.Insert(5 , buffer);
		buffer = "おにぃちゃん";
		db.Insert(8 , buffer);

		AssertFinder(&db ,10,  "あにぎみさま" , "あにちゃま" , "おにぃたま", "にいや", "おにぃちゃん", 
							   "あにちゃま", "あにき", "あにちゃま", "おにぃちゃん", "あにちゃま");
		buffer = "おにぃちゃま";
		db.Update(6 , buffer);
		AssertFinder(&db ,10,  "あにぎみさま" , "あにちゃま" , "おにぃたま", "にいや", "おにぃちゃん", 
							   "あにちゃま", "おにぃちゃま", "あにちゃま", "おにぃちゃん", "あにちゃま");

		buffer = "あにくん";
		db.Update(4 , buffer);
		AssertFinder(&db ,10,  "あにぎみさま" , "あにちゃま" , "おにぃたま", "にいや", "あにくん", 
							   "あにちゃま", "おにぃちゃま", "あにちゃま", "おにぃちゃん", "あにちゃま");

		buffer = "にぃさま";
		db.Update(0 , buffer);
		AssertFinder(&db ,10,  "にぃさま" , "あにちゃま" , "おにぃたま", "にいや", "あにくん", 
							   "あにちゃま", "おにぃちゃま", "あにちゃま", "おにぃちゃん", "あにちゃま");

		buffer = "あにき";
		db.Update(1 , buffer);
		AssertFinder(&db ,10,  "にぃさま" , "あにき" , "おにぃたま", "にいや", "あにくん", 
							   "あにちゃま", "おにぃちゃま", "あにちゃま", "おにぃちゃん", "あにちゃま");

		buffer = "おにぃちゃん";
		db.Update(7 , buffer);
		AssertFinder(&db ,10,  "にぃさま" , "あにき" , "おにぃたま", "にいや", "あにくん", 
							   "あにちゃま", "おにぃちゃま", "おにぃちゃん", "おにぃちゃん", "あにちゃま");

		buffer = "おにぃちゃま";
		db.Update(2 , buffer);
		AssertFinder(&db ,10,  "にぃさま" , "あにき" , "おにぃちゃま", "にいや", "あにくん", 
							   "あにちゃま", "おにぃちゃま", "おにぃちゃん", "おにぃちゃん", "あにちゃま");

		buffer = "あにぃ";
		db.Update(3 , buffer);
		AssertFinder(&db ,10,  "にぃさま" , "あにき" , "おにぃちゃま", "あにぃ", "あにくん", 
							   "あにちゃま", "おにぃちゃま", "おにぃちゃん", "おにぃちゃん", "あにちゃま");

		buffer = "あにき";
		db.Update(5 , buffer);
		AssertFinder(&db ,10,  "にぃさま" , "あにき" , "おにぃちゃま", "あにぃ", "あにくん", 
							   "あにき", "おにぃちゃま", "おにぃちゃん", "おにぃちゃん", "あにちゃま");

		buffer = "あにき";
		db.Update(8 , buffer);
		AssertFinder(&db ,10,  "にぃさま" , "あにき" , "おにぃちゃま", "あにぃ", "あにくん", 
							   "あにき", "おにぃちゃま", "おにぃちゃん", "あにき", "あにちゃま");

		buffer = "あにぃ";
		db.Update(9 , buffer);
		AssertFinder(&db ,10,  "にぃさま" , "あにき" , "おにぃちゃま", "あにぃ", "あにくん", 
							   "あにき", "おにぃちゃま", "おにぃちゃん", "あにき", "あにぃ");
	}
	//ストレス
	{
		printf("ストレステスト準備中 \r\n");
		RFileDB		db;
		db.Create("testdata/rfdbtest10.dat" , 13);

		
		RBuffer buffer;

//		const int testCount = 1000000;
		const int testCount = 100;

		//追加するデータ
		string callme[12];
		callme[0] = "おにぃちゃん";
		callme[1] = "おにぃさま";
		callme[2] = "にぃさま";
		callme[3] = "あにき";
		callme[4] = "おにぃちゃま";
		callme[5] = "あにぃ";
		callme[6] = "おにぃたま";
		callme[7] = "あにうえさま";
		callme[8] = "あにくん";
		callme[9] = "あにぎみさま";
		callme[10] = "あにちゃま";
		callme[11] = "にいや";
		StTestData *InsertMap = new StTestData[testCount];
		StTestData *UpdateMap = new StTestData[testCount];
		//ストレステスト用のデータを作成.
		StressTestMakeRandomData( InsertMap ,testCount , 12 );
		StressTestMakeRandomData( UpdateMap ,testCount , 12 );

		printf("ストレステスト開始 \r\n");
		time_t startTime = time(NULL);
		time_t stepStartTime = time(NULL);
		int i;

		for(i = 0; i < testCount ; i++)
		{
			db.Insert(InsertMap[i].pos , callme[ InsertMap[i].str ] );
		}

		printf("Step経過時間 : %d 秒\r\n", time(NULL) - stepStartTime );
		stepStartTime = time(NULL);
		//正常に追加されたのを確認.
		for(i = 0; i < testCount ; i++)
		{
			db.Select(InsertMap[i].pos , &buffer);
			ASSERT( memcmp(buffer.c_str() , callme[ InsertMap[i].str ].c_str() , callme[ InsertMap[i].str ].size() ) == 0);
		}

		printf("Step経過時間 : %d 秒\r\n", time(NULL) - stepStartTime );
		stepStartTime = time(NULL);

		for(i = 0; i < testCount ; i++)
		{
			db.Update(UpdateMap[i].pos , callme[ UpdateMap[i].str ] );
		}

		printf("Step経過時間 : %d 秒\r\n", time(NULL) - stepStartTime );
		stepStartTime = time(NULL);
		//正常に追加されたのを確認.
		for(i = 0; i < testCount ; i++)
		{
			db.Select(UpdateMap[i].pos , &buffer);
			ASSERT( memcmp(buffer.c_str() , callme[ UpdateMap[i].str ].c_str() , callme[ UpdateMap[i].str ].size() ) == 0);
		}
		printf("Step経過時間 : %d 秒\r\n", time(NULL) - stepStartTime );
		printf("経過時間 : %d 秒\r\n", time(NULL) - startTime );

		delete [] UpdateMap;
		delete [] InsertMap;
	}
}

//引数の順にデーターベースに格納されているかどうかテストする   テスト用
BigClass::AssertFinder(const RFileDB * inDB , int inNumber ,...)
{
	va_list ap;
	va_start(ap, inNumber);

	RBuffer buffer;
	va_start(ap, inNumber);

	string str;
	for(int i = 0; i < inNumber ; i++ )
	{
		str = va_arg( ap, const char*);
		inDB->Select( i , &buffer);

		ASSERT( memcmp(buffer.c_str() , str.c_str() , str.size() ) == 0);
	}
	va_end(ap);
}


//ストレステスト用のデータを作成.
BigClass::StressTestMakeRandomData(StTestData * outData , const int inTestCount , const int inTestDataCount)
{
	srand((unsigned)time(NULL));

	//ユニークになるように.
	char * flg = new char[inTestCount];
	memset(flg , 0 , sizeof(char) * inTestCount);

	int lastUniq = 0;
	//ランダムに追加
	for(int i = 0; i < inTestCount ; i++)
	{
		int r = rand() % inTestCount;

		if ( flg[r] != 0)
		{	//あいていないなら空きを探す
			for(int l = lastUniq ; l < inTestCount ; l ++)
			{
				if ( flg[l] == 0)
				{
					r = l;
					lastUniq = l;
					break;
				}
			}
		}
		flg[r] = 1;
		outData[i].pos = r;
		outData[i].str = rand() % inTestDataCount ;
	}

	delete [] flg;
}

#define RTEMPLATE_LOOP_START	"<!--?LS:"
#define RTEMPLATE_TAG_END		"-->"
#define RTEMPLATE_LOOP_END		"<!--?LE:"

#define RTEMPLATE_VALUE_START	"<!--?V:"

//////////////////////////////////////////////////////////////////////
// 構築/消滅
//////////////////////////////////////////////////////////////////////

BigClass::RHtmlTemplate()
{
	this->Perent = NULL;
}

BigClass::~RHtmlTemplate()
{
	CleanUp();
}


BigClass::Load(const string inFilename) throw(RIOCannotOpenException,RParseException)
{
	CleanUp();

	struct _stat statbuf;
	if ( _stat( inFilename.c_str() ,  &statbuf) == -1)
	{
		throw RIOCannotOpenException(EXCEPTIONTRACE + "stat の取得に失敗" + inFilename);
	}
	int size = statbuf.st_size;
	char * buf =  new char[size + 1];
	
	FILE * fp = fopen( inFilename.c_str() ,"rb");
	if (fp == NULL)
	{
		delete [] buf;
		throw RIOCannotOpenException(EXCEPTIONTRACE + "DATファイルが開けませんでした" + inFilename);
	}
	size = fread( buf ,sizeof(char), size ,fp);
	fclose(fp);

	buf[size] = '\0';

	this->Parse( buf ,size , 0);
	delete [] buf;
}

//子供の場合.
BigClass::Load(const RHtmlTemplate* inPerent ,const string inContect, int inStartLine) throw(RParseException)
{
	CleanUp();

	this->Perent = inPerent;

	this->Parse( inContect.c_str() ,inContect.size() , inStartLine);
}


/**
 * Parse:						内容を解析し、静的、ループ、置換 の項目別にリスト構造に変換します。
 *								パースは汚くなりますね(w
 *
 * @param inTargetBuffer		解析される値 最後に \0 が入っていることは保証される
 * @param inSize				解析される値のサイズ
 * @param inStartLine			.tpl ファイルでのinTargetBufferがある行数 エラー行を出力するときに使う
 * @return void					
 * @exception	RParseException	構文解析エラー
 */
BigClass::Parse(const char* inTargetBuffer , int inSize, int inStartLine) throw(RParseException)
{
	const char * p = inTargetBuffer;
	const char * territory = inTargetBuffer + inSize;	
	const char* oldpos = p;
	while(1)
	{
		oldpos = p;

		//ループタグの検索
		//例 <!--?LS:Kahotan-->
		const char* loopstart = strstr(p , RTEMPLATE_LOOP_START);
		if (loopstart == NULL) break;
		p=loopstart + sizeof(RTEMPLATE_LOOP_START) - 1;

		const char* looptagend = strstr(p , RTEMPLATE_TAG_END);
		if (looptagend == NULL)
		{
			throw RParseException("%d行目:ループ開始タグが閉じていません" , getline(inTargetBuffer , loopstart) + inStartLine);
		}
		// p 〜 looptagend までがタグの名前.
		string tagname = string(p , 0 , looptagend - p);

		p=looptagend + sizeof(RTEMPLATE_LOOP_START) - 1;

		//例 <!--?LE:Kahotan-->
		//このタグをサーチしる.
		const string LoopEndTagName = string(RTEMPLATE_LOOP_END) + tagname + RTEMPLATE_TAG_END;
		//ループタグの終わりを検索.
		const char* loopend = strstr(p , LoopEndTagName.c_str());
		if (loopend == NULL) 
		{
			throw RParseException("%d行目:ループ開始はあるのに終了がありません" , getline(inTargetBuffer , loopstart) + inStartLine);
		}

		//登録したいのですが、実はそのタグが激しくガイシュツではないか調べる.
		if ( this->Select(tagname) != NULL)
		{
			throw RParseException("%d行目〜%d行目:ループ開始,終了のタグ(%s)は激しくガイシュツです" , 
				getline(inTargetBuffer , loopstart) + inStartLine, 
				getline(inTargetBuffer , loopend) + inStartLine, 
				tagname.c_str() );
		}

		//ループの前にある置換タグをすべて取得します。
		this->ParseValue(oldpos , loopstart - oldpos , getline(inTargetBuffer , loopstart) );
		//このループを置換タグとして登録します。
BigClass::DynamicContent , tagname) );
		//ループ自体を登録します。
		const char* tagContentStart = looptagend + sizeof(RTEMPLATE_TAG_END)- 1;
		RHtmlTemplate * childTemplate = new RHtmlTemplate();
		Loop[tagname] =  childTemplate;
		childTemplate->Load(this , string(tagContentStart , 0 , loopend - tagContentStart) , getline(inTargetBuffer , loopstart) );

		p = loopend + LoopEndTagName.size();
	}
	//残りの領域の調査.
	this->ParseValue(oldpos , territory - oldpos , getline(inTargetBuffer , oldpos) );
}

/**
 * ParseValue:					内容を解析し、静的、置換、の項目別にリスト構造に変換します。
 *								パースは汚くなりますね(w
 *
 * @param inTargetBuffer		解析される値 最後に \0 が入っていることは保証される
 * @param inSize				解析される値のサイズ
 * @param inStartLine			.tpl ファイルでのinTargetBufferがある行数 エラー行を出力するときに使う
 * @return void					
 * @exception	RParseException	構文解析エラー
 */
BigClass::ParseValue(const char* inTargetBuffer,int inSize , int inStartLine) throw(RParseException)
{
	const char * p = inTargetBuffer;
	const char * territory = inTargetBuffer + inSize;	
	const char* oldpos = p;
	while(1)
	{
		oldpos = p;

		//置換タグの検索
		//例 <!--?V:Kahotan-->
		const char* valuestart = strstr(p , RTEMPLATE_VALUE_START);
		if (valuestart == NULL) break;			//見つからない
		if (valuestart >= territory) break;		//担当範囲外

		p=valuestart + sizeof(RTEMPLATE_VALUE_START)- 1;

		//置換タグの終了をサーチ
		const char* valueend = strstr(p , RTEMPLATE_TAG_END);
		if (valueend == NULL)
		{
			throw RParseException("%d行目:置換タグが閉じていません" , getline(inTargetBuffer , valuestart) + inStartLine );
		}
		if (valueend >= territory)
		{
			throw RParseException("%d行目:置換タグがおかしいことになっています" , getline(inTargetBuffer , valuestart) + inStartLine );
		}
		//oldpos 〜 valuestart までが静的コンテンツです。
		if (valuestart-oldpos > 0)
		{
			ReplaceIndex.push_back( 
BigClass::StaticContent , string(oldpos , 0 , valuestart-oldpos) ) );
		}
		//p 〜 valueend までがタグの名前です。
		string tagname = string(p , 0 , valueend - p);
		//そして、それが動的コンテンツです。
BigClass::DynamicContent , tagname) );

		p=valueend + sizeof(RTEMPLATE_TAG_END)- 1;
	}
	//残りはすべて静的コンテンツ.
	if (territory-oldpos > 0)
	{
		ReplaceIndex.push_back( 
BigClass::StaticContent , string(oldpos , 0 , territory-oldpos) ) );
	}
}


/**
 * getline:				行数を数える
 *
 * @param inStart		ここからはじまって
 * @param inTarget		ここまで
 * @return int			行数
 */
BigClass::getline(const char * inStart , const char* inEnd) const
{
	int count = 0;
	const char* p = inStart;
	while( p < inEnd )
	{
		if (*p == '\n') count++;
		p++;
	}
	return count;
}

/**
 * CleanUp:				new で確保したものの解放
 *
 * @return void 
 */
BigClass::CleanUp()
{
	{
BigClass::iterator i = Loop.begin() ; i != Loop.end() ; ++i)
		{
			delete (*i).second;
		}
		Loop.clear();
	}
	{
BigClass::iterator i = ReplaceIndex.begin() ; i != ReplaceIndex.end() ; ++i)
		{
			delete (*i);
		}
		ReplaceIndex.clear();
	}
}

/**
 * Replace:						置換を行う
 *
 * @param inReplaceStringMap	置換する文字列のマップ
 * @return string				結果 
 */
BigClass::Replace(const RStringMap * inReplaceStringMap) const
{
	int length = 0;
	{
BigClass::const_iterator i = ReplaceIndex.begin() ; i != ReplaceIndex.end() ; ++i)
		{
			const RHtmlTemplateContent* htc = (*i);
			length += htc->getConectLength(inReplaceStringMap);
		}
	}

	string ret ;
	ret.reserve(length);
	{
BigClass::const_iterator i = ReplaceIndex.begin() ; i != ReplaceIndex.end() ; ++i)
		{
			const RHtmlTemplateContent* htc = (*i);
			ret += htc->getConect(inReplaceStringMap);
		}
	}
	return ret;
}

BigClass::Dump() const
{
	{
BigClass::Dump() ===========================\r\n");
BigClass::const_iterator i = ReplaceIndex.begin() ; i != ReplaceIndex.end() ; ++i)
		{
			printf("\r\n===================== part. ===========================\r\n");
			const RHtmlTemplateContent* htc = (*i);
			puts( htc->Dump().c_str() );
		}
		printf("===================== --------------------- ===========================\r\n");
	}
}


BigClass::RHTTPPOSTParser()
{

}

BigClass::~RHTTPPOSTParser()
{

}

BigClass::Parse(const char* inBuffer , int inSize )
{
	int columStart = 0;
	for(int i = 0; i < inSize ; i ++)	//A
	{
		// = までサーチ.
		if ( inBuffer[i] == '=' )
		{
			int valueStart = i;
			for( i=i+1 ; i < inSize ; i ++)	//B
			{
				//区切りの & をサーチ.
				if ( inBuffer[i] == '&' )
				{
BigClass::chop(string(inBuffer , columStart , valueStart - columStart )) ] = 
BigClass::UrlEncode( string(inBuffer , valueStart+1 , i -(valueStart+1) ) );
					++i;
					columStart = i;
					break;	//Bのループを抜ける.
				}
			}
			if (i >= inSize)
			{
BigClass::chop(string(inBuffer , columStart , valueStart - columStart )) ] = 
BigClass::UrlEncode( string(inBuffer , valueStart+1 , i -(valueStart+1) ) );
			}
		}
	}
}

BigClass::Dump()
{
	puts("========================== POST Dump ============================");
	//すべて解放.
BigClass::iterator i = PostData.begin() ; i != PostData.end() ; ++i)
	{
		printf("%s -> %s\n",(*i).first.c_str(),(*i).second.c_str());
	}
	puts("========================== ========= ============================");
}

 
BigClass::test()
{
	{
		RHTTPPOSTParser	rhpp;
		string a;
		const char* test = "submit=%8F%91%82%AB%8D%9E%82%DE&key=1043426551&FROM=&mail=&MESSAGE=%82%D2%82%B1%81K%82%D2%82%B1&bbs=rti&time=1043440535";
		rhpp.Parse( test , strlen(test) );

		ASSERT( (a = rhpp.PostData["bbs"]) == "rti");
	}
	{
		RHTTPPOSTParser	rhpp;
		string a;
		const char* test = "aaa=bbb";
		rhpp.Parse( test , strlen(test) );

		ASSERT( (a = rhpp.PostData["aaa"]) == "bbb");
	}
	{
		RHTTPPOSTParser	rhpp;
		string a;
		const char* test = "aaa=bbb&ccc=dddd";
		rhpp.Parse( test , strlen(test) );

		ASSERT( (a = rhpp.PostData["aaa"]) == "bbb");
		ASSERT( (a = rhpp.PostData["ccc"]) == "dddd");
	}
	{
		RHTTPPOSTParser	rhpp;
		string a;
		const char* test = "aaa=bbb&";
		rhpp.Parse( test , strlen(test) );

		ASSERT( (a = rhpp.PostData["aaa"]) == "bbb");
	}
	{
		RHTTPPOSTParser	rhpp;
		string a;
		const char* test = "aaa=bbb&bbb=%aaaa&&";
		rhpp.Parse( test , strlen(test) );

		ASSERT( (a = rhpp.PostData["aaa"]) == "bbb");
		ASSERT( (a = rhpp.PostData["bbb"]) == "%aaaa");
	}
	{
		RHTTPPOSTParser	rhpp;
		string a;
		const char* test = "bbs=rti&key=1041563575&submit=%8F%91%82%AB%8D%9E%82%DE&FROM=&mail=&MESSAGE=aaaa";
		rhpp.Parse( test , strlen(test) );

		ASSERT( (a = rhpp.PostData["bbs"]) == "rti");
		ASSERT( (a = rhpp.PostData["key"]) == "1041563575");
		ASSERT( (a = rhpp.PostData["FROM"]) == "");
	}
}



BigClass::RIPFilter()
{

}

BigClass::~RIPFilter()
{
	Clear();
}

BigClass::Clear()
{
BigClass::iterator i = IPList.begin() ; i != IPList.end() ; ++i)
	{
		delete (*i);
	}
}

BigClass::Load(const string inFilename)
{
	Clear();

	FILE * fp = fopen( inFilename.c_str() ,"rb");
	if (fp == NULL)
	{
		return;
	}

	char buf[MAX_PATH];

	int line = 0;
	while( !feof(fp) )
	{
		if ( fgets(buf , MAX_PATH , fp) == NULL ) break;

		line++;
		if ( buf[0] == '\0' || buf[0] == '#' ) continue;

		try
		{
BigClass::chop(buf) );
		}
		catch(RParseException e)
		{
			printf("IPフィルターリストを読み込み中にエラーが発生しました(%d行目):%s\r\n" , line , e.getMessage() );
		}	
	}

	fclose(fp);
}

BigClass::AppendIP(const string inLine) throw(RParseException)
{
	const char* line = inLine.c_str();

	//x.x.x.x-y.y.y.y 形式?
	const char * m = strchr(line , '-');
	if ( m != NULL )
	{	//x.x.x.x-y.y.y.y 形式.
		string from = string( line , 0 , m - line );
		string to = string( line + (m - line + 1) );

		in_addr fromIP ;
		in_addr toIP ;
		fromIP.s_addr = inet_addr( from.c_str() );
		toIP.s_addr = inet_addr( to.c_str() );

		if (fromIP.s_addr == INADDR_NONE)
		{
			throw RParseException(EXCEPTIONTRACE + "(" + from + ")有効なIPではありません.");
		}
		if (toIP.s_addr == INADDR_NONE)
		{
			throw RParseException(EXCEPTIONTRACE + "(" + to + ")有効なIPではありません.");
		}
		IPList.push_back( new RIPFilterData(fromIP , toIP) );
		return ;
	}
	//x.x.x.x/y 形式?
	m = strchr(line , '/');
	if ( m != NULL )
	{	//x.x.x.x/y 形式.
		string from = string( line , 0 , m - line );
		string mask = string( line + (m - line + 1)  );

		in_addr fromIP ;
		fromIP.s_addr = inet_addr( from.c_str() );
		int IPmask = atoi( mask.c_str() ); 

		if (fromIP.s_addr == INADDR_NONE)
		{
			throw RParseException(EXCEPTIONTRACE + "(" + from + ")有効なIPではありません.");
		}
		if (IPmask < 0 || IPmask > 32)
		{
			throw RParseException(EXCEPTIONTRACE + "(" + mask + ")マスクする範囲が正しくありません(0〜32までにしてください).");
		}
		IPList.push_back( new RIPFilterData(fromIP , IPmask) );
		return ;
	}
	throw RParseException(EXCEPTIONTRACE + "文法エラーです。だだしく記述してください" + inLine );
}

BigClass::test()
{
	in_addr a,b,c;
	{
		a.s_addr = inet_addr("192.168.1.10");
		b.s_addr = inet_addr("192.168.1.20");

		RIPFilterData p( a , b );
		c.s_addr = htonl(inet_addr("192.168.1.10"));
		ASSERT( p.IsBan( c ) == true );

		c.s_addr = htonl(inet_addr("192.168.1.20"));
		ASSERT( p.IsBan( c ) == true );

		c.s_addr = htonl(inet_addr("192.168.1.15"));
		ASSERT( p.IsBan( c ) == true );
	}
	{
		a.s_addr = inet_addr("192.168.1.10");
		b.s_addr = inet_addr("192.168.1.20");

		RIPFilterData p( a , b );
		c.s_addr = htonl(inet_addr("10.1.168.192"));
		ASSERT( p.IsBan( c ) == false );

		c.s_addr = htonl(inet_addr("192.1.20.10"));
		ASSERT( p.IsBan( c ) == false );

		c.s_addr = htonl(inet_addr("1.1.1.1"));
		ASSERT( p.IsBan( c ) == false );

		c.s_addr = htonl(inet_addr("0.0.0.0"));
		ASSERT( p.IsBan( c ) == false );
	}
	{
		a.s_addr = inet_addr("192.168.1.10");
		
		RIPFilterData p( a , 24 );
		c.s_addr = htonl(inet_addr("192.168.1.10"));
		ASSERT( p.IsBan( c ) == true );

		c.s_addr = htonl(inet_addr("192.168.1.20"));
		ASSERT( p.IsBan( c ) == true );

		c.s_addr = htonl(inet_addr("192.168.1.15"));
		ASSERT( p.IsBan( c ) == true );
	}
	{
		a.s_addr = inet_addr("192.168.1.10");

		RIPFilterData p( a , 24 );
		c.s_addr = htonl(inet_addr("10.1.168.192"));
		ASSERT( p.IsBan( c ) == false );

		c.s_addr = htonl(inet_addr("192.1.20.10"));
		ASSERT( p.IsBan( c ) == false );

		c.s_addr = htonl(inet_addr("1.1.1.1"));
		ASSERT( p.IsBan( c ) == false );

		c.s_addr = htonl(inet_addr("0.0.0.0"));
		ASSERT( p.IsBan( c ) == false );
	}
}

BigClass::test()
{
	RIPFilter p;
	p.Load("testdata/ripfilter.txt");

	in_addr a;
	a.s_addr = htonl(inet_addr("192.168.1.10"));
	ASSERT( p.IsBan(a) == false );

}

BigClass::RMmap()
{
	this->MapFile = NULL;
	this->MapObject = NULL;
	this->MapMemory = NULL;
}

BigClass::~RMmap()
{
	if (this->MapObject)	Release();
}

BigClass::Create(DWORD inMappingSize) throw(RWin32Exception)
{
	ASSERT(this->MapFile == NULL);	
	ASSERT(this->MapObject == NULL);
	ASSERT(this->MapMemory == NULL);

	this->MapObject = CreateFileMapping( INVALID_HANDLE_VALUE , NULL, PAGE_READWRITE , 0, inMappingSize	, NULL);
	if (this->MapObject == NULL)	throw RWin32Exception(EXCEPTIONTRACE + "メモリマップの作成に失敗");

	this->MapMemory = MapViewOfFile(this->MapObject , FILE_MAP_ALL_ACCESS , 0, 0, 0);
	if (this->MapMemory == NULL)	throw RWin32Exception(EXCEPTIONTRACE + "メモリマップの関連付けに失敗");
}

BigClass::Create(const string inFilename ,DWORD inMappingSize) throw(RWin32Exception)
{
	ASSERT(this->MapFile == NULL);
	ASSERT(this->MapObject == NULL);
	ASSERT(this->MapMemory == NULL);

	this->MapFile = CreateFile( inFilename.c_str() ,
								GENERIC_READ | GENERIC_WRITE,
								NULL,NULL,OPEN_EXISTING,
								FILE_FLAG_RANDOM_ACCESS,NULL );
	if (this->MapFile == INVALID_HANDLE_VALUE)
	{
		throw RWin32Exception(EXCEPTIONTRACE + "ファイル" + inFilename + "が開けません");
	}

	this->MapObject = CreateFileMapping( this->MapFile , NULL, PAGE_READWRITE, 0, inMappingSize	, NULL);
	if (this->MapObject == NULL)	throw RWin32Exception(EXCEPTIONTRACE + "メモリマップの作成に失敗");

	this->MapMemory = MapViewOfFile(this->MapObject , FILE_MAP_ALL_ACCESS  , 0, 0, 0);
	if (this->MapMemory == NULL)	throw RWin32Exception(EXCEPTIONTRACE + "メモリマップの関連付けに失敗");
	DWORD err = GetLastError();
	if (err  == ERROR_ALREADY_EXISTS ) throw RWin32Exception(err,EXCEPTIONTRACE + "メモリマップの関連付けに失敗");
}

BigClass::Release()
{
	ASSERT(this->MapObject != NULL);
	ASSERT(this->MapMemory != NULL);

	UnmapViewOfFile(this->MapMemory);
	CloseHandle(this->MapObject);

	if (this->MapFile)
	{
		CloseHandle(this->MapFile);
	}
	this->MapFile = NULL;
	this->MapObject = NULL;
	this->MapMemory = NULL;
}

BigClass::Flush(DWORD inFlushSize)
{
	if ( !FlushViewOfFile(this->MapMemory,inFlushSize ) ) throw RWin32Exception(EXCEPTIONTRACE + "マッピングファイルのフラッシュに失敗");
}

BigClass::test()
{
	//4バイトのファイルをマップして 5バイト目を書き込んで、フラッシュしてみる
	{
		RMmap	map;
BigClass::MemoryToFile("testdata/rmmap1.txt" , "abcd");
		map.Create( "testdata/rmmap1.txt" , 100 );
		char * p = (char*) map.getMemory();
		//読めます?
		ASSERT(p[0] == 'a');
		ASSERT(p[1] == 'b');
		ASSERT(p[2] == 'c');
		//かけます?
		p[4] = 'X';
		ASSERT(p[4] == 'X');
		map.Flush(0);
		map.Release();
BigClass::FileVerify("testdata/rmmap1.txt" ,"testdata/rmmap1_1.txt" );
	}
}

//受信バッファの最大値.
const int RESERVE_BUFFER_SIZE	= 50000;

//////////////////////////////////////////////////////////////////////
// 構築/消滅
//////////////////////////////////////////////////////////////////////

/**
 * RSocket:		コンストラクタ
 *				とりあえず初期化します。
 */
BigClass::RSocket()
{
	Socket = INVALID_SOCKET;
	IsConnect = false;
}
/**
 * RSocket:		コンストラクタ
 *				指定されたソケットで初期化します。
 *
 * @param inNewSocket	既につながっているソケット.
 * @return  
 */
BigClass::RSocket(SOCKET inNewSocket)
{
	Socket = inNewSocket;
	IsConnect = true;
}


/**
 * ~RSocket:	デストラクタ
 *				ひらきっぱの場合はかってに閉じます。
 */
BigClass::~RSocket()
{
}

/**
 * Open:			ソケットを作成する.
 *
 * @param type		ソケットの種類
 *						SOCK_STREAM : TCPで使用する
 *						SOCK_DGRAM : UDPで使用する
 * @param protocol	使用するプロトコル
 * @throws			RIOCannotOpenException		開けなかったとき
 */
BigClass::Open( int type, int protocol ) throw(RIOCannotOpenException)
{
	Socket = socket(AF_INET,type,protocol);
	if (Socket == INVALID_SOCKET || Socket == NULL) throw RIOCannotOpenException(EXCEPTIONTRACE + "ソケットが開けませんでした" + ErrorToMesage() );
}

/**
 * Connect:				接続(簡易版)
 *
 * @param inHost		ホスト名
 * @param inPort		ポート
 * @throws				RIOException			接続できなかったとき
 */
BigClass::Connect(string inHost , int inPort)	throw(RIOException)
{
	ASSERT(Socket != INVALID_SOCKET);

	//すでに接続しています。
	if (IsConnect)	return ;

	LPHOSTENT	HostEnt;
	SOCKADDR_IN	sai = {0};
	in_addr		iadr;

	iadr.s_addr=inet_addr( inHost.c_str() );
	if(iadr.s_addr==INADDR_NONE)
	{
		HostEnt=gethostbyname(inHost.c_str() );
		if(!HostEnt)
		{
			throw RIOException(EXCEPTIONTRACE + "ホスト名を解決できませんでした" + ErrorToMesage() );
		}
		sai.sin_addr=*((LPIN_ADDR)*HostEnt->h_addr_list);
	}
	else
	{
		sai.sin_addr = iadr;
	}

	sai.sin_port=htons((unsigned short)inPort); // 変換を忘れずに!
	sai.sin_family=AF_INET;

	this->Connect(&sai) ;
}

/**
 * Connect:			接続
 *
 * @param inSai		接続情報
 * @throws			RIOException			接続できなかったとき
 */
BigClass::Connect(const SOCKADDR_IN * inSai) throw(RIOException)
{
	ASSERT(Socket != INVALID_SOCKET);

	//すでに接続しています。
	if (IsConnect)	return ;

	// Winsockで非ブロッキングのソケット通信を行うように設定する.
	unsigned long argp = 1;   // 非ブロッキングに設定 
	if ( ioctlsocket( Socket , FIONBIO , &argp ) )
	{
		throw RIOException(EXCEPTIONTRACE + "非ブロッキングモードへ移動できません" + ErrorToMesage() );
	}

	//接続を試みる.
	int ConnectRet = connect(Socket,(LPSOCKADDR)inSai,sizeof(SOCKADDR_IN));
	if( ! (ConnectRet == 0 || ConnectRet == -1) ) //成功(0) か、まだ終わっていない(-1)でないならば...
	{	//接続に失敗しました.
		string error = ErrorToMesage();	//ブロックモードに戻すときにエラーが上書きされないように先に取得.

		argp = 0;   // ブロッキングに設定 
		ioctlsocket( Socket , FIONBIO , &argp );

		throw RIOException(EXCEPTIONTRACE + "接続に失敗しました" + error );
	}

	try
	{
		//書き込みができるようになるまで待機.
		//タイムアウトが発生すると RIOException が起きます。
		HoldTillReadyForWrite( 60 ) ;
	}
	catch(...)
	{
		argp = 0;   // ブロッキングに設定 
		ioctlsocket( Socket , FIONBIO , &argp );
		throw ;
	}

	argp = 0;   // ブロッキングに設定 
	if ( ioctlsocket( Socket , FIONBIO , &argp ) )
	{
		throw RIOException(EXCEPTIONTRACE + "ブロッキングモードへ移動できません" + ErrorToMesage() );
	}

	IsConnect = true;
}

/**
 * Bind:			bind(簡易版)
 *
 * @param inPort	bindするポート
 * @throws			RIOException		bind失敗
 */
BigClass::Bind(int inPort) throw(RIOException)
{
	ASSERT(Socket != INVALID_SOCKET);

	//すでにbindしています。
	if (IsConnect)	return ;

	int	Opt = 1;
	setsockopt(Socket , SOL_SOCKET, SO_REUSEADDR, (const char*)&Opt , sizeof(int) );

	SOCKADDR_IN	sai = {0};
	sai.sin_family			= AF_INET;
	sai.sin_addr.s_addr	= htonl(INADDR_ANY);
	sai.sin_port			= htons((unsigned short)inPort);

	this->Bind( &sai );
}

/**
 * Bind:			bind
 *
 * @param inSai		bind情報
 * @throws			RIOException		bind失敗
 */
BigClass::Bind(const SOCKADDR_IN * inSai) throw(RIOException)
{
	//すでにbindしています。
	if (IsConnect)	return ;

	int ret = bind(Socket , (struct sockaddr*) inSai , sizeof(sockaddr) );
	if (ret < 0)
	{
		throw RIOException(EXCEPTIONTRACE + "Bind に失敗しました" + ErrorToMesage() );
	}

	IsConnect = true;
}

/**
 * Listen:					listen
 *
 * @param inBacklog			接続要求ログを保存する（キューイングする）最大数
 * @throws	RIOException	listen失敗	
 */
BigClass::Listen(int inBacklog ) throw(RIOException)
{
	ASSERT(Socket != INVALID_SOCKET);

	int ret = listen(Socket , inBacklog );
	if (ret < 0)
	{
		throw RIOException(EXCEPTIONTRACE + "Listen に失敗しました" + ErrorToMesage() );
	}
}

/**	
 * Accept:					accept
 *
 * @return RSocket*			接続されたクライアント
 * @throws	RIOException	accept失敗
 */
BigClass::Accept() throw(RIOException)
{
	ASSERT(Socket != INVALID_SOCKET);

	SOCKET  NewSock = accept(Socket , (struct sockaddr*) NULL , NULL);
	if (NewSock <= 0 )
	{
		throw RIOException(EXCEPTIONTRACE + "accept に失敗しました" + ErrorToMesage() );
	}
	//新規に作成して返す
	return new RSocket(NewSock);
}


/**
 * HoldTillReadyForRead:	読み込みができるようになるまで待機.
 *
 * @param	inTimeOutS		タイムアウトする秒数
 * @throws	RIOException	タイムアウト.
 */
BigClass::HoldTillReadyForRead(long inTimeOutS) throw(RIOException)
{
	timeval UseTimeVal;
	FD_SET	ReadFlg;
	//セレクトの戻り値
	int	SelectRet;
	int i;
	//短い時間でチェックします.
	for(i = 0 ; i < inTimeOutS ; i++)
	{
		//秒.
		UseTimeVal.tv_sec  = 5;
		//秒ms
		UseTimeVal.tv_usec = 0;
		FD_ZERO(&ReadFlg);
		FD_SET(Socket , &ReadFlg);

		SelectRet = select(2 , &ReadFlg, NULL , NULL , &UseTimeVal);
		//タイムアウトではなかったらループ離脱.
		if (SelectRet != 0) break;	
	}
	//タイムアウトです.
	if (i == inTimeOutS)
	{
		throw RIOException(EXCEPTIONTRACE + "タイムアウトが発生しました.");
	}

	if ( ! FD_ISSET(Socket , &ReadFlg) )
	{//ミス.
		throw RIOException(EXCEPTIONTRACE + "原因不明のエラーが発生しました" + ErrorToMesage() );
	}

}

/**
 * HoldTillReadyForWrite:		書き込みができるようになるまで待機.
 *
 * @param	inTimeOutS			タイムアウトする秒数
 * @throws	RIOException	タイムアウト.
 */
BigClass::HoldTillReadyForWrite(long inTimeOutS) throw(RIOException)
{
	timeval UseTimeVal;
	FD_SET	WriteFlg;

	//セレクトの戻り値
	int	SelectRet;	
	int i;
	//短い時間でチェックします.
	for(i = 0 ; i < inTimeOutS ; i++)
	{
		//秒.
		UseTimeVal.tv_sec  = 5;
		//秒ms
		UseTimeVal.tv_usec = 0;
		FD_ZERO(&WriteFlg);
		FD_SET(Socket , &WriteFlg);

		SelectRet = select(2 , NULL , &WriteFlg , NULL , &UseTimeVal);
		//タイムアウトではなかったらループ離脱.
		if (SelectRet != 0) break;	
	}
	//タイムアウトです.
	if (i == inTimeOutS)
	{
		throw RIOException(EXCEPTIONTRACE + "タイムアウトが発生しました.");
	}

	if ( ! FD_ISSET(Socket , &WriteFlg) )
	{//ミス.
		throw RIOException(EXCEPTIONTRACE + "原因不明のエラーが発生しました" + ErrorToMesage() );
	}
}

/**
 * ShutDown:	切断.
 *
 */
BigClass::ShutDown()
{
	if (Socket == INVALID_SOCKET) return ;
	if (!IsConnect)	return ;

BigClass::sends);

	//この時間になってもつないでいる場合は、即切る.
	DWORD TimeOutTime = IntTime() + 10; //10秒待つ.

	//保留中のすべてのデータを受け取る.
	int		Ret;
	char	Buffer[RESERVE_BUFFER_SIZE];
	while(1)
	{
		Ret = recv(Socket , Buffer , RESERVE_BUFFER_SIZE*sizeof(char) , 0 );
		//TRACE("Shutdown 保留中のデータ %d を受信しました\r\n",Ret);
		if ( Ret <= 0 || Ret == SOCKET_ERROR)	break;

		//タイムアウトチェック
		if ( TimeOutTime < IntTime() ) 
		{
			//TRACE("Shutdown タイムアウトが発生しました\r\n");
			break;
		}
	}
	//TRACE("Shutdown が呼ばれました3");
	//データをこれ以上受信しないことを相手に伝える.
BigClass::both);

	IsConnect = false;
}

/**
 * Close:	ソケットクローズ.
 *
 * @throws	RIOCannotCloseException		切断に失敗
 */
BigClass::Close() throw(RIOCannotCloseException)
{
	if(Socket == INVALID_SOCKET) return ;

	//切断する.
//	ShutDown();

	if( closesocket(Socket) )
	{
		throw RIOException(EXCEPTIONTRACE + "ソケットのクローズ時にエラーが発生しました" + ErrorToMesage() );
	}
	Socket = INVALID_SOCKET;

}

/**
 * Send:				送信.
 *
 * @param inBuffer		送信するバッファ
 * @param inBufferLen	送信するバッファのサイズ
 * @param inFlags		フラグ
 * @param inTimeoutS	タイムアウト秒数
 * @return int			送信したサイズ.
 * @throws	RIOException	タイムアウト.
 */
BigClass::Send( const char* inBuffer ,int inBufferLen , int inFlags ,int inTimeoutS ) throw(RIOException,RIOCannotWriteException)
{
	ASSERT(inBuffer != NULL);
	ASSERT(inBufferLen >= 0);
	if (this->Socket == INVALID_SOCKET) return 0;  

	//書けるようになるまで待つ.
	HoldTillReadyForWrite(inTimeoutS);
	//データ送信.
BigClass::send(Socket , inBuffer ,inBufferLen  ,inFlags  );
	//異常事態が起きたら、脱出.
	if ( ret < 0 )
	{
		throw RIOCannotWriteException(EXCEPTIONTRACE + "書き込み時にエラーが発生しました" + ErrorToMesage() );
	}

	return ret;
}
/**
 * Reserve:				受信.
 *
 * @param outBuffer		受信するバッファ
 * @param inBufferLen	受信するバッファのサイズ
 * @param inFlags		フラグ
 * @param inTimeoutS	タイムアウト秒数
 * @return int			受信したサイズ.
 * @throws	RIOException	タイムアウト.
 */
BigClass::Reserve( char* outBuffer ,int inBufferLen , int inFlags ,int inTimeoutS ) throw(RIOException,RIOCannotReadException)
{
	ASSERT(outBuffer != NULL);
	ASSERT(inBufferLen >= 0);
	if (this->Socket == INVALID_SOCKET) return 0;  

	//読めるようになるまで待つ.
	HoldTillReadyForRead(inTimeoutS);
	//データ送信.
BigClass::recv(Socket , outBuffer ,inBufferLen  ,inFlags  );
	if (ret < 0)
	{
		throw RIOCannotReadException(EXCEPTIONTRACE + "読み込み時にエラーが発生しました" + ErrorToMesage() );
	}

	return ret;
}

/**
 * IntTime:	タイムアウトに使う時間の提供.
 *
 * @return DWORD	UNIX時刻
 */
BigClass::IntTime()
{
	struct _timeb Time;
	_ftime(&Time);

	return Time.time;
}
/**
 * ErrorToMesage:	エラーメッセージを取得する.
 *
 * @return string	エラーメッセージ
 */
BigClass::ErrorToMesage()
{
	//http://kaf.tri6.net/code/wsock_r.html
	switch(WSAGetLastError())
	{
	case WSAEINTR: return string(" 関数呼び出しが中断された。\nWinSock 1.1 のブロッキング関数呼び出しが、WSACancelBlockingCall() によって中断された。");
	case WSAEBADF: return string("無効なファイルハンドル。\nソケット関数に渡されたファイルハンドル（ソケットハンドル）が不正である。（WSAENOTSOCKと同義で用いられる）");
	case WSAEACCES: return string("アクセスが拒否された。\nconnect()：ブロードキャストアドレスで接続しようとしたソケットの SO_BROADCASTオプション が有効になっていない。\nsendto()：ブロードキャストアドレスに送信しようとしたソケットの SO_BROADCASTオプションが有効になっていない。\naccept()：受付しようとした接続要求がすでにタイムアウトになっている、もしくは取り消されている。");
	case WSAEFAULT: return string("無効なバッファアドレス\n関数に渡されたバッファを指すポインタが無効なアドレス空間を指している。またはバッファのサイズが小さすぎる。");
	case WSAEINVAL: return string("無効な引数が渡された。\nlisten()を呼び出さずにaccept()を呼び出した。\nバインド済みのソケットに対してbind()しようとした。\nlisten()で待機中のソケットでconnect()しようとした。\n関数に渡されたパラメータに無効な値が含まれている。");
	case WSAEMFILE: return string("使用中のソケットの数が多すぎる。\n同時に利用できるソケット数の最大に達しており、新たにソケットを作成できない。");
	case WSAEWOULDBLOCK: return string("操作はブロッキングされる。\nノンブロッキングモードでソケット関数が呼び出されため、関数は即座にリターンしたが要求された操作は完了していない。");
	case WSAEINPROGRESS: return string("すでにブロッキング手続きが実行されている。\nブロッキング関数が実行中であるか、サービスプロバイダがコールバック関数を処理中である。WinSockでは１つのプロセスで同時に複数のブロッキング操作をすることはできないため、前回呼び出した操作が完全に終了するまで次の操作を開始することはできない。");
	case WSAEALREADY: return string("要求された操作は既に実行中、または実行済み。\nキャンセルしようとした非同期操作が既にキャンセルされている。\nconnect()を呼び出したが、既に前回の呼び出しによって接続処理中である。");
	case WSAENOTSOCK: return string("指定されたソケットが無効である。\nソケットハンドルとして無効な値がソケット関数に渡された。");
	case WSAEMSGSIZE: return string("メッセージサイズが大きすぎる。\n送信、または受信しようとしたメッセージが、基盤となるプロトコルのサポートしている最大メッセージサイズを超えている。ioctlsocket()でバッファサイズを増やすことで回避可能なこともある。");
	case WSAEPROTOTYPE: return string("ソケットは要求されたプロトコルに適合していない。\nsocket()を呼び出すときに指定したプロトコルタイプがソケットタイプと適合していない。メッセージ型プロトコルでストリームソケットを作成しようとした場合など。");
	case WSAENOPROTOOPT: return string("不正なプロトコルオプション。\n指定したソケットオプションまたはioctlsocket()での操作が、そのプロトコルではサポートされてない。\nストリームソケットに SO_BROADCAST を指定しようとした。");
	case WSAEPROTONOSUPPORT: return string("プロトコルがサポートされていない。\nサポートされていないプロトコルを指定した、またはプロトコルのサポートしていない操作を実行しようとした。");
	case WSAESOCKTNOSUPPORT: return string("指定されたソケットタイプはサポートされていない。");
	case WSAEOPNOTSUPP: return string("要求された操作はサポートされていない。\nバンド外データを送信/受信しようとしたソケットでそれがサポートされていない。\n非接続型(UDPなど)ソケットでaccept()を呼び出した。");
	case WSAEPFNOSUPPORT: return string("プロトコルファミリがサポートされていない。");
	case WSAEAFNOSUPPORT: return string("アドレスファミリがサポートされていない。");
	case WSAEADDRINUSE: return string("アドレスは既に使用中である。\nbind()しようとしたアドレスは、既にほかのソケットで使われている。同じローカルアドレスを複数のソケットで使うためには、SO_REUSEADDRソケットオプションをTRUEにする必要がある。");
	case WSAEADDRNOTAVAIL: return string("無効なネットワークアドレス。\nソケット関数に渡されたネットワークアドレスに無効な部分がある。");
	case WSAENETDOWN: return string("ネットワークがダウンしている。\nネットワークシステムが何らかの障害を起こし、機能停止しているため要求された操作が実行できない。");
	case WSAENETUNREACH: return string("指定されたネットワークホストに到達できない。\nWSAEHOSTUNREACHと同義で使われている。");
	case WSAENETRESET: return string("ネットワーク接続が破棄された。\nキープアライブを行っている接続で、何らかの障害のためタイムアウトが検出され接続が閉じられた。");
	case WSAECONNABORTED: return string("ネットワーク接続が破棄された。");
	case WSAECONNRESET: return string("ネットワーク接続が相手によって破棄された。");
	case WSAENOBUFS: return string("バッファが不足している。\nメモリ不足のためWinSockが操作に必要なバッファを確保することができない。または、バッファを必要とする関数呼び出しで、小さすぎるバッファが渡された。");
	case WSAEISCONN: return string("ソケットは既に接続されている。\n接続中のソケットに対してconnect()、listen()、bind()等の操作を行おうとした。\n接続中のソケットでsendto()を実行しようとした。");
	case WSAENOTCONN: return string("ソケットは接続されていない。\n接続されていないソケットでsend()、getpeername()等の接続されたソケットを必要とする操作を実行しようとした。");
	case WSAESHUTDOWN: return string("ソケットはシャットダウンされている。\n既にシャットダウンされて送信/受信が停止されているソケットで、送信または受信の操作を実行しようとした。");
	case WSAETOOMANYREFS: return string("参照の数が多すぎる。");
	case WSAETIMEDOUT: return string("接続要求がタイムアウトした。\nconnect()を呼び出して接続を試みたが、（相手の応答がない等で）処理がタイムアウトになり接続要求がキャンセルされた。");
	case WSAECONNREFUSED: return string("接続が拒否された。");
	case WSAELOOP: return string("ループ。");
	case WSAENAMETOOLONG: return string("名前が長すぎる。");
	case WSAEHOSTDOWN: return string("ホストがダウンしている。\nWSAETIMEDOUTと同義。");
	case WSAEHOSTUNREACH: return string("ホストへの経路がない。\nネットワークの構造上到達できないホストに対して操作を実行しようとした。またはアドレスが不正である。");
	case WSAENOTEMPTY: return string("ディレクトリが空ではない。");
	case WSAEPROCLIM: return string("プロセスの数が多すぎる。\nWSAStartup()：既にWinSockが管理できる最大プロセス数に達しており処理が実行できない。");
	case WSAEUSERS: return string("ユーザーの数が多すぎる。");
	case WSAEDQUOT: return string("ディスククォータ。");
	case WSAESTALE: return string("実行しようとした操作は廃止されている。");
	case WSAEREMOTE: return string("リモート。");
	case WSASYSNOTREADY: return string("ネットワークサブシステムが利用できない。\nWSAStartup()：ネットワークサブシステムが利用できない、または正しくセットアップされていないため機能していない。");
	case WSAVERNOTSUPPORTED: return string("Winsock.dllのバージョンが範囲外である。\nWSAStartup()：要求したWinSockバージョンは、現在の実装ではサポートされていない。");
	case WSANOTINITIALISED: return string("WinSockシステムが初期化されていない。\nWinSock関数を実行しようとしたが、WSAStartup()が正常に実行されていないため機能しない。");
	case WSAEDISCON: return string("シャットダウン処理中。\n接続が相手の処理によって切断されようとしている。");
	case WSAENOMORE: return string("データはこれ以上存在しない。\nWSA_E_NO_MOREと同義。");
	case WSAECANCELLED: return string("操作は取り消された。\nWSA_E_CANCELLEDと同義。");
	case WSAEINVALIDPROCTABLE: return string("サービスプロバイダの関数テーブルが無効。");
	case WSAEINVALIDPROVIDER: return string("サービスプロバイダが無効。");
	case WSAEPROVIDERFAILEDINIT: return string("サービスプロバイダの初期化に失敗した。");
	case WSASYSCALLFAILURE: return string("システムコールに失敗した。\n決して失敗しないはずのシステムコールが何らかの理由により失敗した。");
	case WSASERVICE_NOT_FOUND: return string("サービスが見つからない。\n要求されたサービスが標準的なサービスでなく、指定した名前空間からサービスを見つけることができない。");
	case WSATYPE_NOT_FOUND: return string("タイプが見つからない。");
	case WSA_E_NO_MORE: return string("データはこれ以上存在しない。\nWSALookupServiceNext()：情報はこれ以上存在しない。");
	case WSA_E_CANCELLED: return string("検索がキャンセルされた。\nWSALookupServiceNext()：サービスの検索途中に、WSALookupServiceEnd()によって処理がキャンセルされた。");
	case WSAEREFUSED: return string("操作は拒否された。");
	case WSAHOST_NOT_FOUND: return string("ホストが見つからない。\nDNSなどの名前解決サービスが指定されたホストを見つけられなかった。プロトコルやサービスのクエリー操作においても返される。");
	case WSATRY_AGAIN: return string("指定されたホストが見つからない、またはサービスの異常。");
	case WSANO_RECOVERY: return string("回復不能なエラーが発生した。\nデータベース検索の場合は、名前解決サービスが使用できないことを意味する。");
	case WSANO_DATA: return string("要求されたタイプのデータレコードが見つからない。");
	}
	return "";
}

//受信バッファの最大値.
const int RESERVE_BUFFER_SIZE	= 50000;

//////////////////////////////////////////////////////////////////////
// 構築/消滅
//////////////////////////////////////////////////////////////////////

/**
 * RSocketForWinSock2:		コンストラクタ
 *				とりあえず初期化します。
 */
BigClass::RSocketForWinSock2()
{
	Socket = INVALID_SOCKET;
	IsConnect = false;
}
/**
 * RSocketForWinSock2:		コンストラクタ
 *				指定されたソケットで初期化します。
 *
 * @param inNewSocket	既につながっているソケット.
 * @return  
 */
BigClass::RSocketForWinSock2(SOCKET inNewSocket)
{
	Socket = inNewSocket;
	IsConnect = true;
}


/**
 * ~RSocketForWinSock2:	デストラクタ
 *				
 */
BigClass::~RSocketForWinSock2()
{
}

/**
 * Open:			ソケットを作成する.
 *
 * @param type		ソケットの種類
 *						SOCK_STREAM : TCPで使用する
 *						SOCK_DGRAM : UDPで使用する
 * @param protocol	使用するプロトコル
 * @throws			RIOCannotOpenException		開けなかったとき
 */
BigClass::Open( int type, int protocol ) throw(RIOCannotOpenException)
{
	Socket = socket(AF_INET,type,protocol);
	if (Socket == INVALID_SOCKET || Socket == NULL) throw RIOCannotOpenException(EXCEPTIONTRACE + "ソケットが開けませんでした" + ErrorToMesage() );

	// Winsockで非ブロッキングのソケット通信を行うように設定する.
	unsigned long argp = 1;   // 非ブロッキングに設定 
	if ( ioctlsocket( Socket , FIONBIO , &argp ) )
	{
		throw RIOException(EXCEPTIONTRACE + "非ブロッキングモードへ移動できません" + ErrorToMesage() );
	}

}

/**
 * Connect:				接続(簡易版)
 *
 * @param inHost		ホスト名
 * @param inPort		ポート
 * @throws				RIOException			接続できなかったとき
 */
BigClass::Connect(string inHost , int inPort)	throw(RIOException)
{
	ASSERT(Socket != INVALID_SOCKET);

	//すでに接続しています。
	if (IsConnect)	return ;

	LPHOSTENT	HostEnt;
	SOCKADDR_IN	sai = {0};
	in_addr		iadr;

	iadr.s_addr=inet_addr( inHost.c_str() );
	if(iadr.s_addr==INADDR_NONE)
	{
		HostEnt=gethostbyname(inHost.c_str() );
		if(!HostEnt)
		{
			throw RIOException(EXCEPTIONTRACE + "ホスト名を解決できませんでした" + ErrorToMesage() );
		}
		sai.sin_addr=*((LPIN_ADDR)*HostEnt->h_addr_list);
	}
	else
	{
		sai.sin_addr = iadr;
	}

	sai.sin_port=htons((unsigned short)inPort); // 変換を忘れずに!
	sai.sin_family=AF_INET;

	this->Connect(&sai) ;
}

/**
 * Connect:			接続
 *
 * @param inSai		接続情報
 * @throws			RIOException			接続できなかったとき
 */
BigClass::Connect(const SOCKADDR_IN * inSai) throw(RIOException)
{
	ASSERT(Socket != INVALID_SOCKET);

	//すでに接続しています。
	if (IsConnect)	return ;

	// Winsockで非ブロッキングのソケット通信を行うように設定する.
	unsigned long argp = 1;   // 非ブロッキングに設定 
	if ( ioctlsocket( Socket , FIONBIO , &argp ) )
	{
		throw RIOException(EXCEPTIONTRACE + "非ブロッキングモードへ移動できません" + ErrorToMesage() );
	}

	//接続を試みる.
	int ConnectRet = connect(Socket,(LPSOCKADDR)inSai,sizeof(SOCKADDR_IN));
	if( ! (ConnectRet == 0 || ConnectRet == -1) ) //成功(0) か、まだ終わっていない(-1)でないならば...
	{	//接続に失敗しました.
		string error = ErrorToMesage();	//ブロックモードに戻すときにエラーが上書きされないように先に取得.

		argp = 0;   // ブロッキングに設定 
		ioctlsocket( Socket , FIONBIO , &argp );

		throw RIOException(EXCEPTIONTRACE + "接続に失敗しました" + error );
	}

	try
	{
		//書き込みができるようになるまで待機.
		//タイムアウトが発生すると RIOException が起きます。
		HoldTillReadyForWrite( 60 ) ;
	}
	catch(...)
	{
		argp = 0;   // ブロッキングに設定 
		ioctlsocket( Socket , FIONBIO , &argp );
		throw ;
	}

	argp = 0;   // ブロッキングに設定 
	if ( ioctlsocket( Socket , FIONBIO , &argp ) )
	{
		throw RIOException(EXCEPTIONTRACE + "ブロッキングモードへ移動できません" + ErrorToMesage() );
	}

	IsConnect = true;
}

/**
 * Bind:			bind(簡易版)
 *
 * @param inPort	bindするポート
 * @throws			RIOException		bind失敗
 */
BigClass::Bind(int inPort) throw(RIOException)
{
	ASSERT(Socket != INVALID_SOCKET);

	//すでにbindしています。
	if (IsConnect)	return ;

	int	Opt = 1;
	setsockopt(Socket , SOL_SOCKET, SO_REUSEADDR, (const char*)&Opt , sizeof(int) );

	SOCKADDR_IN	sai = {0};
	sai.sin_family			= AF_INET;
	sai.sin_addr.s_addr	= htonl(INADDR_ANY);
	sai.sin_port			= htons((unsigned short)inPort);

	this->Bind( &sai );
}

/**
 * Bind:			bind
 *
 * @param inSai		bind情報
 * @throws			RIOException		bind失敗
 */
BigClass::Bind(const SOCKADDR_IN * inSai) throw(RIOException)
{
	//すでにbindしています。
	if (IsConnect)	return ;

	int ret = bind(Socket , (struct sockaddr*) inSai , sizeof(sockaddr) );
	if (ret < 0)
	{
		throw RIOException(EXCEPTIONTRACE + "Bind に失敗しました" + ErrorToMesage() );
	}

	IsConnect = true;
}

/**
 * Listen:					listen
 *
 * @param inBacklog			接続要求ログを保存する（キューイングする）最大数
 * @throws	RIOException	listen失敗	
 */
BigClass::Listen(int inBacklog ) throw(RIOException)
{
	ASSERT(Socket != INVALID_SOCKET);

	int ret = listen(Socket , inBacklog );
	if (ret < 0)
	{
		throw RIOException(EXCEPTIONTRACE + "Listen に失敗しました" + ErrorToMesage() );
	}
}

/**	
 * Accept:					accept
 *
 * @throws	RIOException	accept失敗
 */
BigClass::Accept(SOCKET inAcceptSocket ,
								PVOID lpOutputBuffer, DWORD * outReadByte,OVERLAPPED * outOverlapped) throw(RIOException)
{
	ASSERT(Socket != INVALID_SOCKET);

    if (!AcceptEx(Socket, inAcceptSocket,
                  lpOutputBuffer,
                  0,
                  PADDED_ADDR_SIZE, 
                  PADDED_ADDR_SIZE,
                  outReadByte,
                  outOverlapped))
	{
		const DWORD error = WSAGetLastError();
		if (error == ERROR_IO_PENDING) return ;

		WSASetLastError(error);
		throw RIOException(EXCEPTIONTRACE + "accept に失敗しました" + ErrorToMesage() );
	}

}

/**
 * HoldTillReadyForWrite:		書き込みができるようになるまで待機.
 *
 * @param	inTimeOutS			タイムアウトする秒数
 * @throws	RIOException	タイムアウト.
 */
BigClass::HoldTillReadyForWrite(long inTimeOutS) throw(RIOException)
{
	timeval UseTimeVal;
	FD_SET	WriteFlg;

	//セレクトの戻り値
	int	SelectRet;	
	int i;
	//短い時間でチェックします.
	for(i = 0 ; i < inTimeOutS ; i++)
	{
		//秒.
		UseTimeVal.tv_sec  = 1;
		//秒ms
		UseTimeVal.tv_usec = 0;
		FD_ZERO(&WriteFlg);
		FD_SET(Socket , &WriteFlg);

		SelectRet = select(2 , NULL , &WriteFlg , NULL , &UseTimeVal);
		//タイムアウトではなかったらループ離脱.
		if (SelectRet != 0) break;	
	}
	//タイムアウトです.
	if (i == inTimeOutS)
	{
		throw RIOException(EXCEPTIONTRACE + "タイムアウトが発生しました.");
	}

	if ( ! FD_ISSET(Socket , &WriteFlg) )
	{//ミス.
		throw RIOException(EXCEPTIONTRACE + "原因不明のエラーが発生しました" + ErrorToMesage() );
	}
}


#include <./Lim3D/rti_Lim3DPolygon.h>
#include <./Lim3D/rti_Lim3DMaster.h>
#include <./Base/rti_vector.h>

#define _LIM3D_MAX_VEC 4		//最大点数.

/*****************/
//ユーザーのための高レベルメソッド.
/*****************/
//絵画
BigClass::Draw()
{
	PolygonDataEx*	UsingData = m_LinkData.GetStart();
	PolygonDataEx*	it = UsingData;
	PolygonDataEx*	end= m_LinkData.GetEnd();
	XYZFixed		Avg = {0};					//ポリゴンの平均値(重心)
	Fixed			Eye_Avg_Z = 0;				//視点座標のポリゴンの中心のZ座標.

	for( ; it != end ; it++ )
	{
		//平均値を求めます(そのための足し算).
		VectorAdd( &Avg , &Avg , & (it->LinkVecPointer->World) );
		//視点平均値を求めます(そのための足し算).
		Eye_Avg_Z +=  it->LinkVecPointer->Eye.z ;
	}
	//裏面だったら即没.
	if (IsBackstairs(UsingData) == true)	return ;

	//平均値を算出.
	switch( m_LinkData.GetCount() )
	{
	case 4:
		VectorSar(&m_AvgPoint , &Avg , 2);
		m_Eye_Avg_Z = Eye_Avg_Z / 4;
		break;
	case 3:
		VectorSar(&m_AvgPoint , &Avg , 1);
		VectorSub(&m_AvgPoint , &m_AvgPoint ,&Avg );
		m_Eye_Avg_Z = (Eye_Avg_Z / 2) - Eye_Avg_Z;
	}
	//法線ベクトルの算出(World / 単位)
	ClasHousenVector(UsingData);

	//ポリゴンを ZSort 対象に追加.
BigClass::AddZSortPolygon(this);
}

//実際絵画部分
BigClass::TrueDraw()
{
	PolygonDataEx*	UsingData = m_LinkData.GetStart();
	DrawUse	du[ _LIM3D_MAX_VEC+1 ];	//+1はクリッピングのために...
	DrawUse	*dup = du;				//効率処理優先.

	//クリッピングして、絵画します.
	int i;
	int UseVec = m_PolygonClipping.DoClipping( du , UsingData , m_LinkData.GetCount() );
	if (UseVec <= 2) return;

	XYZFixed * Pos;
	//透視投影
	for( i=0 ; i < UseVec ; i++ , dup++ )
	{
		Pos = &(dup->Pos);
		dup->Display.x = IF(LIM3D_USING_AREAW/2) + (FixedDiv(Pos->x , Pos->z) << 8);
		dup->Display.y = IF(LIM3D_USING_AREAH/2) - (FixedDiv(Pos->y , Pos->z) << 8);
		dup->Display.z = Pos->z;
	}
	//DoClipping は絵画する頂点を返して、 du をにデータをセットします.
	//DoDraw は、その du を受け取って、絵画します.
	m_PolygonDraw.DoDraw(this , du , UseVec);
}


//つながり情報の登録.
BigClass::LinkEntry(PolygonData *_c , int Many ,
										bool SizeNotChange , bool IsSet)
{
	//わけのわからない指令は無視.
	if (Many <= 0) return false;

	//各種戻り値.
	bool theRet;
	//頂点データへのアクセス経路の確定.
	VecWorldEye*	VecData = (GetParenceModel()->GetVecCaretaker())->GetStart();
	//うーん、配列確保面倒です.
	PolygonDataEx* thePDE = new PolygonDataEx[Many];
	//念のため確保失敗をチェック.
	if (thePDE == NULL) return false;

	for(int theI = 0 ; theI < Many ; theI ++)
	{
		//頂点のデータを リンク処理より ポインタ処理に置き換えます.
		//これにより、実行時にポインタに変換するのに比べて効率があがる
		//なお、危険度も上昇しますね (汗)
		thePDE[theI].LinkVecPointer = &VecData[ _c[theI].Link] ;
		//テクスチャーはそのまま.
		thePDE[theI].Texture        = _c[theI].Texture;
	}
	//登録.
	if (IsSet)
	{
		theRet =  m_LinkData.Set(thePDE,Many,SizeNotChange);
	}
	else
	{
		theRet =  m_LinkData.Add(thePDE,Many,SizeNotChange);
	}
	//ちゃんと削除しましょー.
	delete [] thePDE;
	//結果を返します.
	return theRet;
}

//つながり情報の登録.
BigClass::LinkEntry(PolygonDataCoexist *_c , int Many ,
										bool SizeNotChange , bool IsSet)
{
	//わけのわからない指令は無視.
	if (Many <= 0) return false;

	//頂点グループの先頭.
	VecWorldEye*	VecData;
	//各種戻り値.
	bool theRet;
	//親モデル.
	TLim3DModel* thePareceModel = GetParenceModel();
	//うーん、配列確保面倒です.
	PolygonDataEx* thePDE = new PolygonDataEx[Many];
	//念のため確保失敗をチェック.
	if (thePDE == NULL) return false;

	for(int theI = 0 ; theI < Many ; theI ++)
	{
		//このポリゴンが所属しているモデル以外からの関連付けかどうか検査.
		if ( (_c->Model == NULL || _c->Model == thePareceModel) )
		{//現在所属しているところからの関連付けです.
			VecData = (thePareceModel->GetVecCaretaker())->GetStart();
		}
		else
		{//現在属していないところからの関連付けです.
			TLim3DModel*	theModel = ((TLim3DModel*)(_c[theI].Model));
			//属していない関連付けは、自分の先祖にあたる関係しか許さない.
			if( !thePareceModel->IsForefathers( theModel ) )
			{//エラー
				return false;
			}
			VecData = (theModel->GetVecCaretaker())->GetStart();
		}

		//頂点のデータを リンク処理より ポインタ処理に置き換えます.
		//これにより、実行時にポインタに変換するのに比べて効率があがる
		//なお、危険度も上昇しますね (汗)
		thePDE[theI].LinkVecPointer = &VecData[ _c[theI].Link] ;
		//テクスチャーはそのまま.
		thePDE[theI].Texture        = _c[theI].Texture;
	}
	//登録.
	if (IsSet)
	{
		theRet =  m_LinkData.Set(thePDE,Many,SizeNotChange);
	}
	else
	{
		theRet =  m_LinkData.Add(thePDE,Many,SizeNotChange);
	}
	//ちゃんと削除しましょー.
	delete [] thePDE;
	//結果を返します.
	return theRet;
}

//つながり情報セット.
BigClass::SetLink(PolygonData *_c , int Many , bool SizeNotChange)
{
	return LinkEntry(_c , Many , SizeNotChange ,  true);
}

//つながり情報セット.
BigClass::AddLink(PolygonData *_c , int Many , bool SizeNotChange)
{
	return LinkEntry(_c , Many , SizeNotChange ,  false);
}
//つながり情報セット.
BigClass::SetLink(PolygonDataCoexist *_c , int Many , bool SizeNotChange)
{
	return LinkEntry(_c , Many , SizeNotChange ,  true);
}

//つながり情報セット.
BigClass::AddLink(PolygonDataCoexist *_c , int Many , bool SizeNotChange)
{
	return LinkEntry(_c , Many , SizeNotChange ,  false);
}

//つながりクリア
BigClass::ClearLink()
{
	m_LinkData.Clear();
}

/*****************/
//ユーザーのための低レベルメソッド.
/*****************/
//つながりデータをベタで取得.
BigClass::GetLinkData()
{
	return &m_LinkData;
}


//法線ベクトルの算出.
BigClass::ClasHousenVector(PolygonDataEx* inUsing)
{
	/*
	*
	* 1                       0
	*  C----------------------A
	*   \
	*    \
	*     \
	*      \
	*       \
	*        \
	*         B 2
	*/
	XYZFixed* const Va = & (inUsing[2].LinkVecPointer->World);
	XYZFixed* const Vb = & (inUsing[0].LinkVecPointer->World);
	XYZFixed* const Vc = & (inUsing[1].LinkVecPointer->World);

	XYZFixed    A,B;    

	A.x = (Va->x - Vc->x);    	A.y = (Va->y - Vc->y);	    A.z = (Va->z - Vc->z);
	B.x = (Vb->x - Vc->x);	    B.y = (Vb->y - Vc->y);    	B.z = (Vb->z - Vc->z);
	//正規化.
	//Normalize(&A);	Normalize(&B);
	//法線ベクトルの算出.
	CrossProduct( &m_HousenVector,&A,&B );
	Normalize( &m_HousenVector );
}

//裏面判定. 
BigClass::IsBackstairs(PolygonDataEx* inUsing)
{
	//return false;
	/*
	*
	* 1                       0
	*  C----------------------A
	*   \
	*    \
	*     \
	*      \
	*       \
	*        \
	*         B 2
	*/
	//視点座標でやっていることに注意せよ.
	XYZFixed* const Va = & (inUsing[2].LinkVecPointer->Eye);
	XYZFixed* const Vb = & (inUsing[0].LinkVecPointer->Eye);
	XYZFixed* const Vc = & (inUsing[1].LinkVecPointer->Eye);
	/*
	//外積の Z 成分だけを算出する.
	Fixed theZ = FixedMul( (Va->x - Vc->x) , (Vb->y - Vc->y) ) - 
						FixedMul( (Va->y - Vc->y) , (Vb->x - Vc->x) );
	// 0よりも小さい場合は裏面.
	if (theZ > 0) return true;
	//表面.
	return false;
	*/
	XYZFixed    A,B;    

	A.x = (Va->x - Vc->x);    	A.y = (Va->y - Vc->y);	    A.z = (Va->z - Vc->z);
	B.x = (Vb->x - Vc->x);	    B.y = (Vb->y - Vc->y);    	B.z = (Vb->z - Vc->z);
	//正規化.
	//Normalize(&A);	Normalize(&B);
	//法線ベクトルの算出.
	XYZFixed EyeHousen;
	CrossProduct( &EyeHousen,&A,&B );
	Normalize( &EyeHousen );

	if (EyeHousen.z > Float2Fixed(0.5) ) return true;

	return false;
}

//テクスチャーの再マッピング(AUTO).
BigClass::ReMapTexture()
{
	TLim3DMaterial*		theMaterial	;		//マテリアル取得.
	theMaterial = GetMaterial() ;
	BMD theTexture = theMaterial->GetTexture();

	//念のためテクスチャーがちゃんとはられているかチェック.
	if (theTexture==NULL)	return false;
	return ReMapTexture( 0 ,0 ,
				theTexture->w , 0   ,
				theTexture->w , theTexture->h ,
				0 ,theTexture->h						);
}

//テクスチャーの再マッピング.
BigClass::ReMapTexture(int X1 ,int Y1,
						int X2,int Y2, int X3,int Y3, int X4,int Y4)
{
	int				Count     = m_LinkData.GetCount();
	PolygonDataEx*	UsingData = m_LinkData.GetStart();

	if ( Count <= 0) return false;

	UsingData[0].Texture.x = X1;
	UsingData[0].Texture.y = Y1;
	if ( Count <= 1) return true;

	UsingData[1].Texture.x = X2;
	UsingData[1].Texture.y = Y2;
	if ( Count <= 2) return true;

	UsingData[2].Texture.x = X3;
	UsingData[2].Texture.y = Y3;
	if ( Count <= 3) return true;
	
	UsingData[3].Texture.x = X4;
	UsingData[3].Texture.y = Y4;
	if ( Count <= 4) return true;

	//頂点が多すぎる.
	return false;
}


BigClass::GetParenceModel()
{
	return ( (TLim3DPolygonCaretaker*)m_Parence)->GetParenceModel(); 
}

/*****************************************************************/
//ジョイスティック情報を更新
/*****************************************************************/
BigClass::JoyStickRef()
{
	int x,y;

	//ボタンと方向の前回の値を保存
	JoyButtonDownOld = JoyInfo.dwButtons; //ボタン
	JoyKeyDownOld = JoyKeyDown;           //方向

	MMRESULT MMret = joyGetPosEx(PadId,&JoyInfo);
	x = JoyInfo.dwXpos;
	y = JoyInfo.dwYpos;

	//方向(privateメンバ)
	JoyKeyDown = 0;      
	if (x < JOY_POS_MIN) JoyKeyDown |= JOY_POS_LEFT; //右
	if (x > JOY_POS_MAX) JoyKeyDown |= JOY_POS_RIGHT; //左
	if (y < JOY_POS_MIN) JoyKeyDown |= JOY_POS_TOP; //上
	if (y > JOY_POS_MAX) JoyKeyDown |= JOY_POS_DOWN; //下

}


#define COMPLE_MAX_BUFFER_SIZE 256
#define COMPLE_ERROR_OUT(INPORMATION)    (MsgError3("CompleError File %s (%dLines)\n %s",CompleFilename,FileLen,INPORMATION))

/***********************************************************/
//そのファイルをコンパイルしてデータを格納
/***********************************************************/
BigClass::Comple(char *filename,ACTION_VECTOR *Ac,USE_STRING *Us)
{
    FILE *fp;
    char buf[COMPLE_MAX_BUFFER_SIZE];
    //予約語.
    char *CL[] =
    {
        "#*",           //コメント  工事現場で使うのは、セメント ... (ﾂﾏﾗｰ)
        "#DEFINE",      //定義
        "#CALS",        //計算
        "#IF",          //IF
        "#ELSE",        //ELSE
        "#ENDIF",       //ENDIF
        "#WHILE",       //WHILE
        "#ENDWHILE",    //ENDWHILE
        "#SWITCH",      //SWITCH
        "#ENDSWITCH",   //ENDSWITCH
        "#CASE",        //CASE
        "#BREAK",       //BREAK
        "#END",         //END
        NULL,
    };
    TCommandList TCL;   //検索エンジン (^^;

    char *next_str;     //予約語の次の文字列.
    //予約語を検索対象に承認する.
    TCL.set(CL);
    //文字列をマッピングするところ.
    UseString = Us;
    //ファイル名をいただいておく.
    CompleFilename = filename;
    //ファイルの行数を初期化
    FileLen = 0;

    fp = fopen(filename,"rb");
    if (!fp)
    {
BigClass::Comple",filename);
        return false;
    }
    try
    {
        while (! feof(fp) )
        {
            FileLen++;  //ファイル行数をカウントします.
            fgets(buf,COMPLE_MAX_BUFFER_SIZE,fp);
            next_str = buf;
            switch (TCL.search(buf,&next_str) )
            {
            case 0: //コメント
                break;
            case 1: //定義.
                if ( !CompleDefine(next_str,Ac) ) throw 0;
                break;
            case 2: //計算
                if ( !AnalysisString(next_str) )  throw 0;//その文字列を解析する
                break;
            case 3: //IF
                if ( !AnalysisString(next_str) )  throw 0;//その文字列を解析する
                Comple_Ana_Stack.push( MAction->size() );   //その IF のあった場所をスタックに登録.
                NewCommand(E_IF);   //分岐命令発効.
                break;
            case 4: //ELSE
                if ( !CompleElse(next_str) ) throw 0;
                break;
            case 5://ENDIF
                //スタックより、先の if , else の位置を取得.
                if ( !CompleEndIf(next_str) ) throw 0;
                break;
            case 6://WHILE
                if (!AnalysisString(next_str) )  throw 0;//その文字列を解析する
                Comple_Ana_Stack.push( MAction->size() );   //その WHILE のあった場所をスタックに登録.
                NewCommand(E_IF);   //分岐命令発効.
                break;
            case 7://ENDWHILE
                if ( !CompleEndWhile(next_str) ) throw 0;
                break;
            case 8://SWITCH
                break;
            case 9://ENDSWITCH
                break;
            case 10://CASE
                break;
            case 11://BREAK
                if ( !CompleBreak(next_str) ) throw 0;
                break;
            case 12://END
                NewCommand(E_HAL);   //END 終了命令
                break;
            default:    //ユーザ定義文 ?
                if ( !CompleUserFunktion(buf)) throw 0;
                break;
            }
        }
    }
    catch(...)
    {   //途中で異常発生!!
        fclose(fp);
        return false;
    }

    fclose(fp);

	//最適化.
	Saitekika(Ac);

    return true;
}

/***********************************************************/
//#DEFINE文の解釈.
/***********************************************************/
BigClass::CompleDefine(char *next_str,ACTION_VECTOR *Ac)
{
    int Def;
    //#DEFINE の値の取得.
    sscanf(next_str,"%d",&Def);
    if (Def >= ACTION_MAX) 
    {
        COMPLE_ERROR_OUT("#DEFINE の限界を超えた定義でげす.");
        return false;
    }
    //今回コンパイルしていく場所を示す. MAction は、private メンバ
    MAction = & Ac[Def];
    return true;
}

/***********************************************************/
//#ELSE文の解釈.
/***********************************************************/
BigClass::CompleElse(char *next_str)
{
    //スタックより、先の if の位置を取得.
    int w = Comple_Ana_Stack.top(); Comple_Ana_Stack.pop();
    //念のため確認.
    if ( (*MAction)[w].Nim != E_IF)
    {
        COMPLE_ERROR_OUT("#ELSE と #IF が対応してまへん.");
        return false;
    }

    //不成立の時は、自分の次の命令に.
    (*MAction)[w].O1 = MAction->size() + 1;
    Comple_Ana_Stack.push( MAction->size() );   //その ELSE があった位置を記録
    NewCommand(E_JMP);   //ELSE の時の分岐命令.

    return true;
}

/***********************************************************/
//#ENDIF文の解釈.
/***********************************************************/
BigClass::CompleEndIf(char *next_str)
{
    //スタックより、先の if , else の位置を取得.
    int w = Comple_Ana_Stack.top(); Comple_Ana_Stack.pop();
    //念のため確認.
    if (! ((*MAction)[w].Nim == E_IF || (*MAction)[w].Nim == E_JMP) )
    {
        COMPLE_ERROR_OUT("#ENDIF が いきなり呼ばれて出てきてズドドドーンです.");
        return false;
    }
    //不成立の時は、自分の次の命令に.
    (*MAction)[w].O1 = MAction->size() ;
    return true;
}

/***********************************************************/
//#ENDIF文の解釈.
/***********************************************************/
BigClass::CompleEndWhile(char *next_str)
{
    //スタックより、先の while の位置を取得.
    int w = Comple_Ana_Stack.top(); Comple_Ana_Stack.pop();
    //BREAK の 念のため確認.
    if ((*MAction)[w].Nim == E_JMP)
    {   //BREAK!
        (*MAction)[w].O1 = MAction->size() ;
        //これは、 WHILE
        w = Comple_Ana_Stack.top(); Comple_Ana_Stack.pop();
    }
    //念のため確認.
    if ((*MAction)[w].Nim == E_IF)
    {   //不成立の時は、自分の次の命令に.
        (*MAction)[w].O1 = MAction->size() + 1;
        NewCommand(E_JMP,w);   //ENDWHILE の時に WHILE までジャンプ
    }
    else
    {
        COMPLE_ERROR_OUT("#ENDWHILE が 不正に出現しました.");
        return false;
    }
    return true;
}

/***********************************************************/
//#BREAK文の解釈.
/***********************************************************/
BigClass::CompleBreak(char *next_str)
{
    //スタックより、先の while の位置を取得.
    int w = Comple_Ana_Stack.top(); //取得するだけってことに注意.
    //念のため確認.
    if ((*MAction)[w].Nim == E_IF)
    {
        Comple_Ana_Stack.push( MAction->size() );   //その BREAK のあった場所をスタックに登録.
        NewCommand(E_JMP);   //BREAK の時の分岐命令.
    }
    else
    {
        COMPLE_ERROR_OUT("#BREAK が 不正に出現したにょー.");
        return false;
    }
    return true;
}
/***********************************************************/
//ユーザ定義文の解釈.
/***********************************************************/
BigClass::CompleUserFunktion(char *buf)
{
    if ( !UserOperation(buf) )   //ユーザが定義したニモニック ?
    {
        if (! FunktionSearch(buf) )    //ユーザが定義した関数 ? 
        {
            COMPLE_ERROR_OUT("解析不能だにょー.");
            return false;
        }
    }
    return true;
}

/***********************************************************/
//ユーザ定義のファンクションを検索、展開します.
/***********************************************************/
BigClass::FunktionSearch(char *buf)
{
    TCommandList TCL;
    int ope,w;
    char *next_str;

    if ( ! FunktionStr) return false;

    TCL.set(FunktionStr);
    next_str = buf;
    //ユーザ命令を選択.
    ope =  TCL.search(buf,&next_str) ;
    if (ope < 0)    return false; //解読不能

    //解読できた!
    w = FunctionParaCals(next_str); //パラメタを展開.
    NewCommand(E_FUNK,ope,w);       //ユーザ定義ファンクション呼び出し.
    return true;    //ok.
}

/***********************************************************/
//ユーザ定義のファンクションのパラメータの展開.
/***********************************************************/
BigClass::FunctionParaCals(char *str)
{
    char buf[COMPLE_MAX_BUFFER_SIZE];
    int ParaNum = 0;
    int buf_counter = 0;
    for( ; *str ; str ++)
    {
        switch(*str)
        {
        case ',':
            buf[buf_counter] = 0;  //その文の修理用.
            AnalysisString(buf);   //その文字列を解析する
            NewCommand(E_PUSH,REG_S);       //S レジスタをスタックに積む.
            buf_counter = 0;
            ParaNum ++;
            break;
        default:
            buf[buf_counter++] = *str;
            break;
        }
    }
    if (buf_counter > 0)
    {
        buf[buf_counter] = 0;  //その文の修理用.
        AnalysisString(buf);   //その文字列を解析する
        NewCommand(E_PUSH,REG_S);       //S レジスタをスタックに積む.
    }
    return ParaNum;
}

/***********************************************************/
//次の文字列を計算式　及び、数式のどちらかで展開.
/***********************************************************/
BigClass::AnalysisString(char* str)
{
    //文字列の証拠 '"' を探す.
    int Cnt = 0;
    char *StrChk = str;
    for( ; *StrChk ; StrChk++) if (*StrChk == '"') Cnt ++;

    if (Cnt > 0)
    {   //文字列.
        NewCommand(E_MOVI,REG_S,
            ScripteString.StringMapping(str,UseString) );       //S レジスタにマッピングした場所を返す.
    }
    else
    {   //数式
        ScripteRevPorland.RevPorland( str , *MAction);
    }
    return true;
}


/***********************************************************/
//最適化.
/***********************************************************/
BigClass::Saitekika(ACTION_VECTOR *Ac)
{
	int ActionNo ;
	int OpeNo ;
	int NextOpNo;
	int MaxActiones;
	Action* lpTempAction;
	Action* lpNextTempAction;
	ACTION_VECTOR *NowAction;
	//基本的な最適化.
	//	MOV  REG_S,1		PUSH REG_S		=> PUSH  1
	//	MOVI REG_S,1		PUSH REG_S		=> PUSHI 1

	for(ActionNo = 0 ; ActionNo < ACTION_MAX ; ActionNo++)
	{
		NowAction = & Ac[ActionNo];
		MaxActiones = (*NowAction).size() - 1;	//ループ回数
		//各命令の内容を吟味します.
		for(OpeNo = 0 ; OpeNo < MaxActiones ; OpeNo ++)
		{
			lpTempAction = &(*NowAction)[OpeNo];
			if ( (lpTempAction->Nim == E_MOV || lpTempAction->Nim == E_MOVI) && (lpTempAction->O1 == REG_S) )
			{
				NextOpNo = OpeNo+1;
				if (NextOpNo >= MaxActiones) break; //次の命令はないのですねぇ ふへっ
				//次の命令を取得.
				lpNextTempAction = &(*NowAction)[NextOpNo];
				//次が、 PUSH REG_S だったら.最適化する.
				if (lpNextTempAction->Nim == E_PUSH && lpNextTempAction->O1 == REG_S)
				{
					//lpNextTempActionのところを 最適化したコードに改造します.
					if (lpTempAction->Nim == E_MOV)		lpNextTempAction->Nim = E_PUSH;
					else								lpNextTempAction->Nim = E_PUSHI;
					lpNextTempAction->O1 = lpTempAction->O2;

					(*NowAction).erase(lpTempAction);
					MaxActiones--;
				}
			}	// E_MOV E_MOVI の判定の IF
		}		// 
	}
}

/*****************************************************************/
//ゲージルーチン
/*****************************************************************/

/*****************************************************************/
//ゲージの初期設定
/*****************************************************************/
BigClass::Set(BMD pbmd,int px,int py ,int pw,int ph,int pmax,int pmin,int _GeajiSpeed)
{
    bmd = pbmd; //ゲージの絵
    bmdx = px ; //その絵をスタートさせる X
    bmdy = py ; //その絵をスタートさせる Y
    bmdw = pw ; //その絵の幅
    bmdh = ph ; //その絵の高さ

    max = pmax; //ゲージの最大値
    min = pmin; //ゲージの最小値
    distance = (pmax - pmin); //距離
    draw_width = 0; 
    true_width = 0;
    GeajiSpeed = _GeajiSpeed; //ゲージのスピード
    value = pmin;
}

/*****************************************************************/
//最大値を変更し直す
/*****************************************************************/
BigClass::ReSetMax(int pmax)
{
    max = pmax;
    distance = (max - min); //距離

    //念のためもとめ直す
    draw_width = bmdw * value / distance;
    true_width = draw_width;
}

/*****************************************************************/
//指定した値にゲージを変更する
/*****************************************************************/
BigClass::NowValue(int pvalue)
{
    //簡易クリッピング
    if (pvalue > max) pvalue = max;
    if (pvalue < min) pvalue = min;
    //ゲージの最大 : distance = X : value の比率を解く
    draw_width = bmdw * pvalue / distance;
    true_width = draw_width;
    //ゲージの値を変更
    value = pvalue;
}

/*****************************************************************/
//指定した値にゲージを少しずつ移動させて変更する
/*****************************************************************/
BigClass::AfterValue(int pvalue)
{
    //簡易クリッピング
    if (pvalue > max) pvalue = max;
    if (pvalue < min) pvalue = min;
    //ゲージの最大 : distance = X : value の比率を解く
    true_width = bmdw * pvalue / distance;
    //ゲージの値を変更
    value = pvalue;
}


/*****************************************************************/
//ゲージの絵画
/*****************************************************************/
BigClass::Draw(GraphicsProc Proc,int x,int y)
{
    Proc(bmd,bmdx,bmdy,draw_width,bmdh,Sprite,x,y);
    //増減していくゲージの場合は.......
    if (draw_width != true_width)
    {
        if(draw_width < true_width)
        {
            draw_width+=GeajiSpeed;
            if (draw_width > true_width) draw_width = true_width; //補正
        }
        else
        {
            draw_width-=GeajiSpeed;
            if (draw_width < true_width) draw_width = true_width; //補正
        }
    }

}





/************************************************************************************/
//マップロード
/************************************************************************************/
BigClass::Read(int no)
{
	FILE *fp;
	char heder[sizeof(MAP_HEDER)];
	char filename[256];
	int filenamesize;

	//ファイル名作成.
	sprintf(filename,MAP_FILENAME,no);

	MapNo = no;
	ChipFileName = NULL;
	Map = NULL;
	Chip = NULL;

    try
    {
	    //ファイルを読み込みます
	    fp = fopen(filename,"rb");
	    if (fp == NULL)
	    {
BigClass::Read",filename);
    	}
    	//ヘッダを読み込み検査
    	fread(heder,sizeof(MAP_HEDER),sizeof(char),fp); //ヘッダ
	    if (lstrcmp(heder,MAP_HEDER) != 0)
	    {
BigClass::Read",filename,"ヘッダがおかしいにょ","正常なファイルに差し替えてください");
    	}
    	filenamesize = fgetc(fp); //BMPのファイル名の長さ
    	//ファイル名格納
    	ChipFileName = (char*) GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,filenamesize +1);
    	if (ChipFileName == NULL) 
    	{
BigClass::Read",filename,"BMPファイル名を格納するメモリ確保に失敗にょ","ファイルがおかしいか、メモリが足りません");
	    }
	    fread(ChipFileName, filenamesize,sizeof(char),fp); //BMPファイル名

        //使用するマップチップBMPファイルを定義する
	    Chip = BmpChar->Make(ChipFileName);
	    if (Chip == NULL) 
	    {
BigClass::Read",filename,"指定された BMPが読めません.","ファイルがおかしいか、MAP_CHIPファイルがありません.");
    	}
        int UseMemroy = sizeof(short) * (MapW * MapH)+1;
        //X Y を読み込む
    	fread(&(MapW),1,sizeof(short),fp); //Xサイズ
    	fread(&(MapH),1,sizeof(short),fp); //Yサイズ
        //マップチップ用のメモリ確保
    	Map = (short*) GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, UseMemroy);
    	if (Map == NULL) 
    	{
BigClass::Read","MAP領域作成",UseMemroy);
    	}
    }
    catch(...)
    {
BigClass::Read",filename,"このマップファイル読み込みは断念されました.","");
    	Destroy();
	    if (fp != NULL)	fclose(fp);
	    return false;
    }
    //マップを読み込む
    fread(Map,(MapW * MapH),sizeof(short),fp);
	fclose(fp);
	return true;

}


/************************************************************************************/
//マップデータの破棄
/************************************************************************************/
BigClass::Destroy()
{
	if (ChipFileName != NULL)		GlobalFree(ChipFileName);
	if (Map != NULL)				GlobalFree(Map);
	if (Chip != NULL)				BmpChar->Breaker(Chip); 
	ChipFileName = NULL;
	Map = NULL;
	Chip = NULL;
}


/***********************************************************/
//マップの外に飛び出さないように... 飛び出していたら true
/***********************************************************/
BigClass::Clipping(int x,int y,int w,int h)
{
    return (x <= 0-w || x >= MAP_STOP_XSCROLL ||
					y <= 0-h || y >= MAP_STOP_YSCROLL );
}

/***********************************************************/
//私は表示されていないのかな? されてない true
/***********************************************************/
BigClass::IamNotDisplay(short x,short y,short faj)
{
    x -= Nowx;
    y -= Nowy;
    return (x < -faj || x > SCREENXSIZE+faj || y < -faj || y > SCREENYSIZE+faj);
}


/**************************************************************/
//マップ 描く
/**************************************************************/
BigClass::MapDrawing(BMD bmd,int Dx,int Dy,int Sx,int Sy,int W,int H)
{
	short wchip;
	short *wmap;

	wmap = Map; //高速化...だと思う.

	//マップを絵画します
	short lx,ly,sx,sy;
	lx = Sx >> MAP_CHIP_POW_SIZE;
	ly = Sy >> MAP_CHIP_POW_SIZE;
	sx = Sx % MAP_CHIP_SIZE;
	sy = Sy % MAP_CHIP_SIZE;
	short x,y,ix,iy;
	for (y = 0 ,iy = ly ;	y <= H ;	    y +=MAP_CHIP_SIZE , iy++ )
	{
		for (x = 0,ix = lx ; x <= W ;	x +=MAP_CHIP_SIZE ,ix ++)
		{
            //マップチップ絵画
			wchip = wmap[MAP_NOW_POINT(ix,iy)];
BigClass::DirectDraw(Chip
						,MAP_CHIPNO_TO_MAP_X(wchip) << MAP_CHIP_POW_SIZE
						,MAP_CHIPNO_TO_MAP_Y(wchip) << MAP_CHIP_POW_SIZE
						,MAP_CHIP_SIZE,MAP_CHIP_SIZE
						,bmd
						,Dx + x-sx,Dy + y-sy);
		}
	}
}

/**************************************************************/
//マップを絵画します
/**************************************************************/
BigClass::DrawMain(BMD bmd,int w,int h)
{
	MapDrawing(bmd,0,0,Nowx,Nowy,w,h);
}

/**************************************************************/
//主人公移動などによるマップスクロール
/**************************************************************/
BigClass::MapMasterMove(short nx,short ny,int speed)
{
	short lx,ly;  //スクリーン座標に変換
	lx = nx-Nowx;
	ly = ny-Nowy;
    //左右
    if (lx <=(SCREENXSIZE/2)-NOMOVEX)
		if (Nowx-speed >= 0) Nowx -=speed;
    if (lx >=(SCREENXSIZE/2)+NOMOVEX)
		if (Nowx+speed <= MAP_STOP_XSCROLL) Nowx +=speed;
    //上下
	if (ly <=(SCREENYSIZE/2)-NOMOVEY)
        if (Nowy-speed >= 0) Nowy -=speed;
	if (ly >=(SCREENYSIZE/2)+NOMOVEY)
        if (Nowy+speed <= MAP_STOP_YSCROLL) Nowy +=speed;
}


/**************************************************************/
//指定したポイントを画面の中心にする.
/**************************************************************/
BigClass::SetCeneter(short nx,short ny)
{
	int lx,ly;
	lx = -(SCREENXSIZEHARF-nx+Nowx);
	ly = -(SCREENYSIZEHARF-ny+Nowy);

	if (lx > 0)
	{
		if (Nowx+lx <= MAP_STOP_XSCROLL) Nowx +=lx;
        else Nowx = MAP_STOP_XSCROLL;
	}
	else
	{
        if (Nowx+lx >= 0)                Nowx +=lx;
        else Nowx = 0;
	}
	if (ly > 0)
	{
		if (Nowy+ly <= MAP_STOP_YSCROLL) Nowy +=ly;
        else Nowy = MAP_STOP_YSCROLL;
	}
	else
	{
        if (Nowy+ly >= 0)                Nowy +=ly;
        else Nowy = 0;
	}
}

/**************************************************************/
//そのポイントを通過できるかチェック
/**************************************************************/
BigClass::If(short nx,short ny)
{
	//ここで問題になるのが、
	//マップチップをまたぐ場合である.
	//とりあえず、そのすべてのまたぐチップと判定をとる.
	//もし、一つでも移動できないチップがまたがれると、没になる.
	short lx,ly;
	lx  = nx >> MAP_CHIP_POW_SIZE;
	ly  = ny >> MAP_CHIP_POW_SIZE;
	if (! MAP_THIS_CHIP_THUR(Map[MAP_NOW_POINT(lx,ly)]) )	return false;

	lx = (nx+31) >> MAP_CHIP_POW_SIZE;
	ly  = ny >> MAP_CHIP_POW_SIZE;
	if (! MAP_THIS_CHIP_THUR(Map[MAP_NOW_POINT(lx,ly)]) )	return false;

	lx  = nx >> MAP_CHIP_POW_SIZE;
	ly = (ny+31) >> MAP_CHIP_POW_SIZE;
	if (! MAP_THIS_CHIP_THUR(Map[MAP_NOW_POINT(lx,ly)]) )	return false;

	lx = (nx+31) >> MAP_CHIP_POW_SIZE;
	ly = (ny+31) >> MAP_CHIP_POW_SIZE;
	if (! MAP_THIS_CHIP_THUR(Map[MAP_NOW_POINT(lx,ly)]) )	return false;

	return true;
}


/*****************************************************************/
//簡易クリッピング
/*****************************************************************/
BigClass::EasyClipingEx(BMD bmd,int *rx1,int *ry1,int *rw1,int *rh1,
				 int rw2,int rh2,int rx2,int ry2,
				 int *sw,int *sh,int *ew,int *eh)
{
    //簡易終了位置クリッピング
/*
    //マイナス方向だったら補正.
    if(*rx1 < 0)
    {
        *rw1 += *rx1;  // *rx1 はマイナス.
        *rx1 = 0;
    }
    //マイナス方向だったら補正.
    if(*ry1 < 0)
    {
        *rh1 += *ry1;  // *ry1 はマイナス.
        *ry1 = 0;
    }
    //画像の横幅より大きければ　没
    if(*rx1 >= bmd->w)  return false;
    //画像の高さより大きければ　没
    if(*ry1 >= bmd->h)  return false;
    
    int p;
    p = rw2 - rx2 ;
    if (p < rw1)    *ew = p;
    else            *ew = rw1;
    if (rx2 < 0 ) *sw = abs(rx2) , *ew = *ew - *sw;
    else          *sw = 0;

    p = rh2 - ry2 ;
    if (p < rh1)    *eh = p;
    else            *eh = rh1;
    if (ry2 < 0 ) *sh = abs(ry2) , *eh = *eh - *sh;
    else          *sh = 0;

    if (*ew <= 0 || *eh <= 0 ) return false;
	return true;
*/
    bool r = false;
    _asm
    {
		mov			edi,bmd
       //マイナス方向だったら補正.
	   mov         eax,dword ptr [rx1]
	   mov         ecx,dword ptr [rw1]
	   mov		   ebx,dword ptr [eax]	//rx1の中身
	   mov         edx,dword ptr [ecx]	//rw1の中身
  	   cmp         ebx,0
	   jge         NONE_RX1_HOSEI
			add			edx,ebx	//*rw1 += *rx1;  // *rx1 はマイナス.
			mov			ebx,0	//*rx1 = 0;
			mov			[ecx],edx
			mov			[eax],ebx
	NONE_RX1_HOSEI:
		//画像の横幅より大きければ　没
		//if(*rx1 >= bmd->w)  return false;
		mov ecx,[edi+BMD_W_POSSITION]	//機種依存!!	bmd->w
		cmp	ebx,ecx
		jge	END_PROC	//没

       //マイナス方向だったら補正.
	   mov         eax,dword ptr [ry1]
	   mov         ecx,dword ptr [rh1]
	   mov		   ebx,dword ptr [eax]	//ry1の中身
	   mov         edx,dword ptr [ecx]	//rh1の中身
  	   cmp         ebx,0
	   jge         NONE_RY1_HOSEI
			add			edx,ebx	//*rh1 += *ry1;  // *ry1 はマイナス.
			mov			ebx,0	//*ry1 = 0;
			mov			[ecx],edx
			mov			[eax],ebx
	NONE_RY1_HOSEI:
		//画像の横幅より大きければ　没
		//if(*rx1 >= bmd->h)  return false;
		mov ecx,[edi+BMD_H_POSSITION]	//機種依存!!	bmd->h
		cmp	ebx,ecx
		jge	END_PROC	//没


        //ワイドの ew
        mov eax,rw2 //eax は rw2
        mov ebx,rx2 //ebx は rx2
        mov ecx,rw1 // ecx を rw1 にする.
		mov ecx,[ecx]	//rw1 は ポインタなので実態化する
        sub eax,ebx // rw2 - rx2

        mov edi,ecx // ediは *ew のこと に rw1を入れる
        cmp eax,ecx //p と rw1 の比較
        jge W_NEXT1
            mov edi,eax //*ew に p を入れる
    W_NEXT1:

        //ワイドの sw
        mov esi,0 // esiは *sw のこと に 0を入れる
        test ebx,0x80000000 // rx2 がマイナス ? 
        jz  W_NEXT2        //マイナスぢゃないなら 0 でよいので抜ける
        neg  ebx            //rx2 の絶対値(正数にして)
            mov esi,ebx         //*sw に入れる
            sub edi,ebx         //*ew = *ew - *sw
    W_NEXT2:
        //メモリに書き戻し
        mov eax,ew
        mov ebx,sw
        mov dword ptr [eax],edi
        mov dword ptr [ebx],esi
            mov edx,edi  // 最後の比較用に ew を保存(edxは使われていないので)

        //ヘイトの eh
        mov eax,rh2 //eax は rh2
        mov ebx,ry2 //ebx は ry2
        mov ecx,rh1 // ecx を rh1 にする.
		mov ecx,[ecx]	//rh1 は ポインタなので実態化する
        sub eax,ebx // rh2 - ry2

        mov edi,ecx // ediは *eh のこと に rh1を入れる
        cmp eax,ecx //p と rh1 の比較
        jge H_NEXT1
            mov edi,eax //*eh に p を入れる
    H_NEXT1:

        //ヘイトの sh
        mov esi,0 // esiは *sh のこと に 0を入れる
        test ebx,0x80000000 // ry2 がマイナス ? 
        jz  H_NEXT2        //マイナスぢゃないなら 0 でよいので抜ける
        neg  ebx            //ry2 の絶対値(正数にして)
            mov esi,ebx         //*sh に入れる
            sub edi,ebx         //*eh = *eh - *sh
    H_NEXT2:
        //メモリに書き戻し
        mov eax,eh
        mov ebx,sh
        mov dword ptr [eax],edi
        mov dword ptr [ebx],esi

        //絵画していいのかなぁ...
	    //if (*ew <= 0 || *eh <= 0 ) return false;
        cmp edx,0
        jle END_PROC
        cmp edi,0
        jle END_PROC
            //成立した合図
            mov r,1
    END_PROC:
    }
    return r;            
}


/*****************************************************************/
//データの頭だし
/*****************************************************************/
BigClass::SeekData(BMD bmd,int rx,int ry,
			  int sw,int sh,int *lpAddPitch)
{
    *lpAddPitch = (bmd->w + bmd->w + bmd->w);
	return (bmd->bm+(rx+sw)*3+(ry+sh)* (*lpAddPitch) );

}




static void linerInterpolate(BMD bmd,Fixed x,Fixed y,int *rgb);
static BYTE linePol(int c1,int c2,int c3,int c4,Fixed xr,Fixed yr);



//そのグラフィックスを sizex sizey に切り裂いたときの個数
//と、Xの数、Yの数を CX,CYに返す
BigClass::GraphicsCutTile(BMD bmd,int sizex,int sizey,short *cx,short *cy)
{
	int t,TableSize;
    t = bmd->w / sizex;
    if (bmd->w % sizex) t ++;
    TableSize = (*cx) = t;

    t = bmd->h / sizey;
    if (bmd->h % sizey) t ++;
    TableSize *= (*cy = t);
	return TableSize;
}

/*****************************************************************/
//拡大縮小　線形補完
/*****************************************************************/
BigClass::BigDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2,int rw2,int rh2)
{
    int x,y;
    Fixed fx,fy;
    Fixed sfx,sfy;
    int ew,eh;
    int rgb;

	if (rw2 != 0)
	{
		sfx = FixedDiv( IF(rw1) , IF(rw2) ) ; //比率計算
	}
	else
	{
		sfx = 0;
	}
	if (rh2 != 0)
	{
	    sfy = FixedDiv( IF(rh1) , IF(rh2) ) ;
	}
	else
	{
		sfy = 0;
	}

	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;

    ew = rw2-1;
    eh = rh2-1;
    for (y = 0 ,fy = ry1+1 ; y < eh-1 ;y ++ , fy += sfy)
    {
        for (x = 0 ,fx = rx1+1; x < ew-1 ;x ++ , fx += sfx)
        {
            //取得
            linerInterpolate(bmd1,fx,fy,&rgb ); 
            //転送
            PSet(bmd2,x+rx2,y+ry2,rgb);
        }
    }

	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
}

void linerInterpolate(BMD bmd,Fixed x,Fixed y,int *rgb)
{
    int px,py;
    Fixed xrate,yrate;
    BYTE r,g,b;
    long col1,col2,col3,col4;

    px =(int)Fixed2Int(x);
    py =(int)Fixed2Int(y);

    xrate = x-Int2Fixed(px);
    yrate = y-Int2Fixed(py);

    //色取得
    col1 = PGet(bmd,px+1,py-1);
    col2 = PGet(bmd,px+1,py+1);
    col3 = PGet(bmd,px-1,py-1);
    col4 = PGet(bmd,px-1,py+1);

    g = linePol( ((int)col1 & 0x000000ff) ,
                 ((int)col2 & 0x000000ff) ,
                 ((int)col3 & 0x000000ff) ,
                 ((int)col4 & 0x000000ff) ,
                 (xrate),(yrate));
    r = linePol( ((int)((col1 & 0x0000ff00) >> 8) ) ,
                 ((int)((col2 & 0x0000ff00) >> 8) ) ,
                 ((int)((col3 & 0x0000ff00) >> 8) ) ,
                 ((int)((col4 & 0x0000ff00) >> 8) ) ,
                 (xrate),(yrate) );
    b = linePol( ((int)((col1 & 0x00ff0000) >> 16) ) ,
                 ((int)((col2 & 0x00ff0000) >> 16) ) ,
                 ((int)((col3 & 0x00ff0000) >> 16) ) ,
                 ((int)((col4 & 0x00ff0000) >> 16) ) ,
                 (xrate),(yrate) );
    //とりあえず (^^;
    *rgb = RTIRGB(r,g,b);
}


BYTE linePol(int c1,int c2,int c3,int c4,Fixed xr,Fixed yr)
{
    Fixed d,e,f;
    d = ( (IF(1)-(xr)) * c1) + (xr * c3);
    e = ( (IF(1)-(xr)) * c2) + (xr * c4);
    f = FixedMul(d,(Int2Fixed(1)-yr) )+ FixedMul(e,yr);
    return (BYTE)( Fixed2Int(FixedRound(f)) );
}


/*****************************************************************/
//ぼかし
/*****************************************************************/
BigClass::ShadeDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2)
{
//    int x,y;

	int AddPitch1,AddPitch2;
	BYTE *data1,*data2;

    int sw,sh,ew,eh;
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);

    _asm{
		dec ew ;こいつらはあらかじめ減算しておく
		dec eh
        mov edx,eh
        mov edi,data1 ;転送元
        mov esi,data2 ;転送先
    LOOP1:              ;ループカウンタに edx を使用中
            push edi
            push esi
            push edx  //ちょっと拝借 LOOP2の中で使うので..
            
            mov ecx,ew
//            xor bx,bx    ;中で作業用に使います LOOP2のことね
        LOOP2:           ;ループカウンタに ecx を使用中

//                mov edi,data1 ;転送元
//                mov esi,data2 ;転送先
				push ecx         ;ちょっと拝借

				//上
				mov edx,edi
				sub edx,AddPitch1
                mov eax,[edx] ;いっきにいただきます
                and eax,0x00ffffff ;不要な部分を切り落とす
                push eax
				//下
				mov edx,edi
				add edx,AddPitch1
                mov eax,[edx] ;いっきにいただきます
                and eax,0x00ffffff ;不要な部分を切り落とす
                push eax
				//左
				mov edx,edi
				sub edx,3
                mov eax,[edx] ;いっきにいただきます
                and eax,0x00ffffff ;不要な部分を切り落とす
                push eax
				//右
				mov edx,edi
				sub edx,3
                mov eax,[edx] ;いっきにいただきます
                and eax,0x00ffffff ;不要な部分を切り落とす
                push eax

                //0x000000ffについて計算
				//eaxは加算ようです
				pop eax ;右の要素
				pop ebx ;右の要素
                and eax,0x000000ff
                and ebx,0x000000ff
                add eax,ebx
				pop ebx ;右の要素
				pop edx ;右の要素  ;他の二つはあとで合成
                sub esp,16    ;4*4バイト(pop pop)戻しておく
                and ebx,0x000000ff
                and edx,0x000000ff
                add ebx,edx
				add eax,ebx		   ;合成
                shr eax,2          ;平均を出す
                and eax,0x000000ff ;念のため再クリッピング
                mov ecx,eax        ;ecxは合計ように拝借

                //0x0000ff00について計算
				//eaxは加算ようです
				pop eax ;右の要素
				pop ebx ;右の要素
                and eax,0x0000ff00
                and ebx,0x0000ff00
                add eax,ebx
				pop ebx ;右の要素
				pop edx ;右の要素  ;他の二つはあとで合成
                sub esp,16    ;4*4バイト(pop pop)戻しておく
                and ebx,0x0000ff00
                and edx,0x0000ff00
                add ebx,edx		   ;合成
				add eax,ebx		   ;合成
                shr eax,2          ;平均を出す
                and eax,0x0000ff00 ;念のため再クリッピング
                or  ecx,eax

                //0x00ff0000について計算
				//eaxは加算ようです
				pop eax ;右の要素
				pop ebx ;右の要素
                and eax,0x00ff0000
                and ebx,0x00ff0000
                add eax,ebx
				pop ebx ;右の要素
				pop edx ;右の要素  ;他の二つはあとで合成
                and ebx,0x00ff0000
                and edx,0x00ff0000
                add ebx,edx		   ;合成
				add eax,ebx		   ;合成
                shr eax,2          ;平均を出す
                and eax,0x00ff0000 ;念のため再クリッピング
                or  ecx,eax

                mov ebx,[esi]      ;あまりをくりぬく
                and ebx,0xff000000
                or  ebx,ecx

                mov [esi],ebx

                add edi,3
                add esi,3

				pop ecx         ;ちょっと拝借を戻す
            dec ecx
            cmp ecx,1
            ja  LOOP2       ;LOOP2終了 ECX解放

//            pop data2 ;データ復帰
//            pop data1
            pop edx
            pop esi
            pop edi

//            mov ebx,AddPitch1 ;Y軸要素をプラス
//            mov ecx,AddPitch2
//            add data1,ebx
//            add data2,ecx
            add edi,AddPitch1
            add esi,AddPitch2
        dec edx             ;LOOP1終了 EDX解放
        cmp edx,1
        ja  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
/*
    for (y = 1 ; y < eh-1 ;y ++ )
    {
        BackupPoint1 = data1;
        BackupPoint2 = data2;
        for (x = 1 ; x < ew-1 ;x ++ )
        {
            GetPoint = data1 - AddPitch1; //上
			B=  *(GetPoint);
			G=  *(GetPoint +1);
			R=  *(GetPoint +2);
            GetPoint = data1 + AddPitch1; //下
			B+=  *(GetPoint);
			G+=  *(GetPoint +1);
			R+=  *(GetPoint +2);
            GetPoint = data1 - 3;  //左
			B+=  *(GetPoint);
			G+=  *(GetPoint +1);
			R+=  *(GetPoint +2);
            GetPoint = data1 + 3; //右
			B+=  *(GetPoint);
			G+=  *(GetPoint +1);
			R+=  *(GetPoint +2);
			
			R = R >> 2;
			G = G >> 2;
			B = B >> 2;
			*(data2) = B;
            *(data2 +1) = G;
			*(data2 +2) = R;
            data1 += 3 ;
            data2 += 3 ;
        }
        data1 = BackupPoint1 ;
        data2 = BackupPoint2 ;
        data1 += AddPitch1 ;
        data2 += AddPitch2 ;
    }
*/
}

/*****************************************************************/
//半透明
/*****************************************************************/
BigClass::Blend50Draw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2)
{
//    int x,y;

	int AddPitch1,AddPitch2;
	BYTE *data1,*data2;


    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);

    _asm{
        mov edx,eh
        mov edi,data1 ;転送元
        mov esi,data2 ;転送先
    LOOP1:              ;ループカウンタに edx を使用中
            push edi
            push esi
            push edx  //ちょっと拝借 LOOP2の中で使うので..
            
            mov ecx,ew
        LOOP2:           ;ループカウンタに ecx を使用中

                mov eax,[edi] ;いっきにいただきます
                mov ebx,[esi]      ;
                test eax,0x00ffffff
                jz   NON_DRAW //透明は無視
				push ebx      //メモリアクセスはなるべくイヤ

                push eax
                push ebx

                //0x000000ffについて計算
                and eax,0x000000ff
                and ebx,0x000000ff
                add eax,ebx
                shr eax,1	;1バイトシフト / 2
                and eax,0x000000ff ;念のため再クリッピング
                mov edx,eax

                //0x0000ff00について計算
                pop ebx
                pop eax
                sub esp,8    ;4*2バイト(pop pop)戻しておく
                and eax,0x0000ff00
                and ebx,0x0000ff00
                add eax,ebx
                shr eax,1   ;1バイトシフト / 2
                and eax,0x0000ff00 ;念のため再クリッピング
                or edx,eax

                //0x00ff0000について計算
                pop ebx
                pop eax
                and eax,0x00ff0000
                and ebx,0x00ff0000
                add eax,ebx
                shr eax,1   ;1バイトシフト /2 
                and eax,0x00ff0000 ;念のため再クリッピング
                or edx,eax

				pop ebx;あまりをくりぬく
                and ebx,0xff000000
                or  ebx,edx

                mov [esi],ebx
NON_DRAW:

                add edi,3
                add esi,3
            dec ecx
            jnz  LOOP2       ;LOOP2終了 ECX解放

            pop edx
            pop esi
            pop edi
			//画像を次のラインへ
            add edi,AddPitch1
            add esi,AddPitch2
        dec edx             ;LOOP1終了 EDX解放
        jnz  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
            /*
    for (y = 0 ; y < eh ;y ++ )
    {
        BackupPoint1 = data1;
        BackupPoint2 = data2;
        for (x = 0 ; x < ew ;x ++ )
        {
			B=  *(data1);
			G=  *(data1 +1);
			R=  *(data1 +2);
			B += *(data2) ;
            G += *(data2 +1) ;
			R += *(data2 +2) ;
            R = R >> 1;
            G = G >> 1;
            B = B >> 1;
			*(data2) = B;
            *(data2 +1) = G;
			*(data2 +2) = R;
            data1 += 3 ;
            data2 += 3 ;
        }
        data1 = BackupPoint1 ;
        data2 = BackupPoint2 ;
        data1 += AddPitch1 ;
        data2 += AddPitch2 ;
    }
            */

}

/*****************************************************************/
//半以上または以下透明
/*****************************************************************/
BigClass::BlendDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2,
                      Fixed fblend,Fixed fglend,Fixed frlend)
{
    int x,y;

    Fixed frlend2,fglend2,fblend2;
    fblend2 = Int2Fixed(1) - fblend;
    fglend2 = Int2Fixed(1) - fglend;
    frlend2 = Int2Fixed(1) - frlend;

	int AddPitch1,AddPitch2;
    int R,G,B;
    int R2,G2,B2;
	BYTE *BackupPoint1,*BackupPoint2;
	BYTE *data1,*data2;

    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);

    for (y = 0 ; y < eh ;y ++ )
    {
        BackupPoint1 = data1;
        BackupPoint2 = data2;
        for (x = 0 ; x < ew ;x ++ )
        {
			B=  *(data1);
			G=  *(data1 +1);
			R=  *(data1 +2);

			B2 = *(data2) ;
            G2 = *(data2 +1) ;
			R2 = *(data2 +2) ;
            B= (BYTE)Fixed2Int( ( fblend2*R2) + ( fblend*R) ) ;
            G= (BYTE)Fixed2Int( ( fglend2*G2) + ( fglend*G) ) ;
            R= (BYTE)Fixed2Int( ( frlend2*B2) + ( frlend*B) ) ;
			*(data2) = B;
            *(data2 +1) = G;
			*(data2 +2) = R;
            data1 += 3 ;
            data2 += 3 ;
        }
        data1 = BackupPoint1 ;
        data2 = BackupPoint2 ;
        data1 += AddPitch1 ;
        data2 += AddPitch2 ;
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
}

/*****************************************************************/
//グラデーションブレンド
/*****************************************************************/
BigClass::BlendGradetionDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
						BMD bmd2,int rx2,int ry2,
						Fixed fblend,Fixed fglend,Fixed frlend,
						unsigned char mode,int start,int size)
{
    int x,y;

    Fixed frlend2,fglend2,fblend2;
    Fixed frlend3,fglend3,fblend3;
    fblend2 = Int2Fixed(1) - fblend;
    fglend2 = Int2Fixed(1) - fglend;
    frlend2 = Int2Fixed(1) - frlend;

	int Gr ;
	int AddPitch1,AddPitch2;
    int R,G,B;
    int R2,G2,B2;
	BYTE *BackupPoint1,*BackupPoint2;
	BYTE *data1,*data2;

    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);

	frlend3 = frlend2;
	fglend3 = fglend2;
	fblend3 = fblend2;
    for (y = 0 ; y < eh ;y ++ )
    {
		frlend2 = frlend3;
		fglend2 = fglend3;
		fblend2 = fblend3;
		Gr = 0;
        BackupPoint1 = data1;
        BackupPoint2 = data2;
        for (x = 0 ; x < ew ;x ++ )
        {
			B=  *(data1);
			G=  *(data1 +1);
			R=  *(data1 +2);

			B2 = *(data2) ;
            G2 = *(data2 +1) ;
			R2 = *(data2 +2) ;
			if (x > start)
			{
				if (++Gr > size)
				{
					Gr = 0;
					frlend2 -= (2048);
					fglend2 -= (2048);
					fblend2 -= (2048);
					if (frlend2 < 0) frlend2 = 0;
					if (fglend2 < 0) fglend2 = 0;
					if (fblend2 < 0) fblend2 = 0;
				}
			}
		    frlend = Int2Fixed(1) - frlend2;
			fglend = Int2Fixed(1) - fglend2;
			fblend = Int2Fixed(1) - fblend2;

            B= (BYTE)Fixed2Int( (fblend2*R2) + (fblend*R) ) ;
            G= (BYTE)Fixed2Int( (fglend2*G2) + (fglend*G) ) ;
            R= (BYTE)Fixed2Int( (frlend2*B2) + (frlend*B) ) ;
			*(data2) = B;
            *(data2 +1) = G;
			*(data2 +2) = R;
            data1 += 3 ;
            data2 += 3 ;
        }
        data1 = BackupPoint1 ;
        data2 = BackupPoint2 ;
        data1 += AddPitch1 ;
        data2 += AddPitch2 ;
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);

}

/*****************************************************************/
//半明度調整
/*****************************************************************/
BigClass::Bright50Draw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2)
{
//    int x,y;

	int AddPitch1,AddPitch2;
//    int R,G,B;
//	BYTE *BackupPoint1,*BackupPoint2;
	BYTE *data1,*data2;


    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
/*

    //簡易終了位置クリッピング
    int sw,sh,ew,eh,p;
    p = bmd2->w - rx2 ;
    if (p < rw1)    ew = p;
    else            ew = rw1;
    if (rx2 < 0 ) sw = abs(rx2) , ew = ew - sw;
    else          sw = 0;

    p = bmd2->h - ry2 ;
    if (p < rh1)    eh = p;
    else            eh = rh1;
    if (ry2 < 0 ) sh = abs(ry2) , eh = eh - sh;
    else          sh = 0;

    if (ew <= 0 || eh <= 0 ) return;
*/
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);

/*
    AddPitch1 = (bmd1->w * 3);
    AddPitch2 = (bmd2->w * 3);
	data1= (bmd1->bm+(rx1+sw)*3+(ry1+sh)*AddPitch1 );
	data2= (bmd2->bm+(rx2+sw)*3+(ry2+sh)*AddPitch2 );
*/
    _asm{
        mov edx,eh
        mov edi,data1 ;転送元
        mov esi,data2 ;転送先
    LOOP1:              ;ループカウンタに edx を使用中
//            push data1   ;データ待避
//            push data2
            push edi
            push esi
            
            mov ecx,ew
        LOOP2:           ;ループカウンタに ecx を使用中

//                mov edi,data1 ;転送元
//                mov esi,data2 ;転送先
                
                mov eax,[edi] ;いっきにいただきます
                push eax

                //0x000000ffについて計算
                and eax,0x000000ff
                shr eax,1
                and eax,0x000000ff ;念のため再クリッピング
                mov ebx,eax

                //0x0000ff00について計算
                pop eax
                sub esp,4    ;4*1バイト(pop pop)戻しておく
                and eax,0x0000ff00
                shr eax,1   ;1バイトシフト
                and eax,0x0000ff00 ;念のため再クリッピング
                or ebx,eax

                //0x00ff0000について計算
                pop eax
                and eax,0x00ff0000
                shr eax,1   ;1バイトシフト
                and eax,0x00ff0000 ;念のため再クリッピング
                or ebx,eax

                mov eax,[esi]      ;あまりをくりぬく
                and eax,0xff000000
                or  eax,ebx

                mov [esi],eax

//                add data1,3
//                add data2,3
                add edi,3
                add esi,3
            dec ecx
            jnz  LOOP2       ;LOOP2終了 ECX解放

//            pop data2 ;データ復帰
//            pop data1
            pop esi
            pop edi

//            mov ebx,AddPitch1 ;Y軸要素をプラス
//            mov ecx,AddPitch2
//            add data1,ebx
//            add data2,ecx
            add edi,AddPitch1
            add esi,AddPitch2
        dec edx             ;LOOP1終了 EDX解放
        jnz  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
            /*
    for (y = 0 ; y < eh ;y ++ )
    {
        BackupPoint1 = data1;
        BackupPoint2 = data2;
        for (x = 0 ; x < ew ;x ++ )
        {
			B=  *(data1);
			G=  *(data1 +1);
			R=  *(data1 +2);
			B += *(data2) ;
            G += *(data2 +1) ;
			R += *(data2 +2) ;
            R = R >> 1;
            G = G >> 1;
            B = B >> 1;
			*(data2) = B;
            *(data2 +1) = G;
			*(data2 +2) = R;
            data1 += 3 ;
            data2 += 3 ;
        }
        data1 = BackupPoint1 ;
        data2 = BackupPoint2 ;
        data1 += AddPitch1 ;
        data2 += AddPitch2 ;
    }
            */

}


/*****************************************************************/
//明度調整
/*****************************************************************/
BigClass::BrightDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2,
                      Fixed fblend,Fixed fglend,Fixed frlend)
{
    int x,y;

	int AddPitch1,AddPitch2;
    int R,G,B;
	BYTE *BackupPoint1,*BackupPoint2;
	BYTE *data1,*data2;

    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
/*
    //簡易終了位置クリッピング
    int sw,sh,ew,eh,p;
    p = bmd2->w - rx2 ;
    if (p < rw1)    ew = p;
    else            ew = rw1;
    if (rx2 < 0 ) sw = abs(rx2) , ew = ew - sw;
    else          sw = 0;

    p = bmd2->h - ry2 ;
    if (p < rh1)    eh = p;
    else            eh = rh1;
    if (ry2 < 0 ) sh = abs(ry2) , eh = eh - sh;
    else          sh = 0;

    if (ew <= 0 || eh <= 0 ) return;
*/
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);
/*
    AddPitch1 = (bmd1->w * 3);
    AddPitch2 = (bmd2->w * 3);
	data1= (bmd1->bm+(rx1+sw)*3+(ry1+sh)*AddPitch1 );
	data2= (bmd2->bm+(rx2+sw)*3+(ry2+sh)*AddPitch2 );
*/
    for (y = 0 ; y < eh ;y ++ )
    {
        BackupPoint1 = data1;
        BackupPoint2 = data2;
        for (x = 0 ; x < ew ;x ++ )
        {
			B=  *(data1);
			G=  *(data1 +1);
			R=  *(data1 +2);
            B= (fblend*R);
            G= (fglend*G);
            R= (frlend*B);

			*(data2) = B;
            *(data2 +1) = G;
			*(data2 +2) = R;
            data1 += 3 ;
            data2 += 3 ;
        }
        data1 = BackupPoint1 ;
        data2 = BackupPoint2 ;
        data1 += AddPitch1 ;
        data2 += AddPitch2 ;
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
}


/*****************************************************************/
//加算アルファブレンド 半透明のシフト抜きの使い回し(劇汗)
/*****************************************************************/
BigClass::AddDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2)
{
//    int x,y;

	int AddPitch1,AddPitch2;
//    int R,G,B;
//	BYTE *BackupPoint1,*BackupPoint2;
	BYTE *data1,*data2;


    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
/*
    //簡易終了位置クリッピング
    int sw,sh,ew,eh,p;
    p = bmd2->w - rx2 ;
    if (p < rw1)    ew = p;
    else            ew = rw1;
    if (rx2 < 0 ) sw = abs(rx2) , ew = ew - sw;
    else          sw = 0;

    p = bmd2->h - ry2 ;
    if (p < rh1)    eh = p;
    else            eh = rh1;
    if (ry2 < 0 ) sh = abs(ry2) , eh = eh - sh;
    else          sh = 0;

    if (ew <= 0 || eh <= 0 ) return;
*/
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);

/*
    AddPitch1 = (bmd1->w * 3);
    AddPitch2 = (bmd2->w * 3);
	data1= (bmd1->bm+(rx1+sw)*3+(ry1+sh)*AddPitch1 );
	data2= (bmd2->bm+(rx2+sw)*3+(ry2+sh)*AddPitch2 );
*/
    _asm{
        mov edx,eh
        mov edi,data1 ;転送元
        mov esi,data2 ;転送先
    LOOP1:              ;ループカウンタに edx を使用中
//            push data1   ;データ待避
//            push data2
            push edi
            push esi
            push edx  //ちょっと拝借 LOOP2の中で使うので..
            
            mov ecx,ew
        LOOP2:           ;ループカウンタに ecx を使用中

//                mov edi,data1 ;転送元
//                mov esi,data2 ;転送先
                
                mov eax,[edi] ;いっきにいただきます
                mov ebx,[esi]      ;
                and eax,0x00ffffff ;不要な部分を切り落とす
                and ebx,0x00ffffff ;不要な部分を切り落とす
                push eax
                push ebx

                //0x000000ffについて計算
                and eax,0x000000ff
                and ebx,0x000000ff
                add eax,ebx
				cmp eax,0x000000ff
				jbe	None_Hosei1
					mov	eax,0x000000ff	//補正
			None_Hosei1:
                mov edx,eax

                //0x0000ff00について計算
                pop ebx
                pop eax
                sub esp,8    ;4*2バイト(pop pop)戻しておく
                and eax,0x0000ff00
                and ebx,0x0000ff00
                add eax,ebx
				cmp eax,0x0000ff00
				jbe	None_Hosei2
					mov	eax,0x0000ff00	//補正
			None_Hosei2:
                or edx,eax

                //0x00ff0000について計算
                pop ebx
                pop eax
                and eax,0x00ff0000
                and ebx,0x00ff0000
                add eax,ebx
				cmp eax,0x00ff0000
				jbe	None_Hosei3
					mov	eax,0x00ff0000	//補正
			None_Hosei3:
                or edx,eax

                mov ebx,[esi]      ;あまりをくりぬく
                and ebx,0xff000000
                or  ebx,edx

                mov [esi],ebx

//                add data1,3
//                add data2,3
                add edi,3
                add esi,3
            dec ecx
            jnz  LOOP2       ;LOOP2終了 ECX解放

//            pop data2 ;データ復帰
//            pop data1
            pop edx
            pop esi
            pop edi

//            mov ebx,AddPitch1 ;Y軸要素をプラス
//            mov ecx,AddPitch2
//            add data1,ebx
//            add data2,ecx
            add edi,AddPitch1
            add esi,AddPitch2
        dec edx             ;LOOP1終了 EDX解放
        jnz  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
}

/*****************************************************************/
//減算アルファブレンド
/*****************************************************************/
BigClass::SubDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2)
{
//    int x,y;

	int AddPitch1,AddPitch2;
//    int R,G,B;
//	BYTE *BackupPoint1,*BackupPoint2;
	BYTE *data1,*data2;


    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
/*
    //簡易終了位置クリッピング
    int sw,sh,ew,eh,p;
    p = bmd2->w - rx2 ;
    if (p < rw1)    ew = p;
    else            ew = rw1;
    if (rx2 < 0 ) sw = abs(rx2) , ew = ew - sw;
    else          sw = 0;

    p = bmd2->h - ry2 ;
    if (p < rh1)    eh = p;
    else            eh = rh1;
    if (ry2 < 0 ) sh = abs(ry2) , eh = eh - sh;
    else          sh = 0;

    if (ew <= 0 || eh <= 0 ) return;
*/
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);

/*
    AddPitch1 = (bmd1->w * 3);
    AddPitch2 = (bmd2->w * 3);
	data1= (bmd1->bm+(rx1+sw)*3+(ry1+sh)*AddPitch1 );
	data2= (bmd2->bm+(rx2+sw)*3+(ry2+sh)*AddPitch2 );
*/
    _asm{
        mov edx,eh
        mov edi,data1 ;転送元
        mov esi,data2 ;転送先
    LOOP1:              ;ループカウンタに edx を使用中
//            push data1   ;データ待避
//            push data2
            push edi
            push esi
            push edx  //ちょっと拝借 LOOP2の中で使うので..
            
            mov ecx,ew
        LOOP2:           ;ループカウンタに ecx を使用中

//                mov edi,data1 ;転送元
//                mov esi,data2 ;転送先
                
                mov eax,[edi] ;いっきにいただきます
                mov ebx,[esi]      ;
                and eax,0x00ffffff ;不要な部分を切り落とす
                and ebx,0x00ffffff ;不要な部分を切り落とす
                push eax
                push ebx

                //0x000000ffについて計算
                and eax,0x000000ff
                and ebx,0x000000ff
                sub eax,ebx
                //マイナスにつっこんだときの補正
                jns None_Hosei1
                    mov     eax,0
            None_Hosei1:
                mov edx,eax

                //0x0000ff00について計算
                pop ebx
                pop eax
                sub esp,8    ;4*2バイト(pop pop)戻しておく
                and eax,0x0000ff00
                and ebx,0x0000ff00
                sub eax,ebx
                //マイナスにつっこんだときの補正
                jns None_Hosei2
                    mov     eax,0
            None_Hosei2:
                or edx,eax

                //0x00ff0000について計算
                pop ebx
                pop eax
                and eax,0x00ff0000
                and ebx,0x00ff0000
                sub eax,ebx
                //マイナスにつっこんだときの補正
                jns None_Hosei3
                    mov     eax,0
            None_Hosei3:
                or edx,eax

                mov ebx,[esi]      ;あまりをくりぬく
                and ebx,0xff000000
                or  ebx,edx

                mov [esi],ebx

//                add data1,3
//                add data2,3
                add edi,3
                add esi,3
            dec ecx
            jnz  LOOP2       ;LOOP2終了 ECX解放

//            pop data2 ;データ復帰
//            pop data1
            pop edx
            pop esi
            pop edi

//            mov ebx,AddPitch1 ;Y軸要素をプラス
//            mov ecx,AddPitch2
//            add data1,ebx
//            add data2,ecx
            add edi,AddPitch1
            add esi,AddPitch2
        dec edx             ;LOOP1終了 EDX解放
        jnz  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
}

/*****************************************************************/
//BitBlt の AND 効果 (^^;;  通過処理はなしです.
/*****************************************************************/
BigClass::AndDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2)
{
	int AddPitch1,AddPitch2;
	BYTE *data1,*data2;

    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);
    _asm{
        mov edx,eh
        mov edi,data1 ;転送
        mov esi,data2 ;転送
    LOOP1:              ;ループカウンタに edx を使用中
            push edi
            push esi
            
            mov ecx,ew
        LOOP2:           ;ループカウンタに ecx を使用中

                mov eax,[edi] ;いっきにいただきます
                mov ebx,[esi]      ;転送先からゲット

                or eax,0xff000000 //転送先にある 上位8ビットを壊さないように
                and eax,ebx       // And 処理
                mov [esi],eax     //書き込み

                add edi,3
                add esi,3
            dec ecx
            jnz  LOOP2       ;LOOP2終了 ECX解放

            pop esi
            pop edi

            add edi,AddPitch1
            add esi,AddPitch2
        dec edx             ;LOOP1終了 EDX解放
        jnz  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
}

/*****************************************************************/
//BitBlt の OR(PAINT) 効果 (^^;;  通過処理はなしです.
/*****************************************************************/
BigClass::OrDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2)
{
	int AddPitch1,AddPitch2;
	BYTE *data1,*data2;

    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);
    _asm{
        mov edx,eh
        mov edi,data1 ;転送
        mov esi,data2 ;転送
    LOOP1:              ;ループカウンタに edx を使用中
            push edi
            push esi
            
            mov ecx,ew
        LOOP2:           ;ループカウンタに ecx を使用中

                mov eax,[edi] ;いっきにいただきます
                mov ebx,[esi]      ;転送先からゲット

                and eax,0x00ffffff //転送先にある 上位8ビットを壊さないように
                or eax,ebx       // Or 処理
                mov [esi],eax     //書き込み

                add edi,3
                add esi,3
            dec ecx
            jnz  LOOP2       ;LOOP2終了 ECX解放

            pop esi
            pop edi

            add edi,AddPitch1
            add esi,AddPitch2
        dec edx             ;LOOP1終了 EDX解放
        jnz  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
}

/*****************************************************************/
//通過無視の絵画
/*****************************************************************/
BigClass::DirectDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2)
{
//    int y;
//    int copysize;
//    int copysizemod;

	int AddPitch1,AddPitch2;
	BYTE *data1,*data2;

    int sw,sh,ew,eh;

 
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
/*
    //簡易終了位置クリッピング
    int sw,sh,ew,eh,p;
    p = bmd2->w - rx2 ;
    if (p < rw1)    ew = p;
    else            ew = rw1;
    if (rx2 < 0 ) sw = abs(rx2) , ew = ew - sw;
    else          sw = 0;

    p = bmd2->h - ry2 ;
    if (p < rh1)    eh = p;
    else            eh = rh1;
    if (ry2 < 0 ) sh = abs(ry2) , eh = eh - sh;
    else          sh = 0;

    if (ew <= 0 || eh <= 0 ) return;
*/

//    copysize = 3*(ew) ;
//    copysizemod = copysize % 4;
//    copysize = copysize / 4;

	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);
/*
    for (int y = eh ; y >= 0 ;y -- )
    {
        //最強の高速化!? ↓
        memcpy( (data2),(data1),3*(ew) );
		data1+=AddPitch1;
		data2+=AddPitch2;
    }
*/
  

    _asm{
        //できるだけ、 dword 単位で転送して、
        //端数は byte 単位で転送するための計算.
        mov eax,ew    //3*(ew)  X*3 = X<<2 -X
        shl eax,2
        sub eax,ew   //eaxが答えです

        mov ecx,eax   //わり算とあまりが必要なので.. 
        shr ecx,2     //eax / 4 のこと.
        and eax,3     //eax % 4 のこと.

        mov edx,eh
        mov esi,data1 ;転送元
        mov edi,data2 ;転送先
        cld
    LOOP1:              ;ループカウンタに edx を使用中
            push edi
            push esi
            push ecx
            //まとめて転送します
            rep movsd
            mov ecx,eax
            rep movsb

            pop ecx
            pop esi
            pop edi
            add esi,AddPitch1
            add edi,AddPitch2
        dec edx             ;LOOP1終了 EDX解放
        jnz  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);

}




/*****************************************************************/
//反転絵画
/*****************************************************************/
BigClass::RevDraw(BMD bmd1,int rx1,int ry1,int rw1,int rh1)
{
//    int x,y;

	int AddPitch1;
//    BYTE *backupPoint;
	BYTE *data1;

    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd1->w,bmd1->h,rx1,ry1,
						&sw,&sh,&ew,&eh) )			return;
/*
    //簡易終了位置クリッピング
    int sw,sh,ew,eh,p;
    p = bmd1->w - rx1 ;
    if (p < rw1)    ew = p;
    else            ew = rw1;
    if (rx1 < 0 ) sw = abs(rx1) , ew = ew - sw;
    else          sw = 0;

    p = bmd1->h - ry1 ;
    if (p < rh1)    eh = p;
    else            eh = rh1;
    if (ry1 < 0 ) sh = abs(ry1) , eh = eh - sh;
    else          sh = 0;

    if (ew <= 0 || eh <= 0 ) return;
*/
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
/*
    AddPitch1 = (bmd1->w * 3);
	data1= (bmd1->bm+(rx1+sw)*3+(ry1+sh)*AddPitch1 );
*/

    _asm{
        mov edx,eh
        mov edi,data1 ;転送元
        mov esi,AddPitch1 ;esiがあまっているので使う (^^;;
    LOOP1:              ;ループカウンタに edx を使用中
            push edi   ;データ待避
            mov ecx,ew
        LOOP2:           ;ループカウンタに ecx を使用中


                mov eax,[edi] ;いっきにいただきます
				mov ebx,eax   ;待避だよーん
				not eax       ;反転
                and eax,0x00ffffff ;ゼロってことは転送しなくてもよい
                and ebx,0xff000000
                or  ebx,eax
                mov [edi],ebx

                add edi,3
            dec ecx
            jnz  LOOP2       ;LOOP2終了 ECX解放

            pop edi ;データ復帰

//            add edi,AddPitch1 ;Y軸要素をプラス
            add edi,esi ;Y軸要素をプラス
        dec edx             ;LOOP1終了 EDX解放
        jnz  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd1);
/*
    for (y = 0 ; y < eh ;y ++ )
    {
        backupPoint = data1; //保存
        for (x = 0 ; x < ew ;x ++ )
        {
            *(data1) =  ~(*(data1)); //反転絵画
            *(data1+1) =  ~(*(data1+1)); //反転絵画
            *(data1+2) =  ~(*(data1+2)); //反転絵画
            data1 += 3;
        }
        data1 = backupPoint; //復帰
        data1 += AddPitch1;
    }
*/
}



/*****************************************************************/
//通過色ありで絵画
/*****************************************************************/
BigClass::Draw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2)
{
//    int x,y;

	int AddPitch1,AddPitch2;
//	BYTE *BackupPoint1,*BackupPoint2;
	BYTE *data1,*data2;

    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
/*
    //簡易終了位置クリッピング
    p = bmd2->w - rx2 ;
    if (p < rw1)    ew = p;
    else            ew = rw1;
    if (rx2 < 0 ) sw = abs(rx2) , ew = ew - sw;
    else          sw = 0;

    p = bmd2->h - ry2 ;
    if (p < rh1)    eh = p;
    else            eh = rh1;
    if (ry2 < 0 ) sh = abs(ry2) , eh = eh - sh;
    else          sh = 0;

    if (ew <= 0 || eh <= 0 ) return;
*/
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);
/*
    AddPitch1 = (bmd1->w * 3);
    AddPitch2 = (bmd2->w * 3);
	data1= (bmd1->bm+(rx1+sw)*3+(ry1+sh)*AddPitch1 );
	data2= (bmd2->bm+(rx2+sw)*3+(ry2+sh)*AddPitch2 );
*/
    _asm{
        mov edx,eh
        mov edi,data1 ;転送
        mov esi,data2 ;転送
    LOOP1:              ;ループカウンタに edx を使用中
//            push data1   ;データ待避
//            push data2
            push edi
            push esi
            
            mov ecx,ew
        LOOP2:           ;ループカウンタに ecx を使用中

//                mov edi,data1 ;転送

                mov eax,[edi] ;いっきにいただきます

                and eax,0x00ffffff ;ゼロってことは転送しなくてもよい
                jz NON_PROC        ;andはフラグが変化するのでcmp抜き 

                ;ここにきたということは透明色ではないので転送
//                mov esi,data2 ;転送

                mov ebx,[esi]      ;あまりをくりぬく
                and ebx,0xff000000
                or  ebx,eax

                mov [esi],ebx

            NON_PROC: ;透明色だったりしたらここにくるかも

//              add data1,3
//              add data2,3
                add edi,3
                add esi,3
            dec ecx
            jnz  LOOP2       ;LOOP2終了 ECX解放

            pop esi
            pop edi
//            pop data2 ;データ復帰
//            pop data1

//            mov ebx,AddPitch1 ;Y軸要素をプラス
//            mov ecx,AddPitch2
//            add data1,ebx
//            add data2,ecx
            add edi,AddPitch1
            add esi,AddPitch2
        dec edx             ;LOOP1終了 EDX解放
        jnz  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
/*
    for (y = 0 ; y < eh ;y ++ )
    {
        BackupPoint1 = data1;
        BackupPoint2 = data2;
        for (x = 0 ; x < ew ;x ++ )
        {
            if (   ( ((DWORD)*((DWORD*)(data1))) & 0xffffff00 )  )
            {
//				*(data2) = *(data1);
//				*(data2+1) = *(data1+1);
//				*(data2+2) = *(data1+2);
				memcpy(data2,data1,3);
            }
            data1+=3;
            data2+=3;
        }
        data1 = BackupPoint1 ;
        data2 = BackupPoint2 ;
        data1 += AddPitch1 ;
        data2 += AddPitch2 ;
    }
*/
}

/*****************************************************************/
//クリア
/*****************************************************************/
BigClass::Cls(BMD bmd,BYTE clear)
{
	if ( !CommDraw->GraphicsLock(bmd) )	return;
	BYTE *dest = bmd->bm;
	int count = (bmd->w * bmd->h);
	count = count + count + count;	//count = (bmd->w * bmd->h) * 3 の掛け算は足し算で.

	int c = clear;
	_asm
	{
		mov edi,dest
		mov edx,count
		//eax に c c c c と配置してあげます.
		mov ebx,c
		mov eax,ebx	//初期は移動で転送ねっ
		shl ebx,8	//4ずらして
		or  eax,ebx //結合
		shl ebx,8	//以下同文
		or  eax,ebx
		shl ebx,8
		or  eax,ebx
		//ここで eax は c c c c となっているはずです.

		//では、転送の始まりです.
		cld	//正方向転送
		mov ecx,edi	//4 で割り切れるかどうか調べます.
		and ecx,3	// dest のアドレス & 3 
		sub edx,ecx	//転送するバイト数からその分を引く
		js	END_OF_RTN
		
		rep stosb
		//現在は 4 で割り切れるアドレスにいます.
		//ここから、count / 4 の値を DWORD 単位で転送します.
		mov ecx,edx
		mov ebx,ecx
		shr ecx,2	// / 2 のことです.
		and ebx,3	// & 3 のことです.
		rep stosd	// DWORD 転送
		mov ecx,ebx
		rep stosb	//BYTE転送
	END_OF_RTN:
	}
 
	CommDraw->GraphicsUnLock(bmd);
}

/*****************************************************************/
//線を描く
/*****************************************************************/
BigClass::Line(BMD bmd1,int rx1,int ry1,int rx2,int ry2,long rgb)
{
	int AddPicth;
	BYTE *data1;
    int w,h;

    w = bmd1->w;
    h = bmd1->h;
    //クリッピング
    if (rx1 < 0) rx1 = 0;
    if (ry1 < 0) rx1 = 0;
    if (rx1 > w) rx1 = w;
    if (ry1 > h) rx1 = h;
    if (rx2 < 0) rx2 = 0;
    if (ry2 < 0) rx2 = 0;
    if (rx2 > w) rx2 = w;
    if (ry2 > h) rx2 = h;

	if ( !CommDraw->GraphicsLock(bmd1) )	return;
    data1 = bmd1->bm;
    AddPicth = bmd1->w * 3;

    int dx,dy ,sx,sy,x,y;
    int i,e;

    dx = abs(rx2 - rx1);                   // 変化量 X
    dy = abs(ry2 - ry1);                   // 変化量 Y
    sx = (rx2 - rx1) >= 0 ? 1 : -1;        // 正:1 負:-1 零:0
    sy = (ry2 - ry1) >= 0 ? 1 : -1;        // 正:1 負:-1 零:0
    
    x = rx1;
    y = ry1;

    if (dy < dx)
    {                    // 点線にしない為
        //X 方向 を 増加する場合
        e = -dx;
        for( i = 0 ; i < dx ; i++)
        {
            //PSet (x * tx, y * ty), QBColor(c)
            PSet(bmd1  , x , y , rgb );
            x = x + sx;                 // X 方向
            e = e + 2 * dy;             // DDA による補間
            if (e >= 0) 
            {
                y = y + sy ;            // Y方向
                e = e - 2 * dx;         // DDA による補間
            }
        }
    }
    else
    {
        // Y 方向 を 増加する場合
        e = -dy;
        for( i = 0 ; i < dy ; i ++)
        {
            //PSet (x * tx, y * ty), QBColor(c)
            PSet(bmd1  , x , y , rgb );
            y = y + sy;                  // Y 方向
            e = e + 2 * dx;              // DDA による補間
            if (e >= 0) 
            {
                x = x + sx ;             // X 方向
                e = e - 2 * dy;          // DDA による補間
            }
        }
    }

	CommDraw->GraphicsUnLock(bmd1);
}

/*****************************************************************/
//四角を描く
/*****************************************************************/
BigClass::Box(BMD bmd1,int rx1,int ry1,int rx2,int ry2,long rgb)
{
    int AddPitch1;
	BYTE *backupdata;
	BYTE *data1;
    int w,h;
    int ew,eh;
    int x,y;

    w = bmd1->w;
    h = bmd1->h;
    rx1--; ry2 ++;
    //クリッピング
    if (rx1 < 0) rx1 = 0;
    if (ry1 < 0) ry1 = 0;
    if (rx1 > w) rx1 = w;
    if (ry1 > h) ry1 = h;
    if (rx2 < 0) rx2 = rx1;
    if (ry2 < 0) ry2 = ry1;
    if (rx2 > w) rx2 = w;
    if (ry2 > h) ry2 = h;

	if ( !CommDraw->GraphicsLock(bmd1) )	return;
    AddPitch1 = (w * 3);
	data1= (bmd1->bm+(rx1*3)+(ry1*AddPitch1) );
//    rgb = (rgb << 8); //あらかじめシフトしておく
    ew = abs(rx2 - rx1); eh = abs(ry2 - ry1);

    for (y = 0 ; y < eh ; y ++)
    {
        backupdata = data1;
        for (x = 0 ; x < ew ; x ++)
        { 
//            PSet(bmd1,x+rx1,y+ry1,rgb);
			DirectPSet(data1,rgb);
            data1+=3;
        }
        data1 = backupdata;
        data1 += AddPitch1;
    }
	CommDraw->GraphicsUnLock(bmd1);
}

/*****************************************************************/
//円を描く
/*****************************************************************/
BigClass::Circle(BMD bmd1,int rx1,int ry1,int rr1,long rgb)
{

    int r;
    int x,y;

	if ( !CommDraw->GraphicsLock(bmd1) )	return;
    for (r = 0 ; r < 1024 ; r++)
    {
        x = (int)(LTBSin1024[r]*rr1 +rx1);
        y = (int)(LTBCos1024[r]*rr1 +ry1);
        //クリッピング (^^;;
        if (x >= 0 && x <= bmd1->w && y >= 0 && y <= bmd1->h)
        {
            PSet(bmd1,x,y,rgb);
        }
    }
	CommDraw->GraphicsUnLock(bmd1);
}


/*****************************************************************/
//左右上下反転
/*****************************************************************/
BigClass::MillorDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2,bool lr,bool ud)
{
    int x,y;

	int AddPitch1,AddPitch2;
	BYTE *BackupPoint1,*BackupPoint2;
	BYTE *data1,*data2;
    int countX; // X に1進んだときのアドレスの移動量
    int lr_millor_start_end_x;//左右反転の場合は始まりは端から

    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
/*
    //簡易終了位置クリッピング
    int sw,sh,ew,eh,p;
    rh1 --; rw1 --;
    p = bmd2->w - rx2 ;
    if (p < rw1)    ew = p;
    else            ew = rw1;
    if (rx2 < 0 ) sw = abs(rx2) , ew = ew - sw;
    else          sw = 0;

    p = bmd2->h - ry2 ;
    if (p < rh1)    eh = p;
    else            eh = rh1;
    if (ry2 < 0 ) sh = abs(ry2) , eh = eh - sh;
    else          sh = 0;

    if (ew <= 0 || eh <= 0 ) return;
*/
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);
/*
    AddPitch1 = (bmd1->w * 3);
    AddPitch2 = (bmd2->w * 3);
	data1= (bmd1->bm+(rx1+sw)*3+(ry1+sh)*AddPitch1 );
	data2= (bmd2->bm+(rx2+sw)*3+(ry2+sh)*AddPitch2 );
*/

    if (lr)
    {
        countX = -3 ;
        lr_millor_start_end_x = AddPitch1-3;
    }
    else
    {
        countX = 3;
        lr_millor_start_end_x = 0; 
    }
    if (ud)
    { //上下反転は、画像アドレスを最下層のYに移動させてからすーたと
        data1 += eh * AddPitch1; 
        //上下反転のために符号反転
        AddPitch1 = -AddPitch1;
    }

    for (y = 0 ; y <= eh ;y ++ )
    {
        BackupPoint1 = data1;
        BackupPoint2 = data2;
        data1 += lr_millor_start_end_x;
        for (x = 0 ; x <= ew ;x ++ )
        {
			*(data2) = *(data1);
            *(data2 +1) = *(data1+1);
			*(data2 +2) = *(data1+2);
            data1 += countX ;
            data2 += 3 ;
        }
        data1 = BackupPoint1 ;
        data2 = BackupPoint2 ;
        data1 += AddPitch1 ;
        data2 += AddPitch2 ;
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);

}

/*****************************************************************/
//指定した範囲にモザイクをかける
/*****************************************************************/
BigClass::MosaicDraw(BMD bmd1,int rx1,int ry1,int rw1,int rh1,int mw,int mh)
{
//    int x,y;
//    int wx,wy;
    int mwskip,mhskip;

	int AddPitch1;
//    BYTE *backupPoint;
//    BYTE *mbackupPoint;
//    BYTE *workbackupPoint;
	BYTE *data1;
//    BYTE R,G,B;

    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd1->w,bmd1->h,rx1,ry1,
						&sw,&sh,&ew,&eh) )			return;
/*
    //簡易終了位置クリッピング
    int sw,sh,ew,eh,p;
    rh1 --; rw1 --;
    p = bmd1->w - rx1 ;
    if (p < rw1)    ew = p;
    else            ew = rw1;
    if (rx1 < 0 ) sw = abs(rx1) , ew = ew - sw;
    else          sw = 0;

    p = bmd1->h - ry1 ;
    if (p < rh1)    eh = p;
    else            eh = rh1;
    if (ry1 < 0 ) sh = abs(ry1) , eh = eh - sh;
    else          sh = 0;

    if (ew <= 0 || eh <= 0 ) return;
*/

	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
/*
    AddPitch1 = (bmd1->w * 3);
	data1= (bmd1->bm+(rx1+sw)*3+(ry1+sh)*AddPitch1 );
*/
    mwskip = mw * 3;
    mhskip = mh * AddPitch1;
    int mwstep ,mhstep;


    _asm{
        mov edx,0
        mov edi,data1 ;転送
    LOOP1:              ;ループカウンタに edx を使用中
//            push data1   ;データ待避
            push edi   ;データ待避
            
            mov ecx,0
            xor bx,bx    ;中で作業用に使います LOOP2のことね
        LOOP2:           ;ループカウンタに ecx を使用中

                ;範囲オーバーは許さない
//                if ( (mw + x) >= ew)     mwstep = (mw+x)-ew;
//                else                     mwstep = mw;
                mov eax,mw
                add eax,ecx  ;ecx は xのことです
                cmp eax,ew
                jb ELSE1
                    sub eax,ew
                    jmp ENDIF1
                ELSE1:
                    mov eax,mw
            ENDIF1:
                mov mwstep,eax

                ;ここより第2のif文です
//                if ( (mh + y) >= eh)     mhstep = (mh+y)-eh;
//                else                     mhstep = mh;
                mov eax,mh
                add eax,edx  ;edx は yのことです
                cmp eax,eh
                jb ELSE2
                    sub eax,eh
                    jmp ENDIF2
                ELSE2:
                    mov eax,mh
            ENDIF2:
                mov mhstep,eax

                ;範囲オーバーチェック終了

//                mov edi,data1 ;転送元
                mov eax,[edi] ;いっきにいただきます
                and eax,0x00ffffff ;不要なデータの切り落とし

                ;ループカウンターのちょっと拝借
                push edx
                push ecx
//                push data1
                push edi


                //eax の中身を書きまくります
                //内部ループスタート
                mov edx,0
                LOOP3:              ;ループカウンタに edx を使用中
//                    push data1   ;データ待避
                    push edi   ;データ待避
            
                    mov ecx,0
                    LOOP4:           ;ループカウンタに ecx を使用中

                        ;以前に用意した eaxの内容を書きまくる
//                        mov edi,data1 ;転送
                        mov ebx,[edi]      ;あまりをくりぬく
                        and ebx,0xff000000
                        or  ebx,eax
                        mov [edi],ebx

//                        add data1,3
                        add edi,3
                    inc ecx
                    cmp ecx,mwstep
                    jb  LOOP4       ;LOOP2終了 ECX解放

//                    pop data1         ;データを復帰
                    pop edi         ;データを復帰

//                    mov ebx,AddPitch1 ;Y軸要素をプラス
//                    add data1,ebx
                    add edi,AddPitch1
                inc edx             ;LOOP1終了 EDX解放
                cmp edx,mhstep
                jb  LOOP3
                ;内部ループ終了
                ;ループカウンターのちょっと拝借を戻す

//                pop data1
                pop edi
                pop ecx
                pop edx

//                mov eax,mwskip
//                add data1,eax
                add edi,mwskip
            add ecx,mw
            cmp ecx,ew
            jb  LOOP2       ;LOOP2終了 ECX解放

//            pop data1 ;データ復帰
            pop edi ;データ復帰

//            mov eax,mh
//            mov ebx,mhskip ;Y軸要素をプラス
//            add data1,ebx
            add edi,mhskip
        add edx,mh             ;LOOP1終了 EDX解放
        cmp edx,eh
        jb  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd1);
/*
    for (y = 0 ; y <= eh ;y +=mh )
    {
        backupPoint = data1; //保存
        for (x = 0 ; x <= ew ;x +=mw )
        {
            R =*(data1);
            G =*(data1+1);
            B =*(data1+2);
            mbackupPoint = data1; //保存
            if ( (mw + x) >= ew)     mwstep = (mw+x)-ew;
            else                     mwstep = mw;
            if ( (mh + y) >= eh)     mhstep = (mh+y)-eh;
            else                     mhstep = mh;
            //モザイク処理ぃぃぃ
            for (wy = 0 ; wy < mhstep ;wy ++ )
            {
                workbackupPoint = data1; //保存
                for (wx = 0 ; wx < mwstep ;wx ++ )
                {
                    *(data1) =   R; //
                    *(data1+1) = G; //
                    *(data1+2) = B; //
                    data1 += 3;
                }
                data1 = workbackupPoint; //復帰
                data1 += AddPitch1;
            }

            data1 = mbackupPoint; //復帰
            data1 += mwskip ;
        }
        data1 = backupPoint; //復帰
        data1 += mhskip;
    }
*/
}






/*****************************************************************/
//フィルタ 指定した範囲にフィルタをかける
/*****************************************************************/
BigClass::FilterDraw(BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      int R,int G,int B)
{
	int AddPitch1;
	BYTE *data1;

    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd1->w,bmd1->h,rx1,ry1,
						&sw,&sh,&ew,&eh) )			return;
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);

    int RAdd,GAdd,BAdd;
    RAdd = (R<<16);
    GAdd = (G<<8 );
    BAdd = (B    );

    _asm{

        mov edx,eh
        mov edi,data1 ;転送
    LOOP1:              ;ループカウンタに edx を使用中
            push edi
            
            mov ecx,ew
        LOOP2:           ;ループカウンタに ecx を使用中

                mov eax,[edi] ;いっきにいただきます
                mov esi,eax //esi が台帳
                and eax,0xff000000 //ここからeax にどんどん足し込んでいく.

                //Rの処理
                mov ebx,esi
                and ebx,0x00ff0000
                add ebx,RAdd
                js R_END_STEP      //マイナスにつっこでいるのでなにもしない(初期が0なので 0 をわざわざ代入する必要なし)

                test ebx,0xff00ffff
                jz R_WRITE_STEP      //書き込み準備
                    mov ebx,0x00ff0000 //丸める
            R_WRITE_STEP:
                or eax,ebx // R の書き込む
            R_END_STEP: //Rの処理の終了

                //Gの処理
                mov ebx,esi
                and ebx,0x0000ff00
                add ebx,GAdd
                js G_END_STEP      //マイナスにつっこでいるのでなにもしない(初期が0なので 0 をわざわざ代入する必要なし)

                test ebx,0xffff00ff
                jz G_WRITE_STEP      //書き込み準備
                    mov ebx,0x0000ff00 //丸める
            G_WRITE_STEP:
                or eax,ebx // G の書き込む
            G_END_STEP: //Rの処理の終了

                //Bの処理
                mov ebx,esi
                and ebx,0x000000ff
                add ebx,BAdd
                js B_END_STEP      //マイナスにつっこでいるのでなにもしない(初期が0なので 0 をわざわざ代入する必要なし)

                test ebx,0xffffff00
                jz B_WRITE_STEP      //書き込み準備
                    mov ebx,0x000000ff //丸める
            B_WRITE_STEP:
                or eax,ebx // G の書き込む
            B_END_STEP: //Rの処理の終了

                //メモリに書き戻す
                mov [edi],eax

                add edi,3
            dec ecx
            jnz  LOOP2       ;LOOP2終了 ECX解放

            pop edi
            add edi,AddPitch1
        dec edx             ;LOOP1終了 EDX解放
        jnz  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd1);

}

/*****************************************************************/
//シフト絵画 青がシフトの要素です. (EL は赤だけどね )
// また、 S は、 0 〜 31 の値をとります.
// それ以上はだめ
/*****************************************************************/
BigClass::ShiftDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2,int S)
{

	int AddPitch1,AddPitch2;
	BYTE *data1,*data2;

    int sw,sh,ew,eh;
    //簡易クリッピング
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);
    _asm{
        mov ebx,eh     // 内部でかけ算を使うために ebx にしている
                       //紛らわしいが、ゆるしてちょ
        mov edi,data1 ;転送
        mov esi,data2 ;転送
    LOOP1:              ;ループカウンタに edx を使用中
            push edi
            push esi
            
            mov ecx,ew
        LOOP2:           ;ループカウンタに ecx を使用中

                mov eax,[edi] ;いっきにいただきます
                and eax,0x000000ff //不要な部分を殺す
                jz END_STEP        //黒は無視

                sub eax,S     //シフト値を減算する.
                js  END_STEP       //負の数だったら無視

                cmp eax,ebx  //eax - eh(の残り)
                ja  END_STEP // > だったら　無視

                mul AddPitch2
                add eax,esi     // eax の部分ずらす

                mov edx,[eax]      //絵画部分を取得.
                and edx,0x00ffffff //不要な部分を落とす

                mov eax,[esi]      //書き込む部分を取得
                and eax,0xff000000 
                or  eax,edx        //くりぬき合成
                mov [esi],eax      //絵画

            END_STEP:

                add edi,3
                add esi,3
            dec ecx
            jnz  LOOP2       ;LOOP2終了 ECX解放

            pop esi
            pop edi

            add edi,AddPitch1
            add esi,AddPitch2
        dec ebx             ;LOOP1終了 EDX解放
        jnz  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
}

/*****************************************************************/
//回転
/*****************************************************************/
BigClass::RotateDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2,int jikux,int jikuy,Angle seeta)
{
    int x,y;
    int rx,ry;
	int tx,ty;
    int min_x,max_x,min_y,max_y;
	Fixed Sin,Cos;	//サインコサインのテンポラリだにょー
	Fixed RSin,RCos;//サインコサインのテンポラリだにょー

	int AddPitch1,AddPitch2;
	BYTE *BackupPoint2;
	BYTE *data1,*data2;

	//サイン コサインを取得!!
	Sin = FixedLTBSin1024[ __ANGLE(seeta) ];
	Cos = FixedLTBCos1024[ __ANGLE(seeta) ];
	//逆サイン 逆コサインを取得!!
	RSin = FixedLTBSin1024[__ANGLE_REV(seeta)];
	RCos = FixedLTBCos1024[__ANGLE_REV(seeta)];
    //テクスチャの各頂点を jiku を中心に回転させますぅ.
	//これによって、最大、最低の転送範囲を取得しますぅ.
	/*
		min
		------------------------
        |                      |
        |                      |
        |          jiku        |
        |                      |
        |                      |
        |                      |
		------------------------
								max
    */
	//左上
    tx = x = rx1 - jikux;
    ty = y = ry1 - jikuy;
	rx = FI(tx*Cos-ty*Sin);
	ry = FI(tx*Sin+ty*Cos);
    min_x = max_x = rx ;
    min_y = max_y = ry ;
	//右上
    tx = x + rw1;
    ty = y ;
	rx = FI(tx*Cos-ty*Sin);
	ry = FI(tx*Sin+ty*Cos);
    if (min_x > rx) min_x = rx;
    if (max_x < rx) max_x = rx;
    if (min_y > ry) min_y = ry;
    if (max_y < ry) max_y = ry;
	//左下
    tx = x ;
    ty = y + rh1;
	rx = FI(tx*Cos-ty*Sin);
	ry = FI(tx*Sin+ty*Cos);
    if (min_x > rx) min_x = rx;
    if (max_x < rx) max_x = rx;
    if (min_y > ry) min_y = ry;
    if (max_y < ry) max_y = ry;
	//右下
    tx = x + rw1;
    ty = y + rh1;
	rx = FI(tx*Cos-ty*Sin);
	ry = FI(tx*Sin+ty*Cos);
    if (min_x > rx) min_x = rx;
    if (max_x < rx) max_x = rx;
    if (min_y > ry) min_y = ry;
    if (max_y < ry) max_y = ry;
    //min から初めて　max までデータを転送します.
    //でも、その前に　受け取る側の開始アドレスを求めます.
    //min max シリーズは軸座標です.
    //それを加えて(ほどんど　マイナスなので引き算だけど)転送開始場所もとめ.
    x = rx2 + min_x;    
    y = ry2 + min_y;    
	max_x ++ ; max_y++;

	//クリッピング
	if (x < 0)
	{		x = 0;		min_x = -rx2;	}
	//クリッピング
	if (y < 0)
	{		y = 0;		min_y = -ry2;	}
	//クリッピング
	if (x+(max_x - min_x) > bmd2->w)
	{		max_x = bmd2->w - x + min_x - 1;	}
	if (y+(max_y - min_y) > bmd2->h)
	{		max_y = bmd2->h - y + min_y - 1;	}
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	//転送開始アドレス取得
	data1 = SeekData(bmd1,rx1,ry1, 0,0,&AddPitch1);
	data2 = SeekData(bmd2,x,y, 0,0,&AddPitch2);

	//デバッグ用(転送範囲を白いボックスで塗りつぶす)
//	Box(Sprite,rx2 + min_x,ry2 + min_y,rx2 + max_x,ry2 + max_y,0xffffff);
	Fixed Xx,Xy;
	Fixed Yx,Yy;
	//初期値を求める.
	Yx = (min_x * RCos)-(min_y * RSin);
	Yy = (min_x * RSin)+(min_y * RCos);
	//テクスチャを横断して画面に水平に貼り付けます.
	//こうすることによって、付加がぐびびびびびびひびびびびびびびっと、減ります.
	//科学の勝利です.(意味なし)
	/*

		Texter             Screen
	|---------------|      |-----------------------|
    |  -^           |      |   ------------------> |
    | |             |  ->  |   ------------------> |
    |-              |      |   ------------------> |
    |---------------|      |                       |
     斜めに横断            |                       |
                           -------------------------
						   まっすぐ絵画
    */
	//転送開始
    for (y = min_y ; y <= max_y ;y ++ )
    {
		Xx = Yx;
		Xy = Yy;
        BackupPoint2 = data2;
        for (x = min_x ; x <= max_x ;x ++ )
        {
			//回転.
			rx = FI(Xx) +jikux;
			ry = FI(Xy) +jikuy;
    		//クリッピング処理
			if (rx>=0 && rx<rw1 && ry>=0 && ry<rh1 )
            {
		    //転送
				DirectPSet(data2 , data1+(rx+rx+rx)+ry*AddPitch1);
            }
			Xx += RCos;
			Xy += RSin;
            data2 += 3 ;
        }
		Yx -= RSin;
		Yy += RCos;
        data2 = BackupPoint2 ;
        data2 += AddPitch2 ;
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
}


/*****************************************************************/
//グレイスケールで絵画
/*****************************************************************/
BigClass::GrayScaleDraw(const BMD bmd1,int rx1,int ry1,int rw1,int rh1,
                      BMD bmd2,int rx2,int ry2)
{
	int AddPitch1,AddPitch2;
	BYTE *data1,*data2;

    int sw,sh,ew,eh;

 
	if (!EasyClipingEx(bmd1,&rx1,&ry1,&rw1,&rh1,
						bmd2->w,bmd2->h,rx2,ry2,
						&sw,&sh,&ew,&eh) )			return;
	if ( !CommDraw->GraphicsLock(bmd1) )	return;
	if ( !CommDraw->GraphicsLock(bmd2) )	return;
	data1 = SeekData(bmd1,rx1,ry1, sw,sh,&AddPitch1);
	data2 = SeekData(bmd2,rx2,ry2, sw,sh,&AddPitch2);
	/*
	*	RGB to YIQ カラー	(C MAGAZIN 2000-2月号 アルゴリズムラボより)
	*
	*  Y     (0.299   0.587   0.114)(R)
	*  I  =  (0.596  -0.274  -0.322)(G)
	*  Q     (0.211  -0.522   0.322)(B)
	*
	*  で、グレースケールにするには、 Y だけを求めればよいそうなので(笑)
	*  Y = 0.299 * R + 0.587 * B + 0.114 * G をやります.
	*  このとき、浮動小数点がでるといやなので、全体を * 256 倍します.
	*  Y = (77 * R + 28 * B  + 151 * G ) / 256 
	*  最後の 256 は、>> 8 で代用するとして(笑)  
	*  この計算式によって Y 成分を求めて、グレースケールにします.
	*/
    _asm{
        mov edx,eh
        mov edi,data1 ;転送
        mov esi,data2 ;転送
    LOOP1:              ;ループカウンタに edx を使用中
            push edi
            push esi
			push edx	;ループカウンター edx をちょっと拝借します.      
            mov ecx,ew
        LOOP2:           ;ループカウンタに ecx を使用中

                mov eax,[edi] ;いっきにいただきます
				//現在自由に使えるのは、 eax ebx edx の二つだけです. (厳しいにょー)
				// eax は、(元)オリジナルの保存.
				// ebx は、ワークエリア.
				// edx は、計算結果(Y要素)をためてきます.

				//B を求めます.
				mov ebx,eax				//とりあえず、ebx (計算領域に移動.)
				and ebx,0x000000ff		//不要な部分を切り落とします.
				imul edx,ebx,28				//Bの計算.//edx にどんどん要素をためていきます.

				//Gを求めます.
				mov ebx,eax				//とりあえず、ebx (計算領域に移動.)
				and ebx,0x0000ff00		//不要な部分を切り落とします.
				shr ebx,8
				imul ebx,151			//Gの計算.
				add  edx,ebx			//edx にどんどん要素をためていきます.
				//Rを求めます.
				mov ebx,eax				//とりあえず、ebx (計算領域に移動.)
				and ebx,0x00ff0000		//不要な部分を切り落とします.
				shr ebx,16
				imul ebx,77				//Rの計算.
				add  edx,ebx			//edx にどんどん要素をためていきます.

				shr  edx,8				//最後に / 256 します.
				mov  eax,edx
				shl  eax,8
				or   edx,eax
				shl  eax,8
				or   edx,eax

                and edx,0x00ffffff ;要らないところをくり貫く.
                mov ebx,[esi]       //先からゲット.
                and ebx,0xff000000	//先のところで書いてはいけないところをクリア.
                or  ebx,edx			//結合
                mov [esi],ebx		//書き込み

                add edi,3
                add esi,3
            dec ecx
            jnz  LOOP2       ;LOOP2終了 ECX解放

			pop edx			 ;ループカウンター edx を拝借していたのをもとに戻します.
            pop esi
            pop edi

            add edi,AddPitch1
            add esi,AddPitch2
        dec edx             ;LOOP1終了 EDX解放
        jnz  LOOP1
    }
	CommDraw->GraphicsUnLock(bmd2);
	CommDraw->GraphicsUnLock(bmd1);
}

#include <./Lim3D/rti_Lim3DModel.h>

#include <./Lim3D/rti_Lim3DMaster.h>

//コンストラクタ
BigClass::TLim3DModel()
{
	m_Vec		= new TLim3DVecCaretaker;		//頂点情報集積クラス
	m_Polygon	= new TLim3DPolygonCaretaker;	//ポリゴン情報集積クラス
	m_Make		= new TLim3DMake;				//モデル親子関係
	m_Point		= new TLim3DPoint;				//位置
	m_Breaking		= false;					//自分が崩壊している.

	m_Vec->Mount_form_Model(this);				//頂点関係に自分が親だと伝える.
	m_Make->Mount_form_Model(this);				//モデル親子関係に自分が親だと伝える.
	m_Polygon->Mount_form_Model(this);			//ポリゴン管理に自分が親だと伝える.
}

//デストラクタ
BigClass::~TLim3DModel()
{
	m_Point->Release();
	m_Polygon->Release();
	m_Vec->Release();
	m_Make->Release();
}

//ガページコレクションより削除.
BigClass::Del(TLim3DModel* Model)
{
	//現在自分が崩壊にあるなら....
	if (m_Breaking == true) return true;	//自分が崩壊しているので子どものことは無視.
	//ガページコレクションより探し出し削除.
	m_Make->Del( Model );

	return true;
}

//親モデルの取得
BigClass::GetParenceModel()
{
	return  ((TLim3DMake*)(m_Parence))->GetParenceModel();
}

/*****************/
//ユーザーのための高レベルメソッド.
/*****************/
//このモデル以下のモデルの絵画.
BigClass::Drawing()
{
	ClasOnly();
	DrawOnly();
}

//このモデル以下のモデルの絵画.
BigClass::Drawing(TMatrix * Ma)
{
	ClasOnly(Ma);
	DrawOnly();
}

//破棄.
BigClass::Release()
{
	//自分が崩壊状態とする.
	m_Breaking = true;
	//親クラス.
	TLim3DModel*	theModel = GetParenceModel();
	//親に削除を伝える.
	if (theModel == NULL)
BigClass::GetModelCaretaker())->Del(this);
	else
		theModel->Del(this);
	delete this;
}

//頂点情報の設定.
BigClass::SetVec(XYZFixed* _c ,	int Many , bool SizeNotChange)
{
	return m_Vec->Set(_c,Many,SizeNotChange);
}

//頂点情報の追加.
BigClass::AddVec(XYZFixed* _c ,	int Many , bool SizeNotChange )
{
	return m_Vec->Add(_c,Many,SizeNotChange);
}

//すべての頂点の破棄
BigClass::ClearVec()
{
	m_Vec->Clear();
}
//ポリゴン情報の設定.
BigClass::NewPolygon()
{
	return m_Polygon->New();
}
//モデルに存在するすべてのポリゴンの破棄.
BigClass::ClearPolygon()
{
	m_Polygon->Clear();
}
//ポリゴン検索開始
BigClass::FindFirstPolygon()
{
	return m_Polygon->FindFirst();
}
//ポリゴン検索続行.
BigClass::FindNextPolygon()
{
	return m_Polygon->FindNext();
}
//モデルの回転角度を指定.
BigClass::SetRotate(Angle x,Angle y,Angle z)
{
	m_Point->SetAngleX(x);
	m_Point->SetAngleY(y);
	m_Point->SetAngleZ(z);
}
//モデルの場所を指定.
BigClass::SetPos(Fixed x,Fixed y,Fixed z)
{
	m_Point->SetPosX(x);
	m_Point->SetPosY(y);
	m_Point->SetPosZ(z);
}
//モデルの回転角度を取得.
BigClass::GetRotate(Angle *x,Angle *y,Angle *z)
{
	*x = m_Point->GetAngleX();
	*y = m_Point->GetAngleY();
	*z = m_Point->GetAngleZ();
}
//モデルの場所を取得.
BigClass::GetPos(Fixed *x,Fixed *y,Fixed *z)
{
	*x = m_Point->GetPosX();
	*y = m_Point->GetPosY();
	*z = m_Point->GetPosZ();
}
//モデルの回転角度を増やす.
BigClass::AddRotate(int x,int y,int z)
{
	m_Point->SetAngleX(m_Point->GetAngleX() + x);
	m_Point->SetAngleY(m_Point->GetAngleY() + y);
	m_Point->SetAngleZ(m_Point->GetAngleZ() + z);
}
//モデルの場所を移動する.
BigClass::AddPos(Fixed x,Fixed y,Fixed z)
{
	m_Point->SetPosX(m_Point->GetPosX() + x);
	m_Point->SetPosY(m_Point->GetPosY() + y);
	m_Point->SetPosZ(m_Point->GetPosZ() + z);
}
//子モデルを作成する.
BigClass::NewModel()
{
	return m_Make->New();
}
//すべての子モデルを削除
BigClass::ClearModel()
{
	m_Make->Clear();
}
//モデル検索開始
BigClass::FindFirstModel()
{
	return m_Make->FindFirst();
}
//モデル検索続行.
BigClass::FindNextModel()
{
	return m_Make->FindNext();
}

//重複頂点の切り離し(これ危険あるねー)
BigClass::Optimize()
{
	//頂点情報クラスへのベタアクセス
	TLim3DVecCaretaker*		theVec = GetVecCaretaker();
	//ポリゴン情報クラスへのベタアクセス
	TLim3DPolygonCaretaker*	thePoly = GetPolygonCaretaker();

	//格納されしデータ.
	VecWorldEye* theSrc  = theVec->GetStart();
	//すべてのデータの数.
	int theEnd = theVec->GetCount();
	//念のため、現在データがあるのかどうかチェック.
	if (theEnd <= 1) return ;
	//ループカウンター.
	int			 theI , theL ;
	//オリジナルデータを格納するバッファ.
	XYZFixed* theOrignalDataTemp = NULL;
	//重複していたら true を代入するフラグ.
	bool*     theDuplicationBuffer = NULL;

	try
	{
		//オリジナルデータを格納するバッファ.
		theOrignalDataTemp = new XYZFixed[ theEnd ];
		//重複していたら true を代入するフラグ.
		theDuplicationBuffer = new bool[ theEnd ];
		//念のため確保できたかチェック. 
		if ( theOrignalDataTemp == NULL || theDuplicationBuffer == NULL) throw ;
		//重複フラグを false でクリアします.
		memset(theDuplicationBuffer , 0 ,sizeof(bool)*theEnd );
		//オリジナルデータの添え字です.
		int			 theOrignalDataNum = 0;
	
		for( theI = 0 ; theI < theEnd ; theI++)
		{//theI に対しての重複データがないかチェックします.
			//重複フラグがたっていたら、そのデータは飛ばします.
			if (theDuplicationBuffer[theI] == true) continue;

			XYZFixed * theSrcVec = &(theSrc[theI].Vec);
			for( theL = theI ; theL < theEnd ; theL++)
			{
				XYZFixed * theDestVec = &(theSrc[theL].Vec);
				if ( theSrcVec->x == theDestVec->x && 
					 theSrcVec->y == theDestVec->y && 
					 theSrcVec->z == theDestVec->z )
				{//この TheL は、 theI のデータと重複しています.
					//重複フラグを立てます.
					theDuplicationBuffer[theL] = true;
					//この TheL を使用しているポリゴンの Linkデータを theOrignalDataNumに付け替えます.
					//OptimizePolygonLinkChange(theL , theOrignalDataNum);
					OptimizePolygonLinkChange( 
						&(theSrc[theL]) , &(theSrc[theOrignalDataNum]) );
				}
			}
			//オリジナルデータとして記録します.
			theOrignalDataTemp[theOrignalDataNum++] = *theSrcVec;
		}
		//重複していないデータをセット.
		theVec->Set( theOrignalDataTemp , theOrignalDataNum	 , true);
		//DEBUG3("最適化によって %d 頂点が %d になりました",theEnd , theOrignalDataNum);
	}
	catch(...)
	{
	}
	//重複フラグの破棄.
	delete [] theDuplicationBuffer;
	//重複していないデータを破棄.
	delete [] theOrignalDataTemp;
}


/*****************/
//ユーザーのための低レベルメソッド.
/*****************/

//計算のみ(頂点計算)
BigClass::ClasOnly()
{
	//まず、回転行列を作成して、くるくるくるーって感じでワールドへ移行します.
	TMatrix		Mat;			//行列
	//回転行列作成.
	Mat.MakeTrans(m_Point->GetAngleX() , m_Point->GetAngleY() , m_Point->GetAngleZ() ,
					m_Point->GetPosX() , m_Point->GetPosY() , m_Point->GetPosZ());
	//すべての頂点を移動させるぞ!
	VecWorldEye* it  = m_Vec->GetStart();
	VecWorldEye* end = m_Vec->GetEnd();
	for ( ; it != end ; it++)
	{
		//it->World = it->Vec;
		Mat.VectorMul( &(it->World) , &(it->Vec) );
		//これで、 ワールドはもとまりました.

		//次は視点座標に変換します.
BigClass::GetSelectEye())->EyeConbert( &(it->Eye) , &(it->World) );
		//視点座標になりました.
	}
	//子モデルを絵画します.
	TLim3DModel*	theChildModel ;
	for( theChildModel = FindFirstModel()  ;
				theChildModel != NULL ; theChildModel = FindNextModel() )
	{
		theChildModel->Drawing( &Mat );
	}
}

//計算のみ(頂点計算)
BigClass::ClasOnly(TMatrix * inParenceMatrix)
{
	//まず、回転行列を作成して、くるくるくるーって感じでワールドへ移行します.
	TMatrix		Mat;			//行列
	//回転行列作成.
	Mat.MakeTrans(m_Point->GetAngleX() , m_Point->GetAngleY() , m_Point->GetAngleZ() ,
					m_Point->GetPosX() , m_Point->GetPosY() , m_Point->GetPosZ());
	//親の行列を加えます.
	Mat.Synthesis(inParenceMatrix);

	//すべての頂点を移動させるぞ!
	VecWorldEye* it  = m_Vec->GetStart();
	VecWorldEye* end = m_Vec->GetEnd();
	for ( ; it != end ; it++)
	{
		//it->World = it->Vec;
		Mat.VectorMul( &(it->World) , &(it->Vec) );
		//これで、 ワールドはもとまりました.

		//次は視点座標に変換します.
BigClass::GetSelectEye())->EyeConbert( &(it->Eye) , &(it->World) );
		//視点座標になりました.
	}
	//子モデルを絵画します.
	TLim3DModel*	theChildModel ;
	for( theChildModel = FindFirstModel()  ;
				theChildModel != NULL ; theChildModel = FindNextModel() )
	{
		theChildModel->Drawing( &Mat );
	}
}

//絵画のみ(頂点計算がすでにされていることが条件)
BigClass::DrawOnly()
{
	TLim3DPolygon* Poly = m_Polygon->FindFirst();
	if (Poly == NULL)	return ;
	do
	{
		Poly->Draw();		//ポリゴンに絵画命令発行.
	}
	while( Poly = m_Polygon->FindNext() );
}


//頂点情報クラスへのベタアクセス
BigClass::GetVecCaretaker()
{
	return m_Vec;
}

//ポリゴン情報クラスへのベタアクセス
BigClass::GetPolygonCaretaker()
{
	return m_Polygon;
}

//親子情報クラスへのベタアクセス
BigClass::GetMake()
{
	return m_Make;
}

//場所情報クラスへのベタアクセス
BigClass::GetPoint()
{
	return m_Point;
}


//ポリゴンの指定されたつながりデータ(inTarget)を新しいデータ(inNew)に変更します.
BigClass::OptimizePolygonLinkChange(VecWorldEye* inTarget ,VecWorldEye* inNew)
{
	TLim3DPolygon* Poly = m_Polygon->FindFirst();
	if (Poly == NULL)	return ;
	do
	{	//つながりデータ機能への べたアクセス取得.
		TLim3DLinkData* theLinkData = Poly->GetLinkData();
		//ポリゴンのリンクデータにアクセスして、書き換えを行います.
		PolygonDataEx* thePolygonLinkDataIt = theLinkData->GetStart();
		PolygonDataEx* thePolygonLinkDataEnd= theLinkData->GetEnd();
		
		for( ; thePolygonLinkDataIt != thePolygonLinkDataEnd ; thePolygonLinkDataIt ++)
		{
			if ( thePolygonLinkDataIt->LinkVecPointer == inTarget)
			{	//ターゲットを発見しました. 書き換えます.
				thePolygonLinkDataIt->LinkVecPointer = inNew;
			}
		}
	}
	while( Poly = m_Polygon->FindNext() );
}

//頂点データ管理クラスで、頂点データの再アロケーションが実行された.
BigClass::ReAllocMemoryVec(VecWorldEye* OldMemoryAddress ,
							VecWorldEye* NewMemoryAddress ,  int OldUseSize)
{
	VecWorldEye*	TempData;
	VecWorldEye*	OldMemoryAddressEnd = OldMemoryAddress+OldUseSize;
	TLim3DPolygon* Poly = m_Polygon->FindFirst();
	if (Poly == NULL)	return ;
	do
	{	//つながりデータ機能への べたアクセス取得.
		TLim3DLinkData* theLinkData = Poly->GetLinkData();
		//ポリゴンのリンクデータにアクセスして、書き換えを行います.
		PolygonDataEx* thePolygonLinkDataIt = theLinkData->GetStart();
		PolygonDataEx* thePolygonLinkDataEnd= theLinkData->GetEnd();

		for( ; thePolygonLinkDataIt != thePolygonLinkDataEnd ; thePolygonLinkDataIt ++)
		{
			//長ったらしくなるので、処理対象のデータを写しておく.
			TempData = thePolygonLinkDataIt->LinkVecPointer;
			if ( TempData >= OldMemoryAddress && TempData < OldMemoryAddressEnd)
			{	//ターゲットを発見しました. 書き換えます.
				thePolygonLinkDataIt->LinkVecPointer =
					(VecWorldEye*)((DWORD)TempData -
							(DWORD)OldMemoryAddress + (DWORD)NewMemoryAddress);
			}
		}
	}
	while( Poly = m_Polygon->FindNext() );

	//子モデルによって、共有されているかもしれないので、
	//念のためすべての子を検索.
	TLim3DModel*	theChildModel ;
	for( theChildModel = FindFirstModel()  ;
				theChildModel != NULL ; theChildModel = FindNextModel() )
	{
		theChildModel->ReAllocMemoryVec
					(OldMemoryAddress , NewMemoryAddress , OldUseSize);
	}
}


//指定したモデルのコピーに自分がなる.
BigClass::CopyForm(TLim3DModel * inModel)
{
	m_Point->CopyForm( inModel->GetPoint() );
//	m_Polygon->CopyForm( inModel->GetPolygonCaretaker() );
//	m_Vec->CopyForm( inModel->GetVecCaretaker() );
//	m_Make->CopyForm( inModel->GetMake() );
}


//指定されたモデルが自分達が属する　親子関係で言う「ご先祖」にあたるかどうか調べる.
BigClass::IsForefathers(TLim3DModel * inModel)
{
	if ( this == inModel) return true;

	TLim3DModel * theParenceModel = GetParenceModel();
	if (theParenceModel == NULL) return false;
	return theParenceModel->IsForefathers(inModel);
}



//自分の親に対してのスキン処理を実行する.
BigClass::Skin()
{
	TLim3DModel * theParenceModel = GetParenceModel();
	//親が居ない場合は没.
	if (theParenceModel == NULL) return ;

	//自分の親の頂点へのアクセス経路を樹立.
	TLim3DVecCaretaker* theParenceVec = theParenceModel->GetVecCaretaker();

	//ワークエリア.
	VecWorldEye *it , *end , *ParenceIt , *ParenceEnd;
	//まず、回転行列を作成して、くるくるくるーって感じでワールドへ移行します.
	TMatrix		Mat;			//行列
	//回転行列作成.
	Mat.MakeTrans(m_Point->GetAngleX() , m_Point->GetAngleY() , m_Point->GetAngleZ() ,
					m_Point->GetPosX() , m_Point->GetPosY() , m_Point->GetPosZ());

	//すべての頂点を移動させるぞ!
	it  = m_Vec->GetStart();
	end  = m_Vec->GetEnd();
	for ( ; it != end ; it++)
	{
		Mat.VectorMul( &(it->World) , &(it->Vec) );
	}

	//共有できる頂点をサーチします.
	ParenceIt  = theParenceVec->GetStart();
	ParenceEnd = theParenceVec->GetEnd();
	for( ; ParenceIt != ParenceEnd ; ParenceIt++)
	{
		it  = m_Vec->GetStart();
		end  = m_Vec->GetEnd();
		for ( ; it != end ; it++)
		{
			//この World は、親座標での話です.
			if ( VectorCmp( &ParenceIt->Vec , &it->World , IF(3) ) )
			{	//変更できそうなので、ポリゴン君につたえる.
				OptimizePolygonLinkChange( it , ParenceIt);
			}
		}
	}
}

/***********************************************************/
//コンストラクタ
//引数							なし
//戻り値						なし
/***********************************************************/
BigClass::TReadMetasequoia()
{
	//マテリアル.
	m_Material			= NULL;
	//マテリアルの数.
	m_MaterialNum		= 0;
	//ファイルから読み込んだデータ.
	m_FileData			= NULL;
	//データの長さ.
	m_FileDataLen		= 0;
}

/***********************************************************/
//デストラクタ
//引数							なし
//戻り値						なし
/***********************************************************/
BigClass::~TReadMetasequoia()
{
	Init();
}

/***********************************************************/
//初期化.
//引数							なし
//戻り値						なし
/***********************************************************/
BigClass::Init()
{
	//マテリアル.
	if (m_Material) delete [] m_Material;
	m_Material			= NULL;
	//ファイルから読み込んだデータ.
	if (m_FileData) delete [] m_FileData;
	m_FileData			= NULL;
	//データの長さ.
	m_FileDataLen		= 0;
	//マテリアルの数.
	m_MaterialNum		= 0;
}

/***********************************************************/
//ファイルの読み込み.
//引数							inFileName	読み込むファイル名.
//戻り値						成功 true
/***********************************************************/
BigClass::Open(const char *inFileName)
{
	Init();

	FILE *		theFp;
	theFp = fopen(inFileName , "rb");
	if (theFp == NULL)	return false;

	//ファイルサイズを取得.
BigClass::fseek( theFp , 0 , SEEK_END);
BigClass::ftell(theFp);
BigClass::fseek( theFp , 0 , SEEK_SET);

	//領域の確保.
	m_FileData = new char[m_FileDataLen];

	//領域にデータを流し込む.
BigClass::fread( m_FileData , sizeof(char) , m_FileDataLen , theFp );

BigClass::fclose( theFp );
	
	//ヘッダチェック.
	if ( ! CheckHeader() )
	{//おかしいデータなので、終了.
		Init();
		return false;
	}
	//マテリアル取得.
	if ( ! GetMaterial() )
	{//おかしいデータなので、終了.
		Init();
		return false;
	}
	return true;
}

/***********************************************************/
//クローズ.
//引数							なし
//戻り値						成功 true
/***********************************************************/
BigClass::Close()
{
	Init();
	return true;
}


/***********************************************************/
//ヘッダチェック.
//引数							なし
//戻り値						成功 true
/***********************************************************/
BigClass::CheckHeader()
{
	__RTI_CHECKER(m_FileData != NULL);

	char	theFormatType[10];
	float	theVer;

BigClass::sscanf(m_FileData , "Metasequoia Document\r\nFormat %s Ver %f" 
												,theFormatType , &theVer );
	//フォーマット形式がテキストで無ければ没.
	if ( stricmp(theFormatType,"Text") != 0 ) return false;
	//バージョンが 1.0未満は没.
	if ( theVer < 1.0 ) return false;

	//OK.
	return true;
}

/***********************************************************/
//モデルの取得.
//引数							inObjectName	読み込むモデルの名前.
//								inModel			読み込ませるモデル.
//戻り値						成功 true
/***********************************************************/
BigClass::GetModel(const char* inObjectName , MODEL inModel)
{
	__RTI_CHECKER(m_FileData != NULL);
	__RTI_CHECKER(m_Material != NULL);
	__RTI_CHECKER(inObjectName != NULL);

	//現在処理している場所.
	char *theNowProc = m_FileData;
	//オブジェクトの名前.
	char theModelName[64];

	while( 1 )
	{
		//モデルタグを探す.
BigClass::strstr( theNowProc , "Object " );
		//タグ見つからない.
		if ( theNowProc == NULL)	return false;
		//オブジェクトが、指定されたオブジェクトと等しいかチェック.
BigClass::sscanf( theNowProc , "Object \"%63[^\"]\" {" , theModelName);
		//それが等しいか比べる、等しいならループを抜ける.
		if ( strcmp(inObjectName , theModelName) == 0)	break;
		//等しくないので、次のオブジェクトいくけど、 strstr を成功させるために +1で
		//文字列のポインタをずらします.
		theNowProc += 1;
	}
	//モデルが定義されていなかったら、ネームサーバーにそのモデルと
	//同じ名前を確保して、そこに格納します.
	MODEL theModel = inModel;
	if (theModel == NULL)
	{
BigClass::NewModel();
		//ネームサーバーに追加する.
BigClass::NameServer.Add( inObjectName , theModel );
	}
	//詳細な情報を取得します.
	GetModelDetail(theNowProc , theModel);

	return true;
}
/***********************************************************/
//すべてのモデルの取得.
//引数							なし
//戻り値						成功 true
/***********************************************************/
BigClass::GetAllModel()
{
	__RTI_CHECKER(m_FileData != NULL);
	__RTI_CHECKER(m_Material != NULL);

	//現在処理している場所.
	char *theNowProc = m_FileData;
	//オブジェクトの名前.
	char theModelName[64];
	//一時モデル.
	MODEL	theDummyModel;

	while( 1 )
	{
		//モデルタグを探す.
BigClass::strstr( theNowProc , "Object " );
		//タグ見つからない.
		if ( theNowProc == NULL)	return false;
		//オブジェクトが、指定されたオブジェクトと等しいかチェック.
BigClass::sscanf( theNowProc , "Object \"%63[^\"]\" {" , theModelName);

		//ネームサーバーにそのモデルと同じ名前を確保して、そこに格納します.
BigClass::NewModel();
		//ネームサーバーに追加する.
BigClass::NameServer.Add( theModelName , theDummyModel );
		//詳細な情報を取得します.
		GetModelDetail(theNowProc , theDummyModel);

		//次のオブジェクトいくけど、 strstr を成功させるために +1で
		//文字列のポインタをずらします.
		theNowProc += 1;
	}

	return true;
}

/***********************************************************/
//モデルの詳細な情報を取得します.
//引数							inObjectData	モデルタグの内容.
//								outModel		読み込ませるモデル.
//戻り値						なし
/***********************************************************/
BigClass::GetModelDetail(const char* inObjectData , MODEL outModel)
{
	__RTI_CHECKER(inObjectData != NULL);
	__RTI_CHECKER(outModel != NULL);

	//ここで、 現在の オブジェクトは処理すべきオブジェクトになっています.
	char *	theTargetPos;
	//頂点情報方法のサーチ.
BigClass::strstr(inObjectData , "vertex ");
	if (theTargetPos != NULL) GetModelDetailVertex(theTargetPos , outModel);
	//面情報方法のサーチ.
BigClass::strstr(inObjectData , "face ");
	if (theTargetPos != NULL) GetModelDetailFace(theTargetPos , outModel);
	//シェーディング方法のサーチ.
BigClass::strstr(inObjectData , "shading ");
	if (theTargetPos != NULL) GetModelDetailShading(theTargetPos , outModel);

	return;
}

/***********************************************************/
//シェーディング情報の取得.
//引数							inTagData		シェーディングの内容.
//								outModel		読み込ませるモデル.
//戻り値						なし
/***********************************************************/
BigClass::GetModelDetailShading(const char* inTagData , MODEL outModel)
{
	__RTI_CHECKER(inTagData != NULL);
	__RTI_CHECKER(outModel != NULL);

	//取得するシェーディング.
	int theShading = 0;
BigClass::sscanf(inTagData , " shading %d" , &theShading);

	//Lim3D ライブラリで使うシェーディング.
	ShadingLevel thePolygonShading ;
	switch(theShading)
	{
	case 0:
		thePolygonShading = FLAT_SHADING;		break;
	case 1:
		thePolygonShading = GROW_SHADING;		break;
	default:
		thePolygonShading = NONE_SHADING;		break;
	}
	
	//すべてのポリゴンにアクセスして､シェーディングレベルの設定.
	TLim3DPolygon* thePoly = outModel->FindFirstPolygon();
	if (thePoly == NULL)	return ;
	do
	{
		thePoly->SetShading(thePolygonShading);
	}
	while( thePoly = outModel->FindNextPolygon() );
}

/***********************************************************/
//頂点情報の取得.
//引数							inTagData		頂点の内容.
//								outModel		読み込ませるモデル.
//戻り値						なし
/***********************************************************/
BigClass::GetModelDetailVertex(const char* inTagData , MODEL outModel)
{
	__RTI_CHECKER(inTagData != NULL);
	__RTI_CHECKER(outModel != NULL);

	//取得する頂点情報.
	int theVertex = 0;
	sscanf(inTagData , " vertex %d {" , &theVertex);
	if (theVertex <= 0) return ;
	
	//現在処理しているところ.
	char * theNowProc = (char*) inTagData;
	//この数だけの頂点を入れます.
	XYZFixed * theVertexBuffer = new XYZFixed[theVertex];
	if (theVertexBuffer == NULL) return;

	int theI;
	for(theI = 0 ; theI < theVertex ; theI++)
	{
		//改行まで読み飛ばす.
BigClass::strstr(theNowProc , "\r\n" );
		if (theNowProc == NULL)
		{
			delete [] theVertexBuffer;
			return ;
		}
		//改行コードを飛ばします.
		theNowProc += sizeof("\r\n");
		//その次の行には頂点情報があるはずなので、読み込みます.
		GetVertexCaseByCase(  theNowProc , &theVertexBuffer[theI]);
	}
	//その頂点の追加.
	outModel->SetVec( theVertexBuffer , theVertex );
	//不要な作業バッファのクリア.
	delete [] theVertexBuffer;
}

/***********************************************************/
//その次の行には頂点情報があるはずなので、読み込みます.
//引数							inVertexData	頂点の内容.
//								outVertex		頂点を格納するバッファ.
//戻り値						なし
/***********************************************************/
BigClass::GetVertexCaseByCase
						(const char* inVertexData , XYZFixed * outVertex)
{
	__RTI_CHECKER(inVertexData != NULL);
	__RTI_CHECKER(outVertex != NULL);

	float theX,theY,theZ;
BigClass::sscanf(inVertexData , " %f %f %f" , &theX, &theY, &theZ);

	outVertex->x = Float2Fixed(theX);
	outVertex->y = Float2Fixed(theY);
	outVertex->z = Float2Fixed(theZ);
}

/***********************************************************/
//面情報の取得.
//引数							inTagData		面の内容.
//								outModel		読み込ませるモデル.
//戻り値						なし
/***********************************************************/
BigClass::GetModelDetailFace(const char* inTagData , MODEL outModel)
{
	__RTI_CHECKER(inTagData != NULL);
	__RTI_CHECKER(outModel != NULL);

	//取得する面情報.
	int theFace = 0;
BigClass::sscanf(inTagData , " face %d {" , &theFace);
	if (theFace <= 0) return ;
	
	//現在処理しているところ.
	char * theNowProc = (char*) inTagData;

	int theI;
	for(theI = 0 ; theI < theFace ; theI++)
	{
		//改行まで読み飛ばす.
BigClass::strstr(theNowProc , "\r\n" );
		if (theNowProc == NULL)		return ;
		//改行コードを飛ばします.
		theNowProc += sizeof("\r\n");
		//その次の行には面情報があるはずなので、読み込みます.
		bool theRet = GetFaceCaseByCase(  theNowProc , outModel);
		if (theRet == false) return ;
	}
}

/***********************************************************/
//面情報の取得.
//引数							inFaceData		1面の内容.
//								outModel		読み込ませるモデル.
//戻り値						成功 true
/***********************************************************/
BigClass::GetFaceCaseByCase(const char* inFaceData , MODEL outModel)
{
	__RTI_CHECKER(inFaceData != NULL);
	__RTI_CHECKER(outModel != NULL);

	//頂点数.
	int theVertexCount;
BigClass::sscanf(inFaceData , " %d " , &theVertexCount);
	//頂点数がいかれていたら没.
	if (theVertexCount < 3 || theVertexCount > 4)	return false;

	//リンクなデータ.
	int			theLink[4];
	//マテリアルナンバー
	int			theMaterial = 0;
	//UV
	float		theUV[4*2];

	if (theVertexCount == 3)
	{//三角形.
BigClass::sscanf(inFaceData , " %d V(%d %d %d) M(%d) UV(%f %f %f %f %f %f)" , 
			&theVertexCount , &theLink[2] , &theLink[1] , &theLink[0] ,
			&theMaterial , 
			&theUV[4] , &theUV[5] , &theUV[2] , &theUV[3] , &theUV[0] , &theUV[1] );
		//値のセット.
		GetFaceCaseByCasePolygonCreate( outModel , 3 , theLink , theMaterial , theUV );
	}
	else
	{//四角形.
BigClass::sscanf(inFaceData , " %d V(%d %d %d %d) M(%d) UV(%f %f %f %f %f %f %f %f)" ,
			&theVertexCount , &theLink[3] , &theLink[2] , &theLink[1] , &theLink[0] ,
			&theMaterial , 
			&theUV[6] , &theUV[7] , &theUV[4] , &theUV[5] ,
			&theUV[2] , &theUV[3] , &theUV[0] , &theUV[1]);
		//値のセット.
		GetFaceCaseByCasePolygonCreate( outModel , 4 , theLink , theMaterial , theUV );
	}
	return true;
}

/***********************************************************/
//そのつながりデータより、ポリゴンを作成する.
//引数							outModel		読み込ませるモデル.
//								inNum			頂点の数 3 or 4.
//								inLink			つながり
//								inMaterial		マテリアル
//								inUV			テクスチャのUV
//戻り値						なし
/***********************************************************/
BigClass::GetFaceCaseByCasePolygonCreate
				(MODEL outModel , int inNum ,
				 const int* inLink , int inMaterial , const float* inUV)
{
	__RTI_CHECKER(outModel != NULL);
	__RTI_CHECKER(inMaterial >= 0);
	__RTI_CHECKER(inMaterial <  m_MaterialNum);

	//ポリゴンの頂点のつながりをあらわすデータ.
	PolygonData thePolygonData[4];

	//テクスチャー.
	BMD theBmd = m_Material[inMaterial]->GetTexture();

	int theI ;
	for(theI = 0 ; theI < inNum ; theI++)
	{
		//頂点のつながり.
		thePolygonData[theI].Link = inLink[theI];
		//テクスチャーがあるとき.
		if (theBmd != NULL)
		{
			//頂点のテクスチャーの UV.
			thePolygonData[theI].Texture.x = ( inUV[theI*2 + 0] * theBmd->w);
			thePolygonData[theI].Texture.y = ( inUV[theI*2 + 1] * theBmd->h);
		}
	}
	//新規ポリゴン作成.
	TLim3DPolygon* thePolygon = outModel->NewPolygon();
	//そのポリゴンにさっきのデータをくわえて完成.
	thePolygon->SetLink( thePolygonData , inNum);
	//そのポリゴンとマテリアルを関連付けます.
	thePolygon->SetMaterial( m_Material[inMaterial] );
}


/***********************************************************/
//マテリアル取得.
//引数							なし.
//戻り値						成功 true
/***********************************************************/
BigClass::GetMaterial()
{
	__RTI_CHECKER(m_FileData != NULL);

	//現在処理している場所.
	char *theNowProc;

	//マテリアルタグを探す.
BigClass::strstr( m_FileData , "Material" );
	//タグ見つからない.
	if ( theNowProc == NULL)	return false;

	//マテリアルタグにある、マテリアル個数を取得.
	m_MaterialNum = 0;
	sscanf( theNowProc , "Material %d {" , &m_MaterialNum);
	if (m_MaterialNum <= 0) return false;
	//マテリアル領域の確保.
	m_Material = new MATERIAL[m_MaterialNum];
	if (m_Material == NULL)		return false;

	int MaterialDataNum = 0;
	for(MaterialDataNum = 0 ; MaterialDataNum < m_MaterialNum ; MaterialDataNum++)
	{
		//改行まで読み飛ばす.
BigClass::strstr(theNowProc , "\r\n" );
		if (theNowProc == NULL) return false;
		//改行コードを飛ばします.
		theNowProc += sizeof("\r\n");
		//その次の行にはマテリアルがあるはずなので、読み込みます.
		bool theRet = GetMaterialCaseByCase
						(  theNowProc , &m_Material[MaterialDataNum]);
		//マテリアル取得中のエラー.
		if (theRet == false)		return false;
	}
	return true;	
}

/***********************************************************/
//1マテリアル取得.
//引数							inMaterialData		1マテリアルのデータ.
//								outMaterial			読み込むマテリアル.
//戻り値						成功 true
/***********************************************************/
BigClass::GetMaterialCaseByCase
					(const char* inMaterialData , MATERIAL* outMaterial)
{
	char	theMaterialName[32]={0};		//材質名                 31Byte以内
	float	theR=0,theG=0,theB=0,theTrans=0;//色（ＲＧＢ）、不透明度 それぞれ0〜1
	float	theDif=0;						//拡散光                 0〜1
	float	theAmb=0;						//周囲光                 0〜1
	float	theEmi=0;						//自己照明               0〜1
	float	theSpc=0;						//反射光                 0〜1
	float	thePow=0;						//反射光の強さ           0〜100
	char	theTexName[64]={0};				//模様マッピング名       相対パスで記述（63Byte以内）
	char	theAlphaName[64]={0};			//透明マッピング名       相対パスで記述（63Byte以内)
	char	theBumpName[64]={0};			//凹凸マッピング名       相対パスで記述（63Byte以内）
	//こんな感じです.
	//	"mat1" col(1.000 0.275 0.459 1.000) dif(1.000) amb(0.250) emi(0.250) spc(0.000) power(5.00)
BigClass::sscanf(inMaterialData , "	\"%31[^\"]\" " \
			"col(%f %f %f %f) dif(%f) amb(%f) emi(%f) spc(%f) power(%f) " \
			"tex(\"%63[^\"]\") alpha(\"%63[^\"]\") bump(\"%63[^\"]\")",
			theMaterialName , &theR , &theG , &theB , &theTrans,
			&theDif , &theAmb , &theEmi , &theSpc , &thePow ,
			theTexName , theAlphaName , theBumpName			);

	//とりあえず、マスターにマテリアルの作成を申請します.
BigClass::NewMaterial();
	if (*outMaterial == NULL) return false;
	//いちいち、アスタリクスつけるのはだるいので...
	MATERIAL theMaterial = *outMaterial;

	//そのマテリアルを構築します.
	//色の決定.
	theMaterial->SetColor( ClasColor( theR , theG , theB , theEmi) );
	//ディフューズ.
	theMaterial->SetDiffuseReflexFactor( Float2Fixed(theDif) );
	//アンビエント.
	theMaterial->SetAmbientReflexFactor( Float2Fixed(theAmb) );
	//スペキャラー
	theMaterial->SetSpecularReflexFactor( Float2Fixed(theSpc) );
	//スペキャラー(反射光の強さ)
	theMaterial->SetVelvetyReflexFactor( Float2Fixed(thePow) );
	//テクスチャーマッピング.
	theMaterial->SetTexture( ClasTexture(theTexName) );
	//で、テクスチャーは結局使うの ? 
	if ( theMaterial->GetTexture() == NULL)
	{	//No テクスチャー.
		theMaterial->SetDrawing(BETA_DRAW);
	}
	else
	{	//Use テクスチャー.
		theMaterial->SetDrawing(TEXTURE_DRAW);
	}
	//ライティングモデルの決定.
	theMaterial->SetLighting
				( ClasLighting( theDif , theAmb , theSpc , thePow) );
	//ネームサーバーに追加する.
BigClass::NameServer.Add( theMaterialName , theMaterial );
	//成功.
	return true;
}


/***********************************************************/
//カラーを取得.
//引数							inR					赤.
//								inG					緑.
//								inB					青.
//								inEei				自分自身の色
//戻り値						色.
/***********************************************************/
BigClass::ClasColor( float inR , float inG , float inB , float inEmi)
{
	int theR = (int)(inR * inEmi * 255);
	int theG = (int)(inG * inEmi * 255);
	int theB = (int)(inB * inEmi * 255);

	if (theR > 0xff) theR = 0xff;
	if (theG > 0xff) theG = 0xff;
	if (theB > 0xff) theB = 0xff;

	return (theR << 16) + (theG << 8) + (theB);
}

/***********************************************************/
//テクスチャーマッピングをやるの ? やる場合は、その テクスチャーの BMDを返す.
//引数							inTextureName		テクスチャーのパス.
//戻り値						BMD
/***********************************************************/
BigClass::ClasTexture(const char * inTextureName)
{
	//ファイル名そのものがない.
	if (inTextureName[0] == '\0') return NULL;
	//マスターのテクスチャーを使う.
BigClass::NewTexture(inTextureName);
}

/***********************************************************/
//ライティング効果の設定.
//引数							inDif
//								inAmb
//								inSpc
//								inPow
//戻り値						ライティングレベル.
/***********************************************************/
BigClass::ClasLighting(float inDif ,float inAmb ,float inSpc ,float inPow)
{
	return LAMBERT_LIGHTING;
}


#include <./Lim3D/rti_Lim3DAnime.h>
#include <./Lim3D/rti_Lim3DMaster.h>
#include <stdio.h>

/*******************************************************************************/
//TLim3DAnimeControlクラス	アニメーションの管理をつかさどります
//							ユーザーはこのクラスの内容を知っていれば、
//							その他の下請けクラスは知らなくても OK なのらー.
/*******************************************************************************/

/*******************************************************************************/
//タグをサーチする.
//引数						inStart			シーンの開始場所.
//							inEnd			シーンの終了場所
//							inTag			タグ名.	Ex. "<MODEL = "
//							outEnd			見つけた文字列の最後.(失敗の時は未定義)
//戻り値					見つけた文字列の先頭.
/*******************************************************************************/
BigClass::SearchTag
		(const char* inStart , const char* inEnd , const char* inTag , char** outEnd)
{
	__RTI_CHECKER(inStart != NULL);
	__RTI_CHECKER(inEnd != NULL);
	__RTI_CHECKER(inTag != NULL);
	__RTI_CHECKER(outEnd != NULL);

	//最初にヒットする場所を返す.
BigClass::strstr( inStart , inTag);
	//取得失敗だったら没.
	if (theNowPos == NULL || theNowPos >= inEnd) return NULL;

	//次にヒットする場所を探す.
BigClass::strstr( theNowPos+1 , inTag);
	//取得できない or inEnd オーバーの時は、 inEnd が終端とする.
	if (*outEnd == NULL || *outEnd >= inEnd) *outEnd = (char*)inEnd;

	return theNowPos;
}

/*******************************************************************************/
//シーンデータ & タスクデータの破棄.
//引数						なし
//戻り値					なし
/*******************************************************************************/
BigClass::Clear()
{
	{
BigClass::iterator it = 	m_Seenvector.begin();
BigClass::iterator end= 	m_Seenvector.end();
		for( ; it != end ; it++)	
		{	
			delete *it;
		}
		m_Seenvector.clear();
	}
	{
BigClass::iterator it = 	m_Taskvector.begin();
BigClass::iterator end= 	m_Taskvector.end();
		for( ; it != end ; it++)	
		{	
			delete *it;
		}
		m_Taskvector.clear();
	}
}

/*******************************************************************************/
//アニメーションファイルを読み込みます.
//引数						inFileName		読み込むファイル名.
//戻り値					成功 true
/*******************************************************************************/
BigClass::Read(const char * inFileName)
{
	__RTI_CHECKER(inFileName != NULL);

	FILE *		theFp;
	theFp = fopen(inFileName , "rb");
	if (theFp == NULL)	return false;

	char *	theFileData;
	int		theFileLen;

	//ファイルサイズを取得.
BigClass::fseek( theFp , 0 , SEEK_END);
BigClass::ftell(theFp);
BigClass::fseek( theFp , 0 , SEEK_SET);

	//領域の確保.
	theFileData = new char[theFileLen];

	//領域にデータを流し込む.
BigClass::fread( theFileData , sizeof(char) , theFileLen , theFp );
	//ファイルのクローズ.
BigClass::fclose( theFp );

	//シーンを追加したりしていく.
	bool theRet = SeenSplit( theFileData , &theFileData[theFileLen] );
	if (theRet == false) return false;

	//読み込んだデータの破棄.
	delete [] theFileData;

	return true;
}

/*******************************************************************************/
//アニメーションの実行のためのタスクを作成する.
//引数						inAnimeName			アニメーション名.
//戻り値					成功 TLim3DAnimeTask*   / 失敗 NULL
/*******************************************************************************/
BigClass::TaskCreate(const char * inAnimeName)
{
	__RTI_CHECKER(inAnimeName != NULL);

	//ネームサーバーより、theModelName のモデルを探す.
	TLim3DAnimeSeen* theAnimeSeen = 
BigClass::NameServer.Get( inAnimeName );
	if (theAnimeSeen == NULL)	return NULL;

	//タスクの作成.
	TLim3DAnimeTask* theTask = new TLim3DAnimeTask(theAnimeSeen);
	if (theTask == NULL) return NULL;

	//リストに追加する.
	m_Taskvector.push_back(theTask);

	return theTask;
}

/*******************************************************************************/
//シーンを分解します.
//引数						inStart			シーンの開始場所.
//							inEnd			シーンの終了場所
//戻り値					成功 true
/*******************************************************************************/
BigClass::SeenSplit(const char * inStart ,const char * inEnd)
{
	__RTI_CHECKER(inStart != NULL);
	__RTI_CHECKER(inEnd != NULL);

	//場所制御.
	char * theNext =  (char*)inStart;
	char * theOld ;

	//シーンの名前.
	char theSeenName[64];

	while(1)
	{
		theOld = theNext;
BigClass::SearchTag( theOld , inEnd , "<SEEN = " , &theNext );
		if (theOld == NULL) break;
		//そのシーンの名前の取得.
BigClass::sscanf(theOld , "<SEEN = \"%63[^\"]\">" , &theSeenName);
		//シーン解析.
		SeenAnalysis(theSeenName, theOld , theNext);
	}
	return true;
}

/*******************************************************************************/
//シーン解析	Start と End がシーンデータ
//引数						inSeenName		シーンの名前
//							inStart			シーンの開始場所.
//							inEnd			シーンの終了場所
//戻り値					成功 true
/*******************************************************************************/
BigClass::SeenAnalysis(const char * inSeenName,
								  const char * inStart , const char * inEnd)
{
	__RTI_CHECKER(inSeenName != NULL);
	__RTI_CHECKER(inStart != NULL);
	__RTI_CHECKER(inEnd != NULL);

	bool theRet;
	//まず、シーンデータを作成する.
	TLim3DAnimeSeen* theSeen = new TLim3DAnimeSeen;
	if (theSeen == NULL)
	{//メモリ不足.
		return false;
	}
	//シーンをフレーム単位で分解します.
	theSeen->FreamSplit( inStart , inEnd);

	//ネームサーバーに追加する.
BigClass::NameServer.Add( inSeenName , theSeen );
	if (theRet == false)
	{//ネームサーバーに登録失敗.
		delete theSeen;
		return false;
	}
	//シーンをリストに追加します.
	m_Seenvector.push_back(theSeen);

	return true;
}

/*******************************************************************************/
//TLim3DAnimeTaskクラス		アニメーション実行を携わる.
//引数							
//戻り値					まだ継続 true / おしまい false
/*******************************************************************************/
BigClass::Action()
{
	__RTI_CHECKER(m_Seen != NULL);

	bool	theRet;
	//アニメーション指令を出す.
	theRet = m_Seen->Action( m_FreamNum , m_Time);	
	//時間を増やします.
	m_Time++;
	//アニメーションはまだ継続させます.
	if (theRet == true)	return true;

	//現在の m_FreamNoのフレームのアニメーションは終了しました.
	//次のフレームにセットして、時間をリセットします.
	m_FreamNum++;
	m_Time = 0;

	//ところで、アニメーションはまだつづくの ?
	theRet = m_Seen->IsContinue(m_FreamNum);
	if (theRet == true)	return true;

	//もう、おしまいの場合.

	switch( m_Option )
	{
	case __ENUM_LIM3D_ANIME_TASK_OPTION_NONE	:
		break;
	case __ENUM_LIM3D_ANIME_TASK_OPTION_REPERT	:
		m_FreamNum = 0;
		m_Time = 0;
		break;
	case __ENUM_LIM3D_ANIME_TASK_OPTION_AUTOKILL:
		break;
	}

	return false;

}



/*******************************************************************************/
//TLim3DAnimeSeenクラス		アニメのシーンを取り扱います.
//							アニメは、1 シーン
/*******************************************************************************/

/*******************************************************************************/
//指定されたフレームを実行命令を出す.
//							ioFream			再生するフレーム.
//							inTime			
//戻り値					true / アニメーション終了 false
/*******************************************************************************/
BigClass::Action(int inFreamNo, int inTime)
{
	__RTI_CHECKER(inFreamNo >= 0);
	__RTI_CHECKER(inFreamNo <= m_vector.size());

	bool theEndOfFreram;

	//そのフレームをアニメーション.
	theEndOfFreram = (m_vector[inFreamNo])->Action(inTime);
	//このフレームのアニメーションが完了したら、即リターン.
	if (theEndOfFreram == true)  return true;

	//このフレームは、終わりましたのでを求めます.
	return false;
}

/*******************************************************************************/
//フレームデータの破棄.
//引数						なし
//戻り値					なし
/*******************************************************************************/
BigClass::Clear()
{
BigClass::iterator it = 	m_vector.begin();
BigClass::iterator end= 	m_vector.end();
	for( ; it != end ; it++)	
	{	
		delete *it;
	}
	m_vector.clear();
}

/*******************************************************************************/
//フレームを分解します.
//							inStart			シーンの開始場所.
//							inEnd			シーンの終了場所
//戻り値					成功 true
/*******************************************************************************/
BigClass::FreamSplit(const char *  inStart , const char * inEnd)
{
	__RTI_CHECKER(inStart != NULL);
	__RTI_CHECKER(inEnd != NULL);

	//このフレームを何フレームで終了させればよいのか..
	int theFreamTime;

	//場所制御.
	char * theNext = (char*)inStart;
	char * theOld;

	while(1)
	{
		theOld = theNext;
BigClass::SearchTag( theOld , inEnd , "<FREAM = " , &theNext );
		if (theOld == NULL) break;
		//そのフレームの終了させる時間の取得.
BigClass::sscanf(theOld , "<FREAM = %d" , &theFreamTime);
		//シーン解析.
		FreamAnalysis(theFreamTime, theOld , theNext);
	}
	return true;
}

/*******************************************************************************/
//フレーム解析	Start と End がシーンデータ
//引数						inSeenName		シーンの名前
//							inStart			シーンの開始場所.
//							inEnd			シーンの終了場所
//戻り値					成功 true
/*******************************************************************************/
BigClass::FreamAnalysis(int inFreamTime,const char * inStart , const char * inEnd)
{
	__RTI_CHECKER(inFreamTime > 0);
	__RTI_CHECKER(inStart != NULL);
	__RTI_CHECKER(inEnd   != NULL);

	bool	theRet;
	//新規フレーム作成.
	TLim3DAnimeFream * theFream = new TLim3DAnimeFream;
	if (theFream == NULL) return false;
	//このフレームを各種アニメーション単位に分解.
	theRet = theFream->BaseSplit(inFreamTime , inStart , inEnd );
	if (theRet == false)
	{
		delete theFream;
		return false;
	}
	//フレームを登録.
	m_vector.push_back(theFream);

	return true;
}

/*******************************************************************************/
//TLim3DAnimeFreamクラス	アニメのシーンを取り扱います.
//							アニメは、1 シーン
/*******************************************************************************/
BigClass::m_AnalysisTable[] = 
{
BigClass::ThisAnalysis,
	NULL,
};

/*******************************************************************************/
//指定されたフレームを実行命令を出す.
//引数						inTime			現在の時間.
//戻り値					true / アニメーション終了 false
/*******************************************************************************/
BigClass::Action(int inTime)
{
	__RTI_CHECKER(inTime <= m_Time);

	//このフレームが持っているすべてのアニメーション単位(TLim3DAnimeBase)に
	//アニメーション指令を出します.
BigClass::iterator it = 	m_vector.begin();
BigClass::iterator end= 	m_vector.end();
	for( ; it != end ; it++)	
	{	//アニメーション実行.
		(*it)->Action();
	}
	//このフレームのアニメーションが終了していないならば...
	if ( inTime < m_Time)	return true;

	//終了しました.
	return false; 
}


/*******************************************************************************/
//各種アニメーション単位を分解します.
//引数						inSeenName		シーンの名前
//							inStart			シーンの開始場所.
//							inEnd			シーンの終了場所
//戻り値					成功 true
/*******************************************************************************/
BigClass::BaseSplit(int inFreamTime,const char * inStart , const char * inEnd)
{
	__RTI_CHECKER(inFreamTime > 0);
	__RTI_CHECKER(inStart != NULL);
	__RTI_CHECKER(inEnd != NULL);

BigClass::m_AnalysisTable;

	for( ; *theThisAnalysis ; theThisAnalysis++)
	{	//その各種アニメーション単位で分解.
		(*theThisAnalysis)( this , inFreamTime , inStart , inEnd);
	}
	m_Time = inFreamTime;

	return true;
}

/*******************************************************************************/
//各種アニメーション単位の破棄.
//引数						なし
//戻り値					なし
/*******************************************************************************/
BigClass::Clear()
{
BigClass::iterator it = 	m_vector.begin();
BigClass::iterator end= 	m_vector.end();
	for( ; it != end ; it++)	
	{	
		delete *it;
	}
	m_vector.clear();
}






/*******************************************************************************/
//TLim3DAnimeModel			モデルのアニメーション.
//							
/*******************************************************************************/


/*******************************************************************************/
//モデルアニメーションの解析.
//引数						inFream			Fream.
//							inSeenName		シーンの名前
//							inStart			シーンの開始場所.
//							inEnd			シーンの終了場所
//戻り値					成功 true
/*******************************************************************************/
BigClass::ThisAnalysis
		(TLim3DAnimeFream * inFream ,int inFreamTime,const char * inStart , const char * inEnd)
{
	__RTI_CHECKER(inFreamTime > 0);
	__RTI_CHECKER(inStart != NULL);
	__RTI_CHECKER(inEnd != NULL);
	//場所制御.
	char * theNext = (char*)inStart;
	char * theOld ;

	//モデルの名前.
	char theModelName[64];
	int	 theX , theY , theZ , theRX , theRY  , theRZ;
	int  theRev;

	while(1)
	{
		theOld = theNext;
BigClass::SearchTag( theOld , inEnd , "<MODEL = " , &theNext );
		if (theOld == NULL) break;
		//そのモデルの各種設定を取得、失敗したら没.
BigClass::sscanf(theOld , "<MODEL = \"%63[^\"]\" M(%d %d %d) R(%d %d %d)>" ,
						theModelName , &theX , &theY , &theZ , &theRX , &theRY  , &theRZ);
		if (theRev != 7) return false;

		//ネームサーバーより、theModelName のモデルを探す.
BigClass::NameServer.GetPointer( theModelName );
		MODEL theModel = *theModelPointer;

		if (theModel == NULL)	return false;

		//モデルの作成、失敗したら没.
		TLim3DAnimeModel* theAnimeModel = new TLim3DAnimeModel;
		if (theAnimeModel == NULL) return false;

		//データのセット.
		theAnimeModel->m_Model = theModelPointer;
		theAnimeModel->DataSet(inFreamTime , (Fixed)theX , (Fixed)theY , (Fixed)theZ , 
											(Angle)theRX , (Angle)theRY ,(Angle)theRZ );
		//Freamに登録.
		inFream->Add(theAnimeModel);
	}
	return true;
}


#include <./Lim3D/rti_Lim3DMaster.h>


//ライティング
BigClass::Lighting(POLYGON inPoly,
					XYZFixed const *inPos , TLim3DMaterial* inMaterial)
{
	//ライトの効果によって振り分け.
	switch( inMaterial->GetLighting() )
	{
	case NONE_LIGHTING:		//ライティングなし
		break;
	case DEFUSE_LIGHTING:	//ディフューズ
		return Diffuse( inPoly ,  inPos , inMaterial);
		break;
	case SPECULAR_LIGHTING:	//スペキュラー
		return Specular( inPoly ,  inPos , inMaterial);
		break;
	case AMBIENT_LIGHTING:	//アンビエント
		return Ambient( inPoly , inMaterial);
		break;
	case LAMBERT_LIGHTING:	//ランバー (ディフューズ + アンビエント)
		return Lambert( inPoly ,  inPos , inMaterial);
		break;
	case PHONG_LIGHTING:	//フォン   (ディフューズ + アンビエント + スペキュラー)
		return Phong( inPoly ,  inPos , inMaterial);
		break;
	}
	return 0;
}

//ディフューズ
BigClass::Diffuse(POLYGON inPoly,
					XYZFixed const *inPos , TLim3DMaterial* inMaterial)
{
	/*
	*  ^     ^
	*   \ cos|
	*    \ Θ|
	*revL \  |N       revL は、左上に向かってます.
	*      \ |        N    は、上にむかってます.
	*       \|
	*------------------                      
	*       ポリゴンだよん
	*/
	XYZFixed		theRevLight;			//逆ライトベクトル
	//pos に対するこのライトの逆ライトベクトルを求める.
    GetRevLightVector(&theRevLight,inPos);
	Fixed theDiffuse;
	{
		register Fixed	theCosA;
		// revLight ･ HousenVector  で 明るさ(-1〜1)が求まります.
        theCosA = DotProduct(&theRevLight,inPoly->GetHousenVector() );
        if (theCosA < 0)
        {	//光はあたってません.
    		return 0;
        }
		theDiffuse = FixedMul( theCosA, inMaterial->GetDiffuseReflexFactor() );
	}
	if (theDiffuse <= 0)
	{	//すべて 0
   		return 0;
	}
	if (theDiffuse >= IF(1) ) 
	{	//そのまんまの色
		return m_RGB;
	}

	//このライトによる色を作る.
	return MulColor(m_RGB,theDiffuse);
}

//スペキュラー
BigClass::Specular(POLYGON inPoly,
					XYZFixed const *inPos , TLim3DMaterial* inMaterial)
{
	/*
	* スペキュラーはちぃっとややこしいです.
	*       ^   ^N  ^       N は、法線ベクトル 上に向かってます.
	*       L\  |  \R	   	L は、逆光線ベクトル 左上に向かってます.
	*         \ | \         R は、反射光ベクトル 右上に向かってます.
	*          \|\          まず、  R を求めます.
	*  -------------------
	*    ポリゴンの面
	*Tag1
	*
	*
	*    ^cosa^
	*     \   |N          L･N により、 Cos a を求める.
	*     L\  |           
	*       \ |
	*        \|
	* --------C----------------
	*
	*Tag2
	*         ^
	*         |
	*    ^ ---|P		L * CosAにより、 N に L を投影します.
	*     \   |         すると、 N の大きさは、 CP となります.
	*     L\  |N        CP を 2 倍します.   
	*       \ |
	*        \|
	* --------C----------------
	*
	*Tag3
	*
	*
	*         ^	           2倍したCP  と、 L を足し算します.
	*        /|            すると、ベクトル G が求まります.
	*     G / |            つまり、二等辺三角形がかけるわけです.
	*      /  |
	*     /   |            そして、 なんと、 G は、 R と同じになるのです.
	*    ^ ---|P		    ベクトルは方向をあらわすものなので、位置は関係ありません.
	*     \   |         
	*     L\  |N        
	*       \ |
	*        \|
	* --------C----------------
	*
	*Tag4
 	*   ^    ^   
	*  N|  R/   /         R と E (視点ベクトル) の内積を求めます.
	*   |  /b /E          すると、
	*   | / /  Cos b      Cos b が求まります.
	*   |/<               
	*---------------------
	*
	*Tag5               
	*     その後、 CosB^n * ks となり、スペキュラーの強さが求まる.
	*     n は、物体の柔らかさです.  小さいとスペキュラーの範囲が広がり、
	*     大きければ、範囲は狭くなります.
	*
	*/
	XYZFixed  theRevLight;					//逆ライトベクトル
	XYZFixed  theR;							//ベクトルR
	XYZFixed  theRevE;						//逆視点ベクトル
	//カメラの位置.
BigClass::GetSelectEye())->GetPoint()->GetPos();
	//inPos に対するこのライトの逆ライトベクトルを求める.
    GetRevLightVector(&theRevLight,inPos);
	//inPos に対するこの視点の逆視点ベクトルを求めます.
	VectorSub( &theRevE , theEyePos ,  inPos);
	Fixed theSpecular;
	{
		register Fixed	theCosA;
		// theRevLight ･ 法線  で 明るさ(-1〜1)が求まります.
        theCosA = DotProduct(&theRevLight,inPoly->GetHousenVector() );
		if (theCosA < 0)
		{	//すべて 0
	   		return 0;
		}
		//ベクトルCP
		XYZFixed theCP;	
		//theCosA * theRevLightにより CP を求めます.
		VectorMul( &theCP , &theRevLight , theCosA);
		//ベクトル CP を 2 倍します.
		theCP.x *= 2;		theCP.y *= 2;		theCP.z *= 2;
		//ベクトル theCP + theRevLight により、ベクトルR (ベクトルG) を求めます.
		VectorAdd( &theR , &theCP , &theRevLight);
		//theR , theRevE の正規化.
        Normalize(&theR);        Normalize(&theRevE);
		//ベクトル theR と、逆視点ベクトルにより、 theCosB (変数はCosA (^^;) を求める.
        theCosA = DotProduct(&theR,&theRevE);
		if (theCosA < 0)
		{	//すべて 0
	   		return 0;
		}
		//CosB ^ 物体の軟らかさ(0〜) * 鏡面反射係数
		theSpecular = FixedMul(fxpow(theCosA,inMaterial->GetVelvetyReflexFactor() )
												, inMaterial->GetSpecularReflexFactor() );
	}
	if (theSpecular <= 0)
	{	//すべて 0
   		return 0;
	}
	if (theSpecular >= IF(1) ) 
	{	//そのまんまの色
   		return m_RGB;
	}
	//このライトによる色を作る.
	return MulColor(m_RGB,theSpecular);
}

//アンビエント
BigClass::Ambient(POLYGON inPoly , TLim3DMaterial* inMaterial)
{
	//このライトによる色を作る.
	return MulColor(m_RGB, inMaterial->GetAmbientReflexFactor() );
}

//ランバー
BigClass::Lambert(POLYGON inPoly,
					XYZFixed const *inPos , TLim3DMaterial* inMaterial)
{
	XYZFixed		theRevLight;			//逆ライトベクトル
	//pos に対するこのライトの逆ライトベクトルを求める.
    GetRevLightVector(&theRevLight,inPos);
	Fixed theLambert;
	{
		register Fixed	theCosA;
		// revLight ･ HousenVector  で 明るさ(-1〜1)が求まります.
        theCosA = DotProduct(&theRevLight,inPoly->GetHousenVector() );
        if (theCosA < 0)
        {	//光はあたってません.
    		return 0;
        }
		theLambert = FixedMul( theCosA, inMaterial->GetDiffuseReflexFactor() ) 
											+ inMaterial->GetAmbientReflexFactor();
	}
	if (theLambert <= 0)
	{	//すべて 0
   		return 0;
	}
	if (theLambert >= IF(1) ) 
	{	//そのまんまの色
   		return m_RGB;
	}

	//このライトによる色を作る.
	return MulColor(m_RGB,theLambert);
}

//フォン
BigClass::Phong(POLYGON inPoly,
				XYZFixed const *inPos , TLim3DMaterial* inMaterial)
{
	XYZFixed  theRevLight;					//逆ライトベクトル
	XYZFixed  theR;							//ベクトルR
	XYZFixed  theRevE;						//逆視点ベクトル
	//カメラの位置.
BigClass::GetSelectEye())->GetPoint()->GetPos();
	//inPos に対するこのライトの逆ライトベクトルを求める.
    GetRevLightVector(&theRevLight,inPos);
	//inPos に対するこの視点の逆視点ベクトルを求めます.
	VectorSub( &theRevE , theEyePos ,  inPos);
	Fixed thePhong = 0;
	while(1)
	{
		register Fixed	theCosA;
		// theRevLight ･ 法線  で 明るさ(-1〜1)が求まります.
        theCosA = DotProduct(&theRevLight,inPoly->GetHousenVector() );

		if (theCosA < 0)	break;
		thePhong = FixedMul( theCosA , inMaterial->GetDiffuseReflexFactor() )
											+ inMaterial->GetAmbientReflexFactor();
		//ベクトルCP
		XYZFixed theCP;	
		//theCosA * theRevLightにより CP を求めます.
		VectorMul( &theCP , &theRevLight , theCosA);
		//ベクトル CP を 2 倍します.
		theCP.x *= 2;		theCP.y *= 2;		theCP.z *= 2;
		//ベクトル theCP + theRevLight により、ベクトルR (ベクトルG) を求めます.
		VectorAdd( &theR , &theCP , &theRevLight);
		//theR , theRevE の正規化.
        Normalize(&theR);        Normalize(&theRevE);
		//ベクトル theR と、逆視点ベクトルにより、 theCosB (変数はCosA (^^;) を求める.
        theCosA = DotProduct(&theR,&theRevE);
		if (theCosA < 0)	break;

		//CosB ^ 物体の軟らかさ(0〜) * 鏡面反射係数
		thePhong = FixedMul(fxpow(theCosA,inMaterial->GetVelvetyReflexFactor() )
												, inMaterial->GetSpecularReflexFactor() );
		break;
	}
	if (thePhong <= 0)
	{	//すべて 0
		return 0;
	}
	if (thePhong >= IF(1) ) 
	{	//そのまんまの色
		return m_RGB;
	}
	//このライトによる色を作る.
	return MulColor(m_RGB,thePhong);
}


//ライトの回転角度を指定.
BigClass::SetRotate(Angle x,Angle y,Angle z)
{
	m_Point.SetAngleX(x);
	m_Point.SetAngleY(y);
	m_Point.SetAngleZ(z);
}
//ライトの場所を指定.
BigClass::SetPos(Fixed x,Fixed y,Fixed z)
{
	m_Point.SetPosX(x);
	m_Point.SetPosY(y);
	m_Point.SetPosZ(z);
}
//ライトの回転角度を取得.
BigClass::GetRotate(Angle *x,Angle *y,Angle *z)
{
	*x = m_Point.GetAngleX();
	*y = m_Point.GetAngleY();
	*z = m_Point.GetAngleZ();
}
//ライトの場所を取得.
BigClass::GetPos(Fixed *x,Fixed *y,Fixed *z)
{
	*x = m_Point.GetPosX();
	*y = m_Point.GetPosY();
	*z = m_Point.GetPosZ();
}
//ライトの回転角度を増やす.
BigClass::AddRotate(int x,int y,int z)
{
	m_Point.SetAngleX(m_Point.GetAngleX() + x);
	m_Point.SetAngleY(m_Point.GetAngleY() + y);
	m_Point.SetAngleZ(m_Point.GetAngleZ() + z);
}
//ライトの場所を移動する.
BigClass::AddPos(Fixed x,Fixed y,Fixed z)
{
	m_Point.SetPosX(m_Point.GetPosX() + x);
	m_Point.SetPosY(m_Point.GetPosY() + y);
	m_Point.SetPosZ(m_Point.GetPosZ() + z);
}

//場所情報クラスへのベタアクセス
BigClass::GetPoint()
{
	return &m_Point;
}

//逆光線ベクトルを求める.
BigClass::GetRevLightVector(XYZFixed* outRevLightVector , XYZFixed const *inPos)
{
	//ライトの位置より現在値を引いて、逆視点ベクトルを求めます.
	VectorSub(outRevLightVector, GetPoint()->GetPos() , inPos);
	//それを正規化します.
	Normalize(outRevLightVector);
}

//このライトによる色を作る.
BigClass::MulColor(DWORD inOrignalRGB,Fixed inParsent)
{
	int theR,theG,theB;

	theR = (inOrignalRGB & 0x00ff0000) >> 16;
	theG = (inOrignalRGB & 0x0000ff00) >>  8;
	theB = (inOrignalRGB & 0x000000ff)      ;

	theR = FI(theR*inParsent);
	theG = FI(theG*inParsent);
	theB = FI(theB*inParsent);

	if (theR > 0xff) theR = 0xff;
	if (theG > 0xff) theG = 0xff;
	if (theB > 0xff) theB = 0xff;

	return (theR << 16) + (theG << 8) + (theB);
}
